WEBVTT
Kind: captions
Language: ja-JP

00:00:00.500 --> 00:00:03.160
これまで
パーティクルフィルターを実装するためのいくつかのテクニックと

00:00:03.160 --> 00:00:05.470
フィルターの正確さを
評価する方法を学んだ

00:00:05.469 --> 00:00:07.900
ことになります

00:00:07.900 --> 00:00:10.630
ここで 
コードの概要を説明します

00:00:10.630 --> 00:00:14.020
このコードは プロジェクトを完成させる
ために使用します

00:00:14.019 --> 00:00:17.919
最初に 
maincpp ファイルを見てみましょう

00:00:17.920 --> 00:00:20.470
このファイルは粒子フィルター
を実行するだけでなく

00:00:20.469 --> 00:00:23.169
実行時間を測定して 
各ステップにおいて

00:00:23.170 --> 00:00:26.170
加重誤差
を計算します

00:00:26.170 --> 00:00:27.670
最初に
しなければならない点は

00:00:27.670 --> 00:00:30.100
To Do コメントにおいてフィルター内の
粒子の数

00:00:30.100 --> 00:00:32.728
を設定することです

00:00:32.728 --> 00:00:36.420
M は 抽出する粒子の 
数です

00:00:36.420 --> 00:00:38.609
これは 使用することになる
異なる測定の

00:00:38.609 --> 00:00:41.579
不確実性
です

00:00:41.579 --> 00:00:46.469
次に 各タイム ステップで メイン関数が 
数学データ 制御データ

00:00:46.469 --> 00:00:52.329
 観察データ
を読み取ります

00:00:52.329 --> 00:00:54.869
このループでは
To Do コメントにおいて

00:00:54.869 --> 00:01:00.119
粒子フィルターの 1 ステップ
を実装することができます

00:01:00.119 --> 00:01:01.829
各時間のステップにおいて
 加重エラー

00:01:01.829 --> 00:01:05.649
を計算し
表示します

00:01:05.650 --> 00:01:07.440
最後に 
粒子フィルター

00:01:07.439 --> 00:01:10.140
が
すべての運転シーケンスを終了すると

00:01:10.140 --> 00:01:14.150
メイン関数は
フィルターの実行時間を計算し

00:01:14.150 --> 00:01:16.710
maincpp となります

00:01:16.709 --> 00:01:19.140
多くの
粒子フィルター コードを

00:01:19.140 --> 00:01:21.269
particlefilter.cpp で実装します

00:01:21.269 --> 00:01:23.640
このファイルには 
粒子フィルター クラス

00:01:23.640 --> 00:01:26.459
の関数の実装が
含まれます

00:01:26.459 --> 00:01:28.199
プロジェクトを完了するために 
各関数を

00:01:28.200 --> 00:01:30.329
振り返ります

00:01:30.329 --> 00:01:32.700
最初に完了すべき関数は 
init です

00:01:32.700 --> 00:01:35.840
この関数は 測定に関する
GPS 位置の入力

00:01:35.840 --> 00:01:39.120
初期方位推定値 
一連の不確実性

00:01:39.120 --> 00:01:40.439
を取ります

00:01:40.439 --> 00:01:43.200
これらの測定値を中心とした
ガウス分布

00:01:43.200 --> 00:01:46.109
からサンプリングして 
すべての粒子を初期化します

00:01:46.109 --> 00:01:49.230
また 
すべての粒子の重量を 1 に初期化します

00:01:49.230 --> 00:01:51.570
ここで
 particle_struct

00:01:51.569 --> 00:01:53.729
の詳細は、particle_filterhで確認できます

00:01:53.730 --> 00:01:56.130
粒子フィルター クラス
には 更新されている

00:01:56.129 --> 00:01:57.719
粒子の内部構造があります

00:01:57.719 --> 00:02:00.480
この関数からは 
何も返されません

00:02:00.480 --> 00:02:03.060
次の関数は 予測です

00:02:03.060 --> 00:02:05.609
この関数は
入力として

00:02:05.609 --> 00:02:09.599
時間ステップ間の時間量 
速度とヨー レート

00:02:09.599 --> 00:02:13.620
測定の不確実性 
現在のタイムステップ速度

00:02:13.620 --> 00:02:16.030
ヨー レート測定を取ります

00:02:16.030 --> 00:02:17.560
これらの測定値を
用いて

00:02:17.560 --> 00:02:19.900
各パーティクルの
予測位置を更新し

00:02:19.900 --> 00:02:23.830
ガウス ノイズを追加することで センサー ノイズ
を計算します

00:02:23.830 --> 00:02:25.900
繰り返しになりますが
更新されたパーティクル位置

00:02:25.900 --> 00:02:28.330
に等しい平均値と
測定値の標準偏差に等しい

00:02:28.330 --> 00:02:31.240
標準偏差をもつ
ガウス分布から

00:02:31.240 --> 00:02:34.090
サンプリングすることによって
ガウス ノイズ

00:02:34.090 --> 00:02:35.331
を追加できます

00:02:39.020 --> 00:02:40.909
データ関連
関数

00:02:40.909 --> 00:02:45.469
は入力としてランドマーク
obs オブジェクトの 2 つのベクトルを取ります

00:02:45.469 --> 00:02:47.719
helperfunctions.h.
では この構造の

00:02:47.719 --> 00:02:49.250
定義を見つけることができます

00:02:53.139 --> 00:02:55.189
この最初のベクトルは 
一つの粒子とセンサー範囲内の地図の

00:02:55.189 --> 00:02:57.979
ランドマークとの間の
予測測定

00:02:57.979 --> 00:02:59.519
です

00:03:02.740 --> 00:03:05.590
他のベクトルは 
LIDAR から収集された

00:03:05.590 --> 00:03:07.780
実際のランドマークの測定値です

00:03:07.780 --> 00:03:09.879
この関数は 
最も近いデータの

00:03:09.879 --> 00:03:12.939
関連付けを行い 
各センサーの観察データ

00:03:12.939 --> 00:03:16.740
を関連している地図のランドマークに割り当て
ます

00:03:16.740 --> 00:03:19.439
次に 重み更新関数を 
完了する必要があります

00:03:19.439 --> 00:03:22.859
この関数は
入力として

00:03:22.860 --> 00:03:25.880
センサーの範囲 
ランドマークの測定の不確実性

00:03:25.879 --> 00:03:28.740
ランドマーク測定
のベクトル

00:03:28.740 --> 00:03:31.237
地図のランドマークを取ります

00:03:31.236 --> 00:03:32.819
ここですべき
最初のことは

00:03:32.819 --> 00:03:35.129
各パーティクルの 
センサー範囲内の測定を

00:03:35.129 --> 00:03:39.609
全てのマップ上にあるランドマークに
対する測定値を予測することです

00:03:39.610 --> 00:03:42.040
この
ランドマーク測定を予測している場合は 実装した

00:03:42.039 --> 00:03:43.989
データ関連付け
関数

00:03:43.990 --> 00:03:47.320
により 
センサー測定を

00:03:47.319 --> 00:03:49.280
地図のランドマークに関連付けることができます

00:03:49.280 --> 00:03:51.409
多変量ガウス分布
確率密度関数

00:03:51.409 --> 00:03:53.629
を使用して 
各パーティクルの新しい重み

00:03:53.629 --> 00:03:56.930
を計算するために 
関連が必要ですが

00:03:56.930 --> 00:03:58.980
このレッスンで説明します

00:03:58.979 --> 00:04:01.340
最後に 
重みが

00:04:01.340 --> 00:04:03.710
0 ～ 1
の範囲になるように正規化します

00:04:03.710 --> 00:04:06.260
その理由としては 
これらの重みをリサンプリングの

00:04:06.259 --> 00:04:09.739
確率として使用するからです

00:04:09.740 --> 00:04:10.909
完成まであと一歩です

00:04:10.909 --> 00:04:13.544
次の関数は 
リサンプル関数です

00:04:13.544 --> 00:04:15.919
粒子の重みを
粒子

00:04:15.919 --> 00:04:20.149
フィルターで使用し c++ 標準の
ライブラリ離散分布

00:04:20.149 --> 00:04:22.819
関数
の重みを使用して ベイズの

00:04:22.819 --> 00:04:26.719
事後分布に更新します

00:04:26.720 --> 00:04:28.870
最後の
ステップです

00:04:28.870 --> 00:04:30.759
加重誤差を計算して
粒子フィルター

00:04:30.759 --> 00:04:33.069
を
評価できます

00:04:33.069 --> 00:04:35.199
この関数は入力として 
特定の時間ステップにおいて

00:04:35.199 --> 00:04:37.689
地上検証データ
位置を取り

00:04:37.689 --> 00:04:40.389
各粒子の重み
を使って粒子フィルター

00:04:40.389 --> 00:04:43.819
の加重
エラーを計算します

00:04:43.819 --> 00:04:47.360
コードの詳細に興味がある場合は 
helperfunction.h

00:04:47.360 --> 00:04:52.129
map.h particlefilter.h if
ファイルを確認

00:04:52.129 --> 00:04:54.719
するようにします

00:04:54.720 --> 00:04:57.830
コードをビルドして
実行するには 端末を開き

00:04:57.829 --> 00:05:00.949
 
ローカライゼーション粒子フィルター

00:05:00.949 --> 00:05:06.379
のホーム ディレクトリを開き 
build.sh

00:05:06.379 --> 00:05:11.300
を入力し 粒子フィルターを実行するために .sh 
を実行します

00:05:11.300 --> 00:05:13.581
皆さんに引き継ぎます

00:05:13.581 --> 00:05:16.040
粒子フィルターのプロジェクトを完成させるのに
必要なツールは

00:05:16.040 --> 00:05:17.510
すべてそろっています

00:05:17.509 --> 00:05:20.469
楽しんでください 
別のレッスンでお会いしましょう

