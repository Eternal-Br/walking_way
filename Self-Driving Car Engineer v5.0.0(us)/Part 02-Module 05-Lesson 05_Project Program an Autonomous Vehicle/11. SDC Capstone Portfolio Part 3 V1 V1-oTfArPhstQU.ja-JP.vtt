WEBVTT
Kind: captions
Language: ja-JP

00:00:00.000 --> 00:00:01.710
やあ お帰りなさい

00:00:01.710 --> 00:00:05.099
では Capstone プロジェクトのチュートリアルの 3番目ですエリンです

00:00:05.099 --> 00:00:06.059
スティーブンです

00:00:06.059 --> 00:00:09.269
ここまで ウェイポイントの生成方法

00:00:09.269 --> 00:00:11.429
車にこれらのウェイポイントを通過させる方法を見てきました

00:00:11.429 --> 00:00:14.160
ここでは 交差点の分類について見ていきます

00:00:14.160 --> 00:00:18.660
はい では このノードで行うことは 基本的に

00:00:18.660 --> 00:00:21.495
自分から一番近い信号のウェイポイントと状態をパブリッシュすることです

00:00:21.495 --> 00:00:25.890
そして 信号に従って車を停止する方法を見つけ出します

00:00:25.890 --> 00:00:29.100
素晴らしいこの部分では

00:00:29.100 --> 00:00:32.670
TensorFlow を使って自分で構築した分類器を実際に使用できます

00:00:32.670 --> 00:00:35.030
はい できますこのチュートリアルでは

00:00:35.030 --> 00:00:38.370
信号を分類するモデルの構築については話しません

00:00:38.369 --> 00:00:43.500
でも 一番近いウェイポイントをパブリッシュするコードの構造について見ていきます

00:00:43.500 --> 00:00:46.814
問題ないようですいいですね では早速はじめていきましょう

00:00:46.814 --> 00:00:50.219
私は tl_detector.py を開いています

00:00:50.219 --> 00:00:53.365
最初にロードしたときに それがどのように見えるのかをお見せしましょう

00:00:53.365 --> 00:00:56.030
サブスクライバーを見てみましょう

00:00:56.030 --> 00:00:58.085
/current_poseと/base_waypointsを取得しています

00:00:58.085 --> 00:00:59.329
これらはあるといいものです

00:00:59.329 --> 00:01:00.859
traffic_lights を取得しました

00:01:00.859 --> 00:01:04.819
分類器を使用する代わりに シミュレーターが送信するそのデータを使用して

00:01:04.819 --> 00:01:08.929
信号の状態が何かわかるんですよね?

00:01:08.930 --> 00:01:10.790
はいシミュレーターを使用すると 信号機メッセージには

00:01:10.790 --> 00:01:15.500
信号の状態が 赤 青 黄のどれかがわかります

00:01:15.500 --> 00:01:16.969
もちろんこれは車にはないので、

00:01:16.969 --> 00:01:18.859
車ではクラシファイに頼る必要がありますが、

00:01:18.859 --> 00:01:20.254
でも テスト目的の場合

00:01:20.254 --> 00:01:21.890
分類器を使用する前に

00:01:21.890 --> 00:01:24.469
シミュレーターからの情報に依存することもできます

00:01:24.469 --> 00:01:26.030
いいはじまりですね

00:01:26.030 --> 00:01:29.879
traffic_waypoint があり それをパブリッシュしています

00:01:29.879 --> 00:01:33.130
また image color もあります

00:01:33.129 --> 00:01:34.869
これはいったい何でしょうか

00:01:34.870 --> 00:01:38.785
image color はカメラのデータで 車のカメラからきています

00:01:38.784 --> 00:01:42.340
よって このチュートリアルでは image color は使用しないと思います

00:01:42.340 --> 00:01:43.630
というのもそれは使用しないので でもまあ あとで

00:01:43.629 --> 00:01:44.709
ちがうタイプがあるんですよね?

00:01:44.709 --> 00:01:45.469
はい

00:01:45.469 --> 00:01:46.795
生データのような

00:01:46.795 --> 00:01:48.040
生イメージも

00:01:48.040 --> 00:01:52.890
はいrepo は分類器で image color を使うようにセットアップされていると思いますが

00:01:52.890 --> 00:01:56.099
代わりに image raw を使う方法もあります

00:01:56.099 --> 00:01:57.539
理由は特に何かあるんですか?

00:01:57.540 --> 00:01:59.580
image raw があって 新しい color スキーマに変換すると

00:01:59.579 --> 00:02:02.774
データを失う可能性があります

00:02:02.775 --> 00:02:03.960
分類器を構築しているとき

00:02:03.959 --> 00:02:05.879
分類器は 人が行うように特定の color スキーマを

00:02:05.879 --> 00:02:08.189
視覚で見る必要はありません

00:02:08.189 --> 00:02:10.949
分類器に情報が集まれば集まるほどそれにこしたことはありません

00:02:10.949 --> 00:02:13.724
ここに分類器をセットアップするコードがあります

00:02:13.724 --> 00:02:17.025
また 通常あるコールバックもあります

00:02:17.025 --> 00:02:21.555
また それがこの traffic callback から信号の情報がくるところで

00:02:21.555 --> 00:02:23.640
またこの image callback もあります

00:02:23.639 --> 00:02:26.629
traffic lights get-light-state のこのプロセスと同じように

00:02:26.629 --> 00:02:30.370
それは重要なもののようですね

00:02:30.370 --> 00:02:33.715
はいでは この上の部分のこのコードはどうなっているのでしょうか

00:02:33.715 --> 00:02:36.219
毎回イメージが 1 つ入ってくると それをどうしているのでしょうか?

00:02:36.219 --> 00:02:40.194
この process_traffic_lights を取得しているようです

00:02:40.194 --> 00:02:43.284
これはstateとlight_wpを提供します

00:02:43.284 --> 00:02:47.139
このイメージではじめるなら

00:02:47.139 --> 00:02:51.245
メッセージから保存しているこの camera image があります

00:02:51.246 --> 00:02:53.860
それにこのステートもあります

00:02:53.860 --> 00:02:57.928
それは process_traffic_lights をもとにした信号の状態です

00:02:57.927 --> 00:03:00.819
はい最初にこれを詳しく見ていくべきですね

00:03:00.819 --> 00:03:04.034
ステートパラメータが使用できる値は何かを見ていきます

00:03:04.034 --> 00:03:08.579
コードの結果を見て それから process_traffic_lights を見てみましょう

00:03:08.580 --> 00:03:13.170
ここでは closest_light とこの line_waypoint_ndex があります

00:03:13.169 --> 00:03:14.849
両方とも none です

00:03:14.849 --> 00:03:17.069
そこでこれらの値が何かを把握する必要があります

00:03:17.069 --> 00:03:20.775
closest_light は一番近い信号機を提供するのだと思いますが

00:03:20.775 --> 00:03:23.730
それぞれの信号機には車線があります

00:03:23.729 --> 00:03:26.234
それは 信号機の停止車線です

00:03:26.235 --> 00:03:29.700
やりたいことは一番近い信号の停止線のインデックスを取得することだと思います

00:03:29.699 --> 00:03:34.049
そしてそれを把握するためにKDツリーのようなものをまた使用できるのだと思います

00:03:34.050 --> 00:03:35.849
はいそれはいいプランのようですね

00:03:35.848 --> 00:03:39.074
これの詳細を見ていきましょう

00:03:39.074 --> 00:03:44.310
self.pose で車の向きが分かっているなら、stop_line_positionsは、

00:03:44.310 --> 00:03:45.870
よかったですね 設定から取得するだけです

00:03:45.870 --> 00:03:48.990
それらは以前にセットアップされ このノードに渡されています

00:03:48.990 --> 00:03:52.020
またcar_wp_idx があり それ

00:03:52.020 --> 00:03:55.260
もまたお馴染みのKDツリーからですか？

00:03:55.259 --> 00:03:55.430
はい

00:03:55.431 --> 00:03:56.280
一番近いウェイポイントも?

00:03:56.280 --> 00:04:01.050
はいこれもです 前のビデオを見ると

00:04:01.050 --> 00:04:03.870
KDツリーが一番近いウェイポイントを検索するようにセットアップしています

00:04:03.870 --> 00:04:04.680
セクション 1 ですよね?

00:04:04.680 --> 00:04:06.689
はい基本的に同じアイデアです

00:04:06.689 --> 00:04:13.125
なので そのコードを再利用してこの異なる値を取得しました

00:04:13.125 --> 00:04:16.800
それは self.waypoints waypoints の長さです

00:04:16.800 --> 00:04:17.220
はい

00:04:17.220 --> 00:04:19.950
もしあるなら 一番近い目に見える信号機を見つけるには

00:04:19.949 --> 00:04:22.500
このコードの考えは 一番近い信号を見つけるために

00:04:22.500 --> 00:04:25.709
信号のリストが繰り返し使用されるということだと思います

00:04:25.709 --> 00:04:29.819
一番大きな違いがあるものから開始します

00:04:29.819 --> 00:04:32.474
それは 8 のようです8 個の交差点があると思います

00:04:32.475 --> 00:04:36.584
そのため それは 100 以上もあるベースウェイポイントのように大きくありません

00:04:36.584 --> 00:04:38.610
そのような小さいリストには

00:04:38.610 --> 00:04:40.800
KD ツリーを使用する必要はあまりないです

00:04:40.800 --> 00:04:41.610
それは別にいいのですが

00:04:41.610 --> 00:04:42.330
あまりメリットがありません

00:04:42.329 --> 00:04:44.189
はい見つけて何度もやってみましょう

00:04:44.189 --> 00:04:46.629
enumeratorには

00:04:46.629 --> 00:04:50.810
この信号とエヌメレーターの状態のi値があります

00:04:50.810 --> 00:04:55.480
また この"line"は"stop_line_positions"か得られます

00:04:55.480 --> 00:04:58.240
そのため 車線を提供しますはい

00:04:58.240 --> 00:05:00.970
これが get_closest_waypoint からの

00:05:00.970 --> 00:05:03.925
 その車線の x と y の値と考えています

00:05:03.925 --> 00:05:07.060
その一番近くのウェイポイントがあり 一番近いウェイポイントと

00:05:07.060 --> 00:05:10.810
車のウェイポイント間の差分をみているようです

00:05:10.810 --> 00:05:14.004
はい 基本的に 私たちの車とウェイポイントと車線のウェイポイント間の

00:05:14.004 --> 00:05:17.920
インデックスの番号があります

00:05:17.920 --> 00:05:19.855
また そのウェイポイントが車の前にあり

00:05:19.855 --> 00:05:24.968
 diff より小さい場合 それは 0 より大きいです

00:05:24.968 --> 00:05:27.904
これは通り過ぎないまたは8個の異なる状態を通過したくない

00:05:27.904 --> 00:05:30.619
という意味です

00:05:30.620 --> 00:05:33.889
OK 一番小さい diff がどれかということを見つけようとしています

00:05:33.889 --> 00:05:36.214
もちろんそれが そこの信号をチェックする理由です

00:05:36.214 --> 00:05:38.854
line_waypoint_index の信号への closest_light を

00:05:38.855 --> 00:05:41.720
その temp_waypoint_index に設定できます

00:05:41.720 --> 00:05:45.380
どれが一番近いのかについてシンプルな線形チェックを行います

00:05:45.379 --> 00:05:48.259
はいそのため それらのすべてをループして 車の前方の

00:05:48.259 --> 00:05:51.259
一番近くの道路車線がどれかわかるはずです

00:05:51.259 --> 00:05:55.754
一番近い信号があると これを通過できます

00:05:55.754 --> 00:05:58.389
では 実際にいまこれを設定します

00:05:58.389 --> 00:06:03.474
状態は get_light_state closest_light と同じになります

00:06:03.475 --> 00:06:08.050
closest_light を取得するとその信号の状態がわかります

00:06:08.050 --> 00:06:10.270
やってみて

00:06:10.269 --> 00:06:12.669
KD ツリーから見て これが closest_index であるか見てみましょう

00:06:12.670 --> 00:06:14.530
これが get_closest_waypoint です

00:06:14.529 --> 00:06:15.678
get_light があります

00:06:15.678 --> 00:06:17.168
はい get_closest_light

00:06:17.168 --> 00:06:18.335
どうでしょう

00:06:18.336 --> 00:06:20.680
スクロールアップしていくと ここにありますこれです

00:06:20.680 --> 00:06:21.069
信号の状態を取得します

00:06:21.069 --> 00:06:24.219
Get_light_state.はいGet_light_state は

00:06:24.220 --> 00:06:27.505
自分の分類器を使用するために最初にセットアップされます

00:06:27.504 --> 00:06:29.714
コードにコメントがあります

00:06:29.714 --> 00:06:33.664
自分で学習する信号分類器に戻りますが

00:06:33.665 --> 00:06:36.605
エリンが前に言っていたようにテスト目的で

00:06:36.605 --> 00:06:40.100
信号は状態付きでシミュレーターからきます

00:06:40.100 --> 00:06:42.860
そのため テストには light.state を使用できます

00:06:42.860 --> 00:06:45.305
それはとても簡単です ここからそれを取得するだけです

00:06:45.305 --> 00:06:47.060
それだけのために関数があるというのは興味深いことです

00:06:47.060 --> 00:06:50.906
はいでも 分類器を使用するとその関数は何も取得しなくなります

00:06:50.906 --> 00:06:53.149
そのため その関数を利用するのがもっと合理的になります

00:06:53.149 --> 00:06:58.909
その line_waypoint とインデックスを返しているだけです

00:06:58.910 --> 00:07:01.640
これが その信号の状態のウェイポイントのインデックスです

00:07:01.639 --> 00:07:03.529
はい その地点を過ぎると

00:07:03.529 --> 00:07:06.799
負のものと trafficlight.UNKNOWN を返します

00:07:06.800 --> 00:07:09.079
そうですその部分はそこでとても重要です

00:07:09.079 --> 00:07:14.734
はい 信号機がなくて負のものを返したい場合

00:07:14.735 --> 00:07:16.670
また信号機の状態が

00:07:16.670 --> 00:07:19.504
信号機を検出したけれど その状態がわからない場合

00:07:19.504 --> 00:07:22.550
trafficlight.UNKNOWN を返します

00:07:22.550 --> 00:07:24.319
不明な場合は何が起こったのでしょうか

00:07:24.319 --> 00:07:25.430
車はなにをするのでしょうか

00:07:25.430 --> 00:07:26.629
これはさまざまです

00:07:26.629 --> 00:07:27.757
このプロジェクトの場合

00:07:27.757 --> 00:07:29.734
不明な場合たぶんそれがベストです

00:07:29.735 --> 00:07:32.090
または信号が見つからない場合 車を動かしたままにします

00:07:32.089 --> 00:07:33.679
非常によく制御された環境で車をテストします

00:07:33.680 --> 00:07:38.509
そのため 信号を通過する場合

00:07:38.509 --> 00:07:40.459
Drive-By-Wire システムをテストして

00:07:40.459 --> 00:07:42.134
それがウェイポイントに沿っているか確認します

00:07:42.134 --> 00:07:45.819
実世界では もしそれがわかった場合は車を停止したいと思います

00:07:45.819 --> 00:07:46.240
その方が安全ですね

00:07:46.240 --> 00:07:50.019
はい 信号がわかって その信号の状態が決められない場合

00:07:50.019 --> 00:07:52.644
そのため それを処理しています

00:07:52.644 --> 00:07:54.924
では もとの作業に戻りましょう

00:07:54.925 --> 00:07:58.329
では 状態がわかって その信号のウェイポイントもわかりました

00:07:58.329 --> 00:07:59.919
そして いま実際にチェックできます

00:07:59.920 --> 00:08:02.770
それは負のものですか?そうでない場合は 何をしますか

00:08:02.769 --> 00:08:05.214
この状態は状態と一致しません

00:08:05.214 --> 00:08:07.659
そこで何が起きているのか説明できますか

00:08:07.660 --> 00:08:09.580
はい

00:08:09.579 --> 00:08:12.729
信号の前の状態を格納し 毎回このコールバックにイメージが出てくる

00:08:12.730 --> 00:08:14.215
またはこのコードを実施する

00:08:14.214 --> 00:08:16.419
イメージがきてそれをクラス化した場合

00:08:16.420 --> 00:08:18.189
その信号でそのイメージを処理し

00:08:18.189 --> 00:08:20.769
状態が変更していることを決定しました

00:08:20.769 --> 00:08:22.720
はい それは大きく変更しています

00:08:22.720 --> 00:08:26.410
信号の状態は 青から黄 または黄から赤に変更されます

00:08:26.410 --> 00:08:28.210
では 遷移を行っているのですか?

00:08:28.209 --> 00:08:29.864
はいもしそうなら

00:08:29.865 --> 00:08:33.060
このカウントシステムを開始します

00:08:33.059 --> 00:08:36.629
カウンター はいそれをセットアップして 状態は state と同じになります

00:08:36.629 --> 00:08:39.689
よって 何かアクションを起こす前に この信号がきちんと統一されていてことを

00:08:39.690 --> 00:08:43.320
確認しようとしているようです

00:08:43.320 --> 00:08:45.390
はい

00:08:45.389 --> 00:08:47.610
分類器にノイズが多いか 信号が何度も変わっているかもしれません

00:08:47.610 --> 00:08:49.950
緑から黄それから赤というように

00:08:49.950 --> 00:08:52.440
そこで 信号がそのままであることを確認します

00:08:52.440 --> 00:08:54.090
またそれが正しいことも

00:08:54.090 --> 00:08:56.009
はい何かアクションを実行する前に

00:08:56.009 --> 00:08:59.639
大きいくなっていても

00:08:59.639 --> 00:09:04.465
最後の状態がなにかを保存しています

00:09:04.465 --> 00:09:07.594
そのため このチェックをここでしています

00:09:07.594 --> 00:09:11.330
状態が trafficlight.RED と一致して負のものでない場合

00:09:11.330 --> 00:09:15.139
light_waypoint が light_waypoint と一致します

00:09:15.139 --> 00:09:18.335
分かりますねこの信号の場所をパブリッシュするとき

00:09:18.335 --> 00:09:21.379
関心があることは信号が赤の時だけです

00:09:21.379 --> 00:09:23.105
それ以外はすべて引き続き走行し続けれます

00:09:23.105 --> 00:09:26.210
信号の状態が赤の場合

00:09:26.210 --> 00:09:28.070
light_waypoint がそれ自体に一致します

00:09:28.070 --> 00:09:30.890
でないと light_waypoint が負のものと同じままにしようとします

00:09:30.889 --> 00:09:32.750
それは道路での"waypoint"のアップデーターであり、

00:09:32.750 --> 00:09:35.000
赤信号以外の何かに基づいて

00:09:35.000 --> 00:09:38.210
"waypoint"の速度を更新しようとしません

00:09:38.210 --> 00:09:41.030
本当に 信号が赤の場合にのみ車を停止する必要があります

00:09:41.029 --> 00:09:42.799
全く必要のないことですが

00:09:42.799 --> 00:09:45.109
この理論を変更し また信号が黄色の場合にコードを更新することに

00:09:45.110 --> 00:09:47.539
関心を持つかもしれません

00:09:47.539 --> 00:09:49.219
ええ気を付けてください

00:09:49.220 --> 00:09:52.670
停止の準備 またその一旦停止 その環境

00:09:52.669 --> 00:09:55.279
黄色を通過するために もっと加速を追加する必要があるかもしれません

00:09:55.279 --> 00:09:57.350
はいそれが面白いところです

00:09:57.350 --> 00:09:59.750
テストロットでそれを試せますか?

00:09:59.750 --> 00:10:02.570
車を停止させる方がいいです

00:10:02.570 --> 00:10:03.845
OK

00:10:03.845 --> 00:10:06.259
その light_waypoint をパブリッシュしているだけですが

00:10:06.259 --> 00:10:08.524
それ以外に何かしていますか

00:10:08.524 --> 00:10:14.090
最新のウェイポイントもパブリッシュして 状態はカウンターに +1 をカウントします

00:10:14.090 --> 00:10:17.780
素晴らしいそれはすべてウェイポイント自体で設定されます

00:10:17.779 --> 00:10:20.990
みつかったインデックスとその信号のウェイポイントをパブリッシュするだけですか

00:10:20.990 --> 00:10:22.445
そのとおりです その後

00:10:22.445 --> 00:10:25.014
実際に put がそれを使用するようにします

00:10:25.014 --> 00:10:26.029
はい ウェイポイントアップデーターでは

00:10:26.029 --> 00:10:27.704
このチュートリアルの最後の部分で それがわかったら

00:10:27.705 --> 00:10:31.190
その light_waypoint  をどうするかを話し合います

00:10:31.190 --> 00:10:34.339
わかりましたこの部分で何か言いたいことはありますか

00:10:34.339 --> 00:10:35.690
いいえ これで全部です

00:10:35.690 --> 00:10:37.220
素晴らしいできました

00:10:37.220 --> 00:10:39.080
それでは参加してくれてありがとう

