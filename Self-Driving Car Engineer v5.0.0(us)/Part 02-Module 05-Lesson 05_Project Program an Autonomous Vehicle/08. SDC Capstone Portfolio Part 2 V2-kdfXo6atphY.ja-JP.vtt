WEBVTT
Kind: captions
Language: ja-JP

00:00:00.000 --> 00:00:03.600
ではプロジェクトの 2番目へ進みますエリンです

00:00:03.600 --> 00:00:04.560
スティーブンです

00:00:04.559 --> 00:00:08.038
これまで どのようにウェイポイントへ到達するかを見てきました

00:00:08.038 --> 00:00:10.439
ここでは この車が実際にウェイポイントを追跡する必要があります

00:00:10.439 --> 00:00:12.821
そのとおりでは実際に見てみましょう

00:00:12.821 --> 00:00:14.009
それではどのように始めるか見てみましょう

00:00:14.009 --> 00:00:17.190
このセクションでは DbW ノードを見ていきます

00:00:17.190 --> 00:00:20.565
OK ここでの次のコンセプトは Waypoint Updater のすぐ後ですね

00:00:20.565 --> 00:00:22.170
では ここでは何を行いますか?

00:00:22.170 --> 00:00:24.870
ここにすぐに throttle コマンド

00:00:24.870 --> 00:00:26.490
break コマンド steering コマンドがあります

00:00:26.489 --> 00:00:31.424
そうですね皆さんの DbW ノードが twist コマンドトピックをサブスクライブしている場合

00:00:31.425 --> 00:00:33.744
最終 Waypoints がパブリッシュされると

00:00:33.744 --> 00:00:37.459
Autoware ソフトウェアの一種であるウェイポイントフォロワーへ進み

00:00:37.460 --> 00:00:38.630
最終ウェイポイントと

00:00:38.630 --> 00:00:42.575
その速度を取って車のための適切な twist コマンドをパブリッシュします

00:00:42.575 --> 00:00:45.166
twists コマンドをご覧になったことない方へ説明すると

00:00:45.165 --> 00:00:49.039
基本的には車の線形加速度および角加速度となります

00:00:49.039 --> 00:00:51.409
ここで さまざまな種類のコントローラーをお見せします

00:00:51.409 --> 00:00:54.359
おそらく 車を制御するためにいくつかのコントローラーが必要となるでしょう

00:00:54.359 --> 00:00:57.299
たくさんの種類が提供されていますね?

00:00:57.299 --> 00:00:57.968
そのとおり

00:00:57.969 --> 00:01:01.410
たとえば PID はローパスフィルターで提供されます

00:01:01.409 --> 00:01:05.474
このノードは twist コマンドトピックメッセージを取得します

00:01:05.474 --> 00:01:08.819
ここで実行したいのは スロットル ステアリング ブレーキをパブリッシュすることです

00:01:08.819 --> 00:01:11.324
では コードを確認してみましょう

00:01:11.325 --> 00:01:17.280
twist コントローラーのところで見つけた dbw_node.py に興味があります

00:01:17.280 --> 00:01:19.829
これが最初にファイルを開いたときの様子です

00:01:19.829 --> 00:01:23.495
ここには既に設定済みの複数の基本コードが実装されていて

00:01:23.495 --> 00:01:25.125
ここにたくさんのカーパラメーターがあり

00:01:25.125 --> 00:01:27.629
これらすべてのカーパラメーターを使用することになるでしょう

00:01:27.629 --> 00:01:29.819
そうですね本当にfuel capacity (燃料容量) は必要ですか?

00:01:29.819 --> 00:01:33.359
精度を求めるなら

00:01:33.359 --> 00:01:34.469
燃料容量が使用できます

00:01:34.469 --> 00:01:36.840
車の停止の時に車両重量が必要となりますからね

00:01:36.840 --> 00:01:39.900
シミュレーターに燃料容量を取り込むと 計算が大変になりますね

00:01:39.900 --> 00:01:42.210
まったくまあ シミュレーターではこれは使用しません

00:01:42.209 --> 00:01:42.989
それは無限ですから

00:01:42.989 --> 00:01:45.299
無限の燃料 では 走り続けられますね

00:01:45.299 --> 00:01:48.119
しかし これは車の重量を制御するような方法ですから

00:01:48.120 --> 00:01:49.829
燃料容量が実装されています

00:01:49.829 --> 00:01:52.379
もしガソリンの 75 パーセントであるとわかっている場合

00:01:52.379 --> 00:01:54.598
その値をファクターとして使用できます

00:01:54.599 --> 00:01:55.620
高い精度を求めることもできますが

00:01:55.620 --> 00:01:57.660
ここでの目的では その必要はありません

00:01:57.659 --> 00:02:02.459
ただし ホイール半径と車両重量が必要です

00:02:02.459 --> 00:02:05.089
OK では基本的な物理が使えますね

00:02:05.090 --> 00:02:09.020
はい、ブレーキコマンドはトルクの単位を扱いますからね

00:02:09.020 --> 00:02:11.030
はい そのとおりですニュートンメートルですね

00:02:11.030 --> 00:02:13.849
そして ブレーキにどれくらいのトルクを適用すべきか求めるために

00:02:13.849 --> 00:02:16.099
車両重量 掛ける

00:02:16.099 --> 00:02:17.419
ホイール半径 掛ける

00:02:17.419 --> 00:02:19.099
目的の加速度として計算します

00:02:19.099 --> 00:02:22.729
わかりましたまたここで 50 ヘルツ でのループがありますね

00:02:22.729 --> 00:02:23.060
はい

00:02:23.060 --> 00:02:24.170
ここでは 50 ヘルツが重要ですか

00:02:24.169 --> 00:02:25.429
それとも 30 ヘルツにしても大丈夫ですか?

00:02:25.430 --> 00:02:27.260
この場合は非常に重要です

00:02:27.259 --> 00:02:29.674
前回の 30 ヘルツはそれほど重要ではありませんでしたが

00:02:29.675 --> 00:02:31.760
この場合 50 が必須となります

00:02:31.759 --> 00:02:35.120
DBWによって車両を動かす場合

00:02:35.120 --> 00:02:38.730
50ヘルツでコマンドを受信できないと思い通りに動作しません

00:02:38.729 --> 00:02:40.139
もしそれ以下の値を返された場合

00:02:40.139 --> 00:02:42.554
20 ヘルツくらいでシャットダウンになると思います

00:02:42.555 --> 00:02:43.980
またこれは 安全機能としても働きます

00:02:43.979 --> 00:02:44.299
そうですね

00:02:44.300 --> 00:02:46.469
コンピューターの故障とみなし

00:02:46.469 --> 00:02:48.764
ドライバーへ制御を返そうとするでしょう

00:02:48.764 --> 00:02:50.789
50 ヘルツをパブリッシュしない場合

00:02:50.789 --> 00:02:54.030
50ヘルツでパブリッシュしないと、DBWによる運転はテスト中に終了することになるでしょう

00:02:54.030 --> 00:02:57.030
知っておいてよかったです 確認のために控えておきましょう

00:02:57.030 --> 00:02:59.340
では先に進み 結果コードを確認してみましょう

00:02:59.340 --> 00:03:01.905
既にお話したように サブスクライバーが既にあり

00:03:01.905 --> 00:03:05.189
ここのループの中にこのコントローラーを実装しています

00:03:05.189 --> 00:03:08.939
これは twist_controller.py から出力しているので

00:03:08.939 --> 00:03:11.189
定義された制御クラスがそこにあります

00:03:11.189 --> 00:03:13.710
したがって コントローラーをそこからインポートしました

00:03:13.710 --> 00:03:15.375
現在の速度を基にした スロットル

00:03:15.375 --> 00:03:20.400
ブレーキ ステアリングが提供されているように見えますね

00:03:20.400 --> 00:03:24.168
DbW が実行可能かどうかにより 線速度や

00:03:24.168 --> 00:03:28.754
角速度は none として出発しているようですね

00:03:28.754 --> 00:03:32.490
そして コールバック関数が書き込まれているようですね

00:03:32.490 --> 00:03:33.570
はい そのとおり

00:03:33.569 --> 00:03:34.289
では

00:03:34.289 --> 00:03:37.679
いろいろな種類のデータがこのノードに入り これをコールバックで書き出します

00:03:37.680 --> 00:03:43.379
速度があり スロットル ステアリング

00:03:43.379 --> 00:03:44.984
ブレーキをパブリッシュします

00:03:44.985 --> 00:03:47.200
きちんとしたチェックでは

00:03:47.199 --> 00:03:50.694
このすべてがコマンドを車へ送信しているか確認したいですね

00:03:50.694 --> 00:03:53.739
ただ前進させたい場合 どうすればいいですか?

00:03:53.740 --> 00:03:56.439
車が前進することをテストしたいだけの場合

00:03:56.439 --> 00:04:00.340
スロットルを 1 に ステアリングとブレーキを 0 に設定して

00:04:00.340 --> 00:04:02.659
スロットルをパブリッシュするだけです

00:04:02.659 --> 00:04:06.099
そしてブレーキのようにではなく スロットルは 0 から 1 とします

00:04:06.099 --> 00:04:08.530
OK ではスターター関数まで進めて

00:04:08.530 --> 00:04:11.275
このアクチュアルコントローラーを使用する代わりに

00:04:11.275 --> 00:04:14.140
スロットル ブレーキ ステアリングの値をハードコードして

00:04:14.139 --> 00:04:16.743
コールバックを使用します

00:04:16.744 --> 00:04:18.510
次に このコントローラーを確認しましょう

00:04:18.509 --> 00:04:21.810
はい 実際にほとんどの作業はこの部分で実行されます

00:04:21.810 --> 00:04:23.175
とても重要なようですね

00:04:23.175 --> 00:04:25.905
では 最初にコントローラーを開くと

00:04:25.904 --> 00:04:27.509
空っぽのように見えますね

00:04:27.509 --> 00:04:27.959
そうですね

00:04:27.959 --> 00:04:30.389
ただ デフォルトとして 1 0 0 が返ってきているだけですね

00:04:30.389 --> 00:04:34.620
OKこれだと コントローラーを呼び出して車を前進できそうですね

00:04:34.620 --> 00:04:38.550
OK素晴らしい書き込むとどうなるか見てみましょう

00:04:38.550 --> 00:04:41.280
もちろん ここではものすごくたくさんの方法でいろいろなことができ

00:04:41.279 --> 00:04:45.412
車の速度を制御するコントローラーを使用できる方法もたくさんあります

00:04:45.413 --> 00:04:47.310
yaw コントローラーが提供されています

00:04:47.310 --> 00:04:48.689
では これがステアリングをサポートするんですか?

00:04:48.689 --> 00:04:51.625
はい ステアリングコマンドを yaw コントローラーから受け取ったら

00:04:51.625 --> 00:04:55.250
ホイールベースステアリング比を書き込んでください

00:04:55.250 --> 00:04:59.420
秒速 0.1 メートルが車の最低速度となると思います

00:04:59.420 --> 00:04:59.948
OK

00:04:59.947 --> 00:05:03.544
そして最大横加速度と最高ステアリング角度となります

00:05:03.545 --> 00:05:06.920
さらに これらすべては dbw.py を通過するパラメーターですから

00:05:06.920 --> 00:05:09.259
これを yaw コントローラーへ進めるだけです

00:05:09.259 --> 00:05:12.439
さらに スロットルのために PDI コントローラーも実装されていますね

00:05:12.439 --> 00:05:14.719
スロットルコントローラー用のパラメーターは

00:05:14.720 --> 00:05:17.000
完全に実験によって得られたもので

00:05:17.000 --> 00:05:19.970
どのように動作するかテストするだけです

00:05:19.970 --> 00:05:21.380
少し面白くなってきました

00:05:21.379 --> 00:05:22.939
ローパスフィルターも実装されていますね

00:05:22.939 --> 00:05:25.759
ローパスフィルターを作成したのは

00:05:25.759 --> 00:05:29.159
メッセージを通じてやってくる速度がノイズを含んでいるため

00:05:29.160 --> 00:05:31.500
基本的に この LowPassFilter が

00:05:31.500 --> 00:05:34.199
速度の中の高周波帯のノイズを取り除いてくれるためです

00:05:34.199 --> 00:05:37.288
また 車両重量 燃料容量や

00:05:37.288 --> 00:05:40.169
必要かどうかかわからないけど

00:05:40.170 --> 00:05:41.400
ホイール半径にように

00:05:41.399 --> 00:05:42.539
 役に立ちそうなものもあります

00:05:42.540 --> 00:05:45.000
加速度や減速度限界は おそらく必要でしょう

00:05:45.000 --> 00:05:46.425
これは与えられていて

00:05:46.425 --> 00:05:49.319
減速限界はコンフィギュレーションファイルに設定します

00:05:49.319 --> 00:05:50.640
これも入ってくると思うのですが

00:05:50.639 --> 00:05:54.269
ROS パラメーターの一つや dbw_node.py. の他の部分もあります

00:05:54.269 --> 00:05:58.467
車そのものによって定義されますから これはプリセットですか?

00:05:58.468 --> 00:06:03.569
いいえ 加速度限界と減速度限界はコンフォートパラメーターなだけだと思います

00:06:03.569 --> 00:06:03.829
OK

00:06:03.829 --> 00:06:07.379
ですから 速度はどうしたいか 車の減速や加速の最大値をどうしたいか ですね

00:06:07.379 --> 00:06:10.214
ここにコントロールファンクションがありますので

00:06:10.214 --> 00:06:12.539
確認してみましょう

00:06:12.540 --> 00:06:14.640
まず初めに コントロールを呼び出すには

00:06:14.639 --> 00:06:17.759
コントロールは dbw.py の中に呼び出されます

00:06:17.759 --> 00:06:22.469
コントローローラークラスのインスタンスを上記のように作成し

00:06:22.470 --> 00:06:23.640
基本的に 50 ヘルツでコントロールを呼び出します

00:06:23.639 --> 00:06:26.714
最初に確認することは dbw_enabled が実行可能かどうかです

00:06:26.714 --> 00:06:28.379
なぜ dbw_enabled を考えなければならないのでしょう?

00:06:28.379 --> 00:06:31.620
私たちはDBWをONにしたりOFFにすることができます

00:06:31.620 --> 00:06:34.110
信号待ちをしているとき

00:06:34.110 --> 00:06:35.879
私はDBWをOFFにするかもしれません

00:06:35.879 --> 00:06:37.334
また何かを直しているとき

00:06:37.334 --> 00:06:39.609
コードの実行中はDBWはOFFになるかもしれません

00:06:39.610 --> 00:06:42.862
PID コントローラーを使用中では 積分の項があり

00:06:42.862 --> 00:06:46.995
PID コントローラーをオフにしない場合には

00:06:46.995 --> 00:06:48.959
エラーの蓄積が発生します

00:06:48.959 --> 00:06:52.274
これは良くありません なぜなら DbW ノードに戻った時

00:06:52.274 --> 00:06:55.289
このすべてのエラーが蓄積され 車が迷走することになりかねません

00:06:55.290 --> 00:07:00.090
ああ それは面白くないですね

00:07:00.089 --> 00:07:00.269
そのとおりです

00:07:00.269 --> 00:07:03.359
よって 実行可能でない場合には 先に進んで 0 0 0 を返してください

00:07:03.360 --> 00:07:05.639
これでコントローラーがリセットされますね

00:07:05.639 --> 00:07:06.659
そのとおりです

00:07:06.660 --> 00:07:10.439
OKそうでなければ 現在の速度と

00:07:10.439 --> 00:07:11.670
yaw コントローラーから得るステアリングを調べ

00:07:11.670 --> 00:07:16.350
この速度エラーを確認します

00:07:16.350 --> 00:07:19.305
つまり どこへ行きたいかに対して現在どこにいるのか

00:07:19.305 --> 00:07:22.035
ここに最終速度もありますね

00:07:22.035 --> 00:07:24.090
これが物理的処理を始める場所ですか?

00:07:24.089 --> 00:07:27.959
はい 下にブレーキパートの物理的処理を開始する場所がありますね

00:07:27.959 --> 00:07:32.129
スロットルでは スロットルコントローラーをステップスルーしているように見えますね

00:07:32.129 --> 00:07:34.699
これは PID コントローラーと関連していますか?

00:07:34.699 --> 00:07:36.959
はい速度エラーと

00:07:36.959 --> 00:07:40.634
サンプル時間があり このクラスで初期化した時にわかっているでしょうけど

00:07:40.634 --> 00:07:44.099
残り時間として現在の時間があり

00:07:44.100 --> 00:07:47.640
PID コントローラーの各ステップでサンプルタイムを得るために使用できます

00:07:47.639 --> 00:07:49.675
では ここでこのステップを呼び出して

00:07:49.675 --> 00:07:53.194
実際にPID コントローラーで実行されているサンプリングとなります

00:07:53.194 --> 00:07:55.250
定義したエラーがこの中にありますか?

00:07:55.250 --> 00:07:57.170
はい 実際にこのコードを書いているとき

00:07:57.170 --> 00:08:00.020
PID コントローラーにエラーがあることに気が付きました

00:08:00.019 --> 00:08:03.185
それは フルタームの中でのリセットからの積分が妨げられるエラーでした

00:08:03.185 --> 00:08:07.115
ですから repo で選択して今は大丈夫なはずですが

00:08:07.115 --> 00:08:08.660
Capstone Repo からのこの最新バージョンを

00:08:08.660 --> 00:08:11.360
確認したくなるのではないかと思います

00:08:11.360 --> 00:08:13.610
そうですね この部分は変更されているように見えますね

00:08:13.610 --> 00:08:17.360
いくつかデバグした項がこの下にあるのがわかると思います

00:08:17.360 --> 00:08:20.600
rospy.logwarn は何が実行されているのかを確認しているだけです

00:08:20.600 --> 00:08:24.530
では スロットル値を得て 初期値としてブレーキを 0 に設定したので

00:08:24.529 --> 00:08:25.819
ここで確認を実行します

00:08:25.819 --> 00:08:28.659
これは とても単純な車の制御です

00:08:28.660 --> 00:08:32.379
最初に実行するチェックは 線形速度 これは私たちの目的ですが

00:08:32.379 --> 00:08:34.554
線形速度が 0

00:08:34.554 --> 00:08:36.474
そしてゆっくりと進み

00:08:36.475 --> 00:08:39.115
現在の速度が 0.1 以下です

00:08:39.115 --> 00:08:40.779
おそらく停止しようとするでしょうから

00:08:40.779 --> 00:08:44.709
スロットル = 0 として 多量のブレーキを適用します

00:08:44.710 --> 00:08:49.810
さもないと スロットルはとても小さく 速度エラーが 0 より小さくなります

00:08:49.809 --> 00:08:51.669
そうですねこの場合

00:08:51.669 --> 00:08:53.049
速度は負の値となり

00:08:53.049 --> 00:08:56.339
これは希望する速度よりも速いことを意味しており

00:08:56.340 --> 00:08:58.725
つまり目的速度よりも速いことになります

00:08:58.725 --> 00:09:02.685
また PID はスロットルを緩めますが 私たちは減速したいので

00:09:02.684 --> 00:09:06.299
スロットルは 0.1 より小さくなり ここでの速度は負の値となります

00:09:06.299 --> 00:09:10.109
この場合 ブレーキを 400 でハードコーディングするのではなく

00:09:10.110 --> 00:09:11.639
この絶対値を使用して

00:09:11.639 --> 00:09:15.600
減速度に車両重量とホイール半径を掛けます

00:09:15.600 --> 00:09:17.805
これで 目的とするトルク値が得られますので

00:09:17.804 --> 00:09:20.294
減速したい値に

00:09:20.294 --> 00:09:21.824
車両重量を掛けて

00:09:21.825 --> 00:09:23.504
ホイール半径を掛けます

00:09:23.504 --> 00:09:24.960
車両重量はキログラム

00:09:24.960 --> 00:09:26.400
ホイール半径はメートルです

00:09:26.399 --> 00:09:29.279
実際に減速値を計算します

00:09:29.279 --> 00:09:35.824
それは速度エラーと前に定義した減速限界パラメータとの最大値です

00:09:35.825 --> 00:09:39.620
したがって これは実際には速度エラーに左右され

00:09:39.620 --> 00:09:40.789
もし大きい値の場合

00:09:40.789 --> 00:09:42.829
このブレーキの値もとても大きくなります

00:09:42.830 --> 00:09:45.200
コードを書く際につまずいた部分の一つに

00:09:45.200 --> 00:09:47.840
ブレーキの値が負の値となることです

00:09:47.840 --> 00:09:48.769
なるほど 実際には何が起こっているでしょうか

00:09:48.769 --> 00:09:50.809
たとえば 減速したい場合

00:09:50.809 --> 00:09:53.449
加速度が正の値でブレーキの値は負になります

00:09:53.450 --> 00:09:56.509
もちろん シミュレーター上で車は全く減速しませんね

00:09:56.509 --> 00:09:58.039
だから絶対値を使う必要があるのです

00:09:58.039 --> 00:10:00.424
はい そのとおりですね ここで decel は負の値となりますが

00:10:00.424 --> 00:10:03.079
これを正の値としたいですよね

00:10:03.080 --> 00:10:06.875
これでコントロールを完了したと思います

00:10:06.875 --> 00:10:09.559
そうですね ここでウェイポイント上でパブリッシュを行い

00:10:09.559 --> 00:10:13.159
それがdbw_node.pyに入り

00:10:13.159 --> 00:10:15.634
車を制御するコントローラが得られているはずです

00:10:15.634 --> 00:10:18.304
あともう一つ 実際にお話しておかなければならないことがあります

00:10:18.304 --> 00:10:21.319
この部分で車を動作しているとき

00:10:21.320 --> 00:10:24.620
道路に沿って進むにつれて

00:10:24.620 --> 00:10:26.690
車線の内側から少し離れていることがあります

00:10:26.690 --> 00:10:30.650
また時として これが実際に使用している Autoware コードの乱れとなることがあります

00:10:30.649 --> 00:10:35.509
したがって ウェイポイントから一定の距離だけ離れるまで

00:10:35.509 --> 00:10:38.210
またはウェイポイントのトラジェクトリーから一定の角度だけ離れるまで

00:10:38.210 --> 00:10:41.870
Autoware コードはトラジェクトリーを再計算しません

00:10:41.870 --> 00:10:45.529
そして注意してほしいのは このとても単純なコントローラーによって

00:10:45.529 --> 00:10:49.309
トラジェクトリーを再計算して新しい twist コマンドを車に送る時点まで

00:10:49.309 --> 00:10:52.129
既に車はウェイポイントから逸れているので

00:10:52.129 --> 00:10:55.355
ウェイポイントへ突然戻ることがあります

00:10:55.355 --> 00:10:58.370
ウェイポイントがノードや

00:10:58.370 --> 00:11:00.919
新しい twists コマンドに従うまで 他へ逸れていきます

00:11:00.919 --> 00:11:01.909
ですから カーソルをリフレッシュしてください

00:11:01.909 --> 00:11:04.309
そうですね これを修正する方法はいくつかありますが

00:11:04.309 --> 00:11:08.269
コードはこの設定でさらに大きく超えていくことがあります

00:11:08.269 --> 00:11:08.569
そうですよね

00:11:08.570 --> 00:11:10.459
少しだけ外れているだけかもしれません

00:11:10.458 --> 00:11:11.849
しかし これをどのように修正できますか?

00:11:11.850 --> 00:11:13.710
そうですね

00:11:13.710 --> 00:11:16.860
ウェイポイントフォロワー CPP コードへ進み

00:11:16.860 --> 00:11:20.115
常に更新されているかどうか確認することができます

00:11:20.115 --> 00:11:23.235
その中にはウェイポイントに従っているかどうかを確認する関数があり

00:11:23.235 --> 00:11:26.452
もしウェイポイントに従っていなければ 更新します

00:11:26.452 --> 00:11:30.209
コードを変更して 基本的にはいつでもウェイポイントに従うように確認することができます

00:11:30.210 --> 00:11:32.490
その他にする必要が出てくる場面は

00:11:32.490 --> 00:11:35.029
yaw コントローラーを変更してステアリングの値をダンプニングしたり

00:11:35.029 --> 00:11:36.569
この yaw コントローラーがある場合

00:11:36.570 --> 00:11:40.020
少しスクロールダウンして get_steering を呼び出します

00:11:40.019 --> 00:11:42.840
いくつかのダンプニング項を追加して

00:11:42.840 --> 00:11:46.388
現在の角速度やターゲット角速度を得たり

00:11:46.388 --> 00:11:48.090
2 つの差を確認することができます

00:11:48.090 --> 00:11:48.604
では

00:11:48.604 --> 00:11:49.950
その 2 つが同じであれば

00:11:49.950 --> 00:11:50.960
ステアリングは変更せず

00:11:50.960 --> 00:11:52.043
もし違えば

00:11:52.043 --> 00:11:54.149
ダンプニングをその中に追加します

00:11:54.149 --> 00:11:56.024
ここにローパスフィルターがあります

00:11:56.024 --> 00:11:58.620
これはそれほど複雑ではありません

00:11:58.620 --> 00:12:01.350
値の履歴を平均化するだけで

00:12:01.350 --> 00:12:05.519
前のエントリーに左右されるため 大きな数には決してなりません

00:12:05.519 --> 00:12:07.319
そうですね 単に信号を取り

00:12:07.320 --> 00:12:10.590
入ってくる信号のどの部分でも集めて前の部分と平均化します

00:12:10.590 --> 00:12:14.220
そして タウ周波数パラメーターに従って待機します

00:12:14.220 --> 00:12:14.790
素晴らしい

00:12:14.789 --> 00:12:16.019
他にありますか

00:12:16.019 --> 00:12:17.039
いいえ これで全部です

00:12:17.039 --> 00:12:17.789
素晴らしい

00:12:17.789 --> 00:12:20.759
それではまた お会いしましょう

