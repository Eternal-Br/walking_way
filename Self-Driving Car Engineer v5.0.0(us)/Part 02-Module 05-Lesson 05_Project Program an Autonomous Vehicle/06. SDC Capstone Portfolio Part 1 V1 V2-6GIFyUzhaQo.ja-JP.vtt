WEBVTT
Kind: captions
Language: ja-JP

00:00:00.000 --> 00:00:03.419
こんにちはスティーブンです Udacity のコース開発者です

00:00:03.419 --> 00:00:07.009
私はシステム統合コンテンツに取り組んでおり Carla でコードを実行しています

00:00:07.009 --> 00:00:08.404
こんにちはアーロン ブラウンです

00:00:08.404 --> 00:00:11.699
自動運転車のコンテンツ開発者で

00:00:11.699 --> 00:00:13.500
キャップストーン プロジェクトのシミュレーション部分

00:00:13.500 --> 00:00:16.535
に携わりました

00:00:16.535 --> 00:00:18.765
では始めましょう

00:00:18.765 --> 00:00:20.804
プロジェクトのチュートリアルを行います

00:00:20.804 --> 00:00:23.454
これはプロジェクトのチュートリアルであり 4 つのステップで行います

00:00:23.454 --> 00:00:29.500
今日の最初のステップは ウェイポイント更新の最初の部分です

00:00:29.500 --> 00:00:32.270
そうですねそれで 道路上でこれらのウェイポイントを見て

00:00:32.270 --> 00:00:35.445
車両を追跡することを試みることができるようになりたいと思っています

00:00:35.445 --> 00:00:36.494
そう願います

00:00:36.494 --> 00:00:41.250
はい先に進んで クラスルームをチェックアウトし 開始するために必要なものを見てみましょう

00:00:41.250 --> 00:00:44.204
今のところ Ubuntu と ROS が必要なのが分かります

00:00:44.204 --> 00:00:49.849
Linux や Windows さえあれば 実際にこのプロジェクトをネイティブに実行する方法があります

00:00:49.850 --> 00:00:51.234
私は Ubuntu Bash を使用しました

00:00:51.234 --> 00:00:52.460
両方とも持っていない場合

00:00:52.460 --> 00:00:57.109
Mac 上で実行可能な VM などがあります

00:00:57.109 --> 00:00:59.950
ROS と Ubuntu は有名ですが

00:00:59.950 --> 00:01:03.600
DBW Node も見ることができます

00:01:03.600 --> 00:01:05.394
DBW Node とは何でしょうか?

00:01:05.394 --> 00:01:07.589
DBW はドライブ バイ ワイヤーで

00:01:07.590 --> 00:01:10.234
自動車内で稼働し

00:01:10.234 --> 00:01:13.144
ROS が自動車のハードウェアと連動することを可能にするノードです

00:01:13.144 --> 00:01:16.670
それで ROS が実際に自動車のステアリングとスロットルを作動させることを可能にします

00:01:16.670 --> 00:01:19.329
OKこれは ハードウェアとソフトウェアの間の橋渡しをするものです

00:01:19.329 --> 00:01:22.250
このプロジェクトのために これをインストールする必要がある理由は

00:01:22.250 --> 00:01:26.200
コードのために必要となるであろう ROS メッセージ定義が含まれるからです

00:01:26.200 --> 00:01:28.075
それで 一度すべてをインストールすると

00:01:28.075 --> 00:01:31.155
先に進み リポジトリをチェックアウトすることから始めることができます

00:01:31.155 --> 00:01:33.814
VM にアクセスできるようにするために

00:01:33.814 --> 00:01:36.965
実行する必要があるすべてのファイルが手に入り

00:01:36.965 --> 00:01:40.990
その後 実際にキャップストーン プロジェクトに進むことができます

00:01:40.989 --> 00:01:43.799
これには ROS コードの実行方法と

00:01:43.799 --> 00:01:46.554
DBW ソフトウェアのインストール方法に関する指示があります

00:01:46.555 --> 00:01:50.570
OKこれは リポジトリを複製する他のプロジェクトと同じです

00:01:50.569 --> 00:01:55.049
ここには セットアップして ROS に入るための特別な指示があります

00:01:55.049 --> 00:01:58.825
catkin_make を実行し devil setup.sh を起動すると

00:01:58.825 --> 00:02:00.380
ROS が起動します

00:02:00.379 --> 00:02:05.649
修正を始めて このプロジェクトを動かすために必要な最初のファイルの1つは何でしょうか?

00:02:05.650 --> 00:02:09.675
しなければならないことは ウェイポイント アップデーターを修正することです

00:02:09.675 --> 00:02:12.950
Waypoint Updater Node (Partial) に進みましょう

00:02:12.949 --> 00:02:16.310
基本的にいくつかのベースとなるウェイポイントがあり

00:02:16.310 --> 00:02:19.594
自動車が追従するウェイポイントのリストを含む

00:02:19.594 --> 00:02:24.469
情報を持つ車線オブジェクトを公開しています

00:02:24.469 --> 00:02:28.020
current_pose トピックにくる

00:02:28.020 --> 00:02:30.550
車両の現在位置を使いたい場合

00:02:30.550 --> 00:02:33.939
車両の前方にあるウェイポイントを公開します

00:02:33.939 --> 00:02:35.370
最終的に 4 つのウェイポイントがあります

00:02:35.370 --> 00:02:37.545
先に進んで ファイルをチェック アウトしますか?

00:02:37.544 --> 00:02:38.000
はい

00:02:38.000 --> 00:02:41.439
最初にファイルをロードしたときにファイルがどのように見えるかです

00:02:41.439 --> 00:02:43.669
いくつかのウェイポイントがあり

00:02:43.669 --> 00:02:45.219
デフォルトでは 200 です

00:02:45.219 --> 00:02:48.514
車両の前方には 最初に 200 個のウェイポイントがあります

00:02:48.514 --> 00:02:53.463
ベースウェイポイントを得るために、このサブスクライバーを使っています

00:02:53.463 --> 00:02:56.409
どうやって基本的なウェイポイントのセットを取得できますか?

00:02:56.409 --> 00:02:58.539
加入者を使用しており

00:02:58.539 --> 00:03:01.664
rospy.Subscriberを見ると

00:03:01.664 --> 00:03:03.884
基本的なウェイポイントがある場合は トピックになります

00:03:03.884 --> 00:03:07.620
Laneはトピックのメッセージタイプです

00:03:07.620 --> 00:03:11.735
次に waypoints_cb はウェイポイント コールバックです

00:03:11.735 --> 00:03:14.330
これは 基本的に毎回呼ばれる関数です

00:03:14.330 --> 00:03:15.110
ここです

00:03:15.110 --> 00:03:15.565
はい

00:03:15.564 --> 00:03:17.104
OKこれを実装する必要があります

00:03:17.104 --> 00:03:20.840
ウェイポイントを受信できることを確認する必要があります

00:03:20.840 --> 00:03:22.625
基本的にはウェイポイントを保存したいだけです

00:03:22.625 --> 00:03:24.939
結果を見てみましょう

00:03:24.939 --> 00:03:25.569
はい

00:03:25.569 --> 00:03:26.139
OK

00:03:26.139 --> 00:03:29.269
ウェイポイントをコールバックするまでスクロール ダウンするとします

00:03:29.270 --> 00:03:30.730
Callback 関数があります

00:03:30.729 --> 00:03:33.619
はいコールバックには

00:03:33.620 --> 00:03:35.284
受信するウェイポイントがあり

00:03:35.284 --> 00:03:40.090
self.basewaypoints は ウェイポイントとオブジェクトに保存するだけです

00:03:40.090 --> 00:03:41.629
OKこれは加入者です

00:03:41.629 --> 00:03:44.014
これが毎回起こっていることを意味しますか?

00:03:44.014 --> 00:03:46.909
通常は はいです しかし これはラッチされた加入者です

00:03:46.909 --> 00:03:48.949
コードが現在リポジトリに設定されている方法であると信じています

00:03:48.949 --> 00:03:53.254
一度、コールバックが呼び出されるとbase_waypointsは送信されなくなります

00:03:53.254 --> 00:03:56.039
これは良いことです

00:03:56.039 --> 00:03:57.219
 base_waypointsは変更されないので

00:03:57.219 --> 00:03:59.500
毎秒何回も呼び出すのは非効率的です

00:03:59.500 --> 00:04:00.699
そのため 一度 関数を呼び出します

00:04:00.699 --> 00:04:04.399
ここには他にも面白いコードを書いたコードがあります

00:04:04.400 --> 00:04:06.770
したがって 基本的な考え方は これらの基本的なウェイポイントのセットを取得し

00:04:06.770 --> 00:04:11.685
車両の正面にある最初の 200個 を参照として使用することです

00:04:11.685 --> 00:04:17.490
どのウェイポイントが車両に最も近いか実際に考え出す素晴らしい方法は何ですか?

00:04:17.490 --> 00:04:18.764
良い質問です

00:04:18.764 --> 00:04:21.654
このコードでは KDTree と呼ばれるものを使用しています

00:04:21.654 --> 00:04:23.239
KDTree は どこから来ますか?

00:04:23.240 --> 00:04:24.514
Scripy にあります

00:04:24.514 --> 00:04:28.625
正解です scipy.spatial import KDTree をインポートしました

00:04:28.625 --> 00:04:31.430
KDTree は 空間内の最も近い点を効率的に検索できるようにする

00:04:31.430 --> 00:04:34.535
データ構造を備えています

00:04:34.535 --> 00:04:37.080
n ではなく log n のようなものです

00:04:37.079 --> 00:04:40.339
はいウェイポイントのリストを通して直接検索する場合です

00:04:40.339 --> 00:04:44.209
1000 個のウェイポイントがあるかもしれません おそらく リストの最後に欲しいウェイポイントです

00:04:44.209 --> 00:04:45.664
はい 長い時間がかかります

00:04:45.665 --> 00:04:50.340
KDTree を使用し log nのようなものであり 10 サイクルしかないのであれば

00:04:50.339 --> 00:04:51.739
効率性は高くなります

00:04:51.740 --> 00:04:53.095
これは はるかに良い方法です

00:04:53.095 --> 00:04:54.640
素晴らしいKDTree を使用しています

00:04:54.639 --> 00:04:56.569
この KDTree をどのように設定しますか?

00:04:56.569 --> 00:04:59.524
ここでは コード内でウェイポイントを

00:04:59.524 --> 00:05:02.810
各ウェイポイントの 2D 座標に変換したことがわかります

00:05:02.810 --> 00:05:04.089
これは 理解のためのリストです

00:05:04.089 --> 00:05:06.659
ウェイポイントごとに waypoints.waypoints があります

00:05:06.660 --> 00:05:13.305
waypoint.pose.pose.position.x と waypoint.pose.pose.position.yがあります

00:05:13.305 --> 00:05:17.199
各ウェイポイントのための 2D 座標のセットのリストが提供されます

00:05:17.199 --> 00:05:19.550
これは KDTree を構築するために使用します

00:05:19.550 --> 00:05:21.829
素晴らしい一回のコールバックで

00:05:21.829 --> 00:05:26.180
購読者から得られる その他の情報で構築しました

00:05:26.180 --> 00:05:28.785
重要なのは おそらく車両のポーズだと思います

00:05:28.785 --> 00:05:32.185
はい実際には このコールバックについて言及したいことが 1 つあります

00:05:32.185 --> 00:05:33.860
ここでは self.waypoints2D ではないコードがあります

00:05:33.860 --> 00:05:38.780
また ここでは その属性がコールバックで使用されているため

00:05:38.779 --> 00:05:45.089
2D が加入者より前に初期化されるようにします

00:05:45.089 --> 00:05:47.659
そうしないとwaypoints_2dが初期化される前に

00:05:47.660 --> 00:05:52.010
サブスクライバーコールバックが呼び出されるというリスク条件に遭遇する可能性があります

00:05:52.009 --> 00:05:57.024
何を参照すればよいのかわからないので 問題が発生します

00:05:57.024 --> 00:05:58.144
よくわかりました

00:05:58.144 --> 00:06:00.555
pose_cb のためのコールバックがあり

00:06:00.555 --> 00:06:02.819
ポーズが何であるかを把握しています

00:06:02.819 --> 00:06:04.409
そのため 車両のポーズを保存します

00:06:04.410 --> 00:06:05.290
答えはシンプルです

00:06:05.290 --> 00:06:06.980
これは頻繁に呼び出されます

00:06:06.980 --> 00:06:07.935
どれほどの頻度ですか?

00:06:07.935 --> 00:06:11.254
正確にはわかりませんが おそらく 50 ヘルツ前後です

00:06:11.254 --> 00:06:13.730
素晴らしい2 つの作業があります

00:06:13.730 --> 00:06:18.314
今度は最初のファイルに rospy.spin を使って このように見える何かがあります

00:06:18.314 --> 00:06:20.899
この結果 私達が話しているコードになりますが

00:06:20.899 --> 00:06:23.004
かなり違って見えますここにループがあります

00:06:23.004 --> 00:06:25.879
それで ループ関数を定義し

00:06:25.879 --> 00:06:27.680
基本的にこれを行っているのは

00:06:27.680 --> 00:06:29.780
パブリッシュの頻度を制御するためです

00:06:29.779 --> 00:06:32.394
OK50 ヘルツを目標とします

00:06:32.394 --> 00:06:34.669
はいこの場合 おそらく 50 ヘルツより少し小さくて

00:06:34.670 --> 00:06:36.949
問題ありません

00:06:36.949 --> 00:06:40.779
公開する最後のウェイポイントは

00:06:40.779 --> 00:06:42.619
Autoware のコードの一部であるウェイポイント フォロワーに公開し

00:06:42.620 --> 00:06:45.550
30 ヘルツで実行されていると考えられます

00:06:45.550 --> 00:06:48.430
これらのメッセージは、30ヘルツで実行される 

00:06:48.430 --> 00:06:51.860
waypoint follower に行くだけなので

00:06:51.860 --> 00:06:55.290
30ヘルツまたはそれ未満まで下げることも可能です

00:06:55.290 --> 00:06:58.189
そのループは 50 ヘルツで絶えず起こっているため

00:06:58.189 --> 00:07:01.550
ここで何が起こっているのか見てみましょう

00:07:01.550 --> 00:07:04.240
pose と base_waypoints があれば

00:07:04.240 --> 00:07:06.155
それは 今話している 2 つのことです

00:07:06.154 --> 00:07:08.349
多くの rospy はシャットダウンされていないため

00:07:08.350 --> 00:07:10.365
これが実行しているものです

00:07:10.365 --> 00:07:12.960
そのため 最も近いウェイポイントを取得する必要があります

00:07:12.959 --> 00:07:14.810
この関数を使って

00:07:14.810 --> 00:07:17.634
get_closest_waypoint を取得し KDTree を使うことになります

00:07:17.634 --> 00:07:19.310
進み ウェイポイントを選びます

00:07:19.310 --> 00:07:20.774
そのため get_closest_waypoint を実行します

00:07:20.774 --> 00:07:22.339
はいget_closest_waypoint においては

00:07:22.339 --> 00:07:24.500
車両の座標を取得します

00:07:24.500 --> 00:07:29.314
self.pose.pose.position.x と sel.pose.pose.position.y です

00:07:29.314 --> 00:07:31.850
position.xy に到着する前に置く必要がある ポーズの

00:07:31.850 --> 00:07:34.640
数で悩む場合

00:07:34.639 --> 00:07:38.399
最善策は その種類のメッセージのメッセージ定義を調べることです

00:07:38.399 --> 00:07:41.584
it's.pose.pose は知っていますが just.pose は知りません

00:07:41.584 --> 00:07:43.799
メッセージの定義を見れば かなり明確なはずです

00:07:43.800 --> 00:07:47.400
メッセージをチェック アウトする方法について 教室において 指示がありますか?

00:07:47.399 --> 00:07:51.424
はい、このWaypoint Updater Nodeのコンセプトでは、

00:07:51.425 --> 00:07:53.560
rostopic と rosmsg について話しています

00:07:53.560 --> 00:07:59.040
それで 特定のメッセージ タイプについて より多くの情報を得るために ROS メッセージ情報を使うことができますか?

00:07:59.040 --> 00:08:01.110
はい ここで 詳しく見てみると

00:08:01.110 --> 00:08:03.925
ウェイポイントのためにフォーマットされている方法を見ることができます

00:08:03.925 --> 00:08:05.889
すべてのメッセージは

00:08:05.889 --> 00:08:08.750
プロジェクト レポートの 6 つのフォルダーにあります

00:08:08.750 --> 00:08:10.050
それで すべてのメッセージに不足があります

00:08:10.050 --> 00:08:14.160
ここを見れば、pose.poseだとわかります いいね

00:08:14.160 --> 00:08:19.420
では xとyに基づいて このツリーに対してクエリを実行します

00:08:19.420 --> 00:08:23.435
それで 返却されている配列があります

00:08:23.435 --> 00:08:27.764
ある種の距離 そして インデックス自体も推測しています

00:08:27.764 --> 00:08:31.969
それこそ いま述べたことです最初のものは 1 つのアイテムを返したいだけです

00:08:31.970 --> 00:08:35.340
そのため TB ツリー内でクエリ アイテムに最も近い点です

00:08:35.340 --> 00:08:37.100
2 番目の 1 によって

00:08:37.100 --> 00:08:40.779
クエリが位置とインデックスを返されます

00:08:40.779 --> 00:08:44.894
インデックスはK-Dツリーに入れたのと同じ順序です

00:08:44.894 --> 00:08:47.699
それで ウェイポイント用にこれらすべての二次元座標を入力します

00:08:47.700 --> 00:08:50.634
したがって 取得しようとしているのは基本的にその座標のインデックスです

00:08:50.634 --> 00:08:53.000
正しいです 最も近いインデックスに注意します

00:08:53.000 --> 00:08:54.205
次に起こる点を見てみましょう

00:08:54.205 --> 00:08:55.320
最も近い座標です

00:08:55.320 --> 00:08:57.025
これはウェイポイント 2D からのもので

00:08:57.024 --> 00:09:00.014
ウェイポイント2Dを取得しただけで

00:09:00.014 --> 00:09:01.960
前の座標も取得できます

00:09:01.960 --> 00:09:03.280
ここでは ちょっとした計算をしています

00:09:03.279 --> 00:09:05.309
なぜなら これらのウェイポイントが車の前にあることを確認したいと思ったからです

00:09:05.309 --> 00:09:07.544
よろしいですか?

00:09:07.544 --> 00:09:09.149
はい私たちは

00:09:09.149 --> 00:09:11.814
waypoint_tree.query によって最も近いウェイポイントを取得しました

00:09:11.815 --> 00:09:14.715
しかし そのポイントが自動車の前にあることを確認したいと考えています

00:09:14.715 --> 00:09:18.080
この種の超平面を使用してから内積を計算して

00:09:18.080 --> 00:09:21.335
それが正または負であることを確認し

00:09:21.335 --> 00:09:24.820
2 つのベクトル間の内積に基づいて

00:09:24.820 --> 00:09:29.420
最初のウェイポイントが実際に車両の正面にあるかどうかを確認できます

00:09:29.419 --> 00:09:31.349
ウェイポイントが車の背後になる場合

00:09:31.350 --> 00:09:33.990
無視してそれを切り取るだけでよいですか?

00:09:33.990 --> 00:09:35.740
次のポイントを取りますウェイポイントが車両の背後にあり

00:09:35.740 --> 00:09:39.009
最も近いウェイポイントが後ろにあると判断した場合 次のポイントを取ります

00:09:39.009 --> 00:09:42.939
次のポイントを取りますが ウェイポイント リスト全体の長さをモジュール化します

00:09:42.940 --> 00:09:44.550
コードにおいて

00:09:44.549 --> 00:09:46.139
val が 0 より大きい場合

00:09:46.139 --> 00:09:48.350
ウェイポイントが背後にあることを意味しているため

00:09:48.350 --> 00:09:50.465
最も近いインデックスプラス 1 を取りますが

00:09:50.465 --> 00:09:52.995
ウェイポイント 2D の長さをモジュール化します

00:09:52.995 --> 00:09:54.330
したがって この超平面については

00:09:54.330 --> 00:09:56.820
この数学がどのように機能するかについて少し話をする必要があります

00:09:56.820 --> 00:10:00.955
はいここに小さな図があります

00:10:00.955 --> 00:10:03.620
ここに基本的に起こっていることが示されています

00:10:03.620 --> 00:10:07.820
ここは 最も近いウェイポイントです

00:10:07.820 --> 00:10:11.215
それで これは Cl-vect です

00:10:11.215 --> 00:10:14.170
次に 前のウェイポイントがあります

00:10:14.169 --> 00:10:17.049
この矢印

00:10:17.049 --> 00:10:19.639
ここにあるこのベクトルは 最も近いベクトルと前のベクトルの差です

00:10:19.639 --> 00:10:21.889
これが基準ベクトルであり

00:10:21.889 --> 00:10:25.149
垂直なこの超平面を定義しています

00:10:25.149 --> 00:10:27.529
破線で与えられる超平面があり

00:10:27.529 --> 00:10:31.449
このベクトルに垂直であるべきです

00:10:31.450 --> 00:10:34.250
車は 2 つの状態のいずれかである場合もあります

00:10:34.250 --> 00:10:38.240
超平面の前方または背後ですね？

00:10:38.240 --> 00:10:41.730
この車は 2 つの状態にある可能性があります

00:10:41.730 --> 00:10:45.425
つまり pos_vect と pos_vect があります

00:10:45.424 --> 00:10:49.699
車が最も近いウェイポイントの正面にある場合

00:10:49.700 --> 00:10:52.629
車両は このベクトルによって決定される超平面の前に位置しています

00:10:52.629 --> 00:10:55.014
両方のベクトルは同じ方向を向いています

00:10:55.014 --> 00:10:58.024
最も近いインデックスは実際には車両の背部に位置します

00:10:58.024 --> 00:10:59.595
このドットの積は正です

00:10:59.595 --> 00:11:01.639
はい反対に

00:11:01.639 --> 00:11:05.889
車両の位置が超平面の背後にある場合は

00:11:05.889 --> 00:11:07.995
最も近いウェイポイントの背後にあることになります

00:11:07.995 --> 00:11:10.019
そのため 反対に位置します両は反対方向を示し

00:11:10.019 --> 00:11:12.324
 内積は負です

00:11:12.325 --> 00:11:12.625
もちろんできます

00:11:12.625 --> 00:11:14.529
OK これが

00:11:14.529 --> 00:11:17.269
最も近いウェイポイントが車両の前方 または 背後にあるかを示します

00:11:17.269 --> 00:11:20.029
はい まさにそこにコードで起こっていることです

00:11:20.029 --> 00:11:22.649
素晴らしいこの超平面をどのように扱っているか 内積が正か負か

00:11:22.649 --> 00:11:25.259
この座標が車両の前にあるか

00:11:25.259 --> 00:11:27.194
どうかを確認するために

00:11:27.195 --> 00:11:30.220
 この数学をもう少し調べてみましょう

00:11:30.220 --> 00:11:34.480
はい 最も近い座標がある最も近い vect を得ることができます

00:11:34.480 --> 00:11:39.254
私たちが使っている基本座標のようなもので すべて相対的なものです

00:11:39.254 --> 00:11:41.924
これが ウェイポイントの 2D 座標です

00:11:41.924 --> 00:11:44.629
車の位置を見ているだけで

00:11:44.629 --> 00:11:49.129
基準点からその車の位置までベクトルを描くことができます

00:11:49.129 --> 00:11:54.174
ここの前の座標である以前の vect と vect を配置します

00:11:54.174 --> 00:11:58.964
x y にあり これがどのように整列しているかを見ているようなものです

00:11:58.965 --> 00:12:02.389
車両の向き ウェイポイントの向きを使用でき

00:12:02.389 --> 00:12:04.519
前のウェイポイントから現在のウェイポイントまでのベクトル

00:12:04.519 --> 00:12:05.699
を作成し

00:12:05.700 --> 00:12:08.225
車両の方向を使って 同じ方向を向いているかどうかを確認できます

00:12:08.225 --> 00:12:10.144
これは 一つの可能な方法にすぎません

00:12:10.144 --> 00:12:12.889
最も近いインデックスを返し

00:12:12.889 --> 00:12:15.960
戻って来たもので 何が起こっているのか見ることができます

00:12:15.960 --> 00:12:18.590
それで これらのウェイポイントを公開しています

00:12:18.590 --> 00:12:20.155
closest_waypoint_idx

00:12:20.154 --> 00:12:22.564
今度は公開されているウェイポイント関数に行きます

00:12:22.565 --> 00:12:26.295
最も近いインデックスと車の前に最も近いウェイポイントのインデックスを持っているため

00:12:26.294 --> 00:12:29.245
メッセージ タイプは車線である必要があります

00:12:29.245 --> 00:12:30.914
それで 新しい車線オブジェクト

00:12:30.914 --> 00:12:32.034
 または新しい車線メッセージを作成します

00:12:32.034 --> 00:12:36.149
車線ヘッダーは基本ウェイポイント ヘッダーと同じです

00:12:36.149 --> 00:12:37.870
実際には関係ありません ヘッダーは使用しません

00:12:37.870 --> 00:12:40.759
この作業を 完全にスキップすることもできます

00:12:40.759 --> 00:12:47.679
車線のウェイポイントは ベース ウェイポイントからのウェイポイントになりますが

00:12:47.679 --> 00:12:51.089
分割されています  最も近いインデックスから最も近いインデックスになりますが

00:12:51.090 --> 00:12:54.570
多くの場合 ポイントを先読みします

00:12:54.570 --> 00:12:59.895
これはわかります終わった場合に モジュラー化することを心配する必要がありますか?

00:12:59.894 --> 00:13:02.199
いいえPython のスライスは本当にすばらしいからです

00:13:02.200 --> 00:13:04.285
最も近いインデックスとウェイポイントの予測が

00:13:04.284 --> 00:13:07.850
ウェイポイントの合計長よりも大きい場合は

00:13:07.850 --> 00:13:10.759
最も近いインデックスから最後までのスライドが表示されます

00:13:10.759 --> 00:13:13.049
実際に私が自分でプロジェクトを書いていたときに気づいた点ですが

00:13:13.049 --> 00:13:15.084
リストの終わりに近づいた際に

00:13:15.085 --> 00:13:16.210
突然

00:13:16.210 --> 00:13:18.019
車が前進するにつれて ウェイポイントは

00:13:18.019 --> 00:13:19.829
ますます小さくなり

00:13:19.830 --> 00:13:21.930
リストの最後で急停止します

00:13:21.929 --> 00:13:25.334
これは テスト スロット 2 で実際に行われていることとよく似ています

00:13:25.335 --> 00:13:28.050
実際には これが前の部分で扱った

00:13:28.049 --> 00:13:31.049
wウェイポイントが車の先端であるかどうかを判断しようとしたとき

00:13:31.049 --> 00:13:34.389
最も近いウェイポイントとその後ろのウェイポイントを使用した理由です

00:13:34.389 --> 00:13:36.730
ウェイポイントリストの最後に近づくにつれて

00:13:36.730 --> 00:13:39.180
最も近いウェイポイントとそれより先のウェイポイントを使用すると

00:13:39.179 --> 00:13:40.559
問題が発生する可能性が高くなります

00:13:40.559 --> 00:13:43.349
素晴らしいウェイポイント アップデーターのためだと思います

00:13:43.350 --> 00:13:44.480
はいこのコードが完成したら

00:13:44.480 --> 00:13:45.789
ROS を起動して

00:13:45.789 --> 00:13:51.504
端末に新しいタブを開くか 新しい端末ウィンドウを開いて

00:13:51.504 --> 00:13:53.544
開発環境を起動します

00:13:53.544 --> 00:13:57.959
develsetup.sh を起動し 最終ウェイポイントをエコーします

00:13:57.960 --> 00:14:01.170
ROS トピック エコー スラッシュはウェイポイントを見つけて

00:14:01.169 --> 00:14:04.769
このメモが必要とする最後のウェイポイントを公開していることを確認してください

00:14:04.769 --> 00:14:06.470
私はとても視覚的な人です

00:14:06.470 --> 00:14:09.475
このプロジェクトをやっていたとき ウェイポイントを目で見えるようにしたかったので

00:14:09.475 --> 00:14:13.490
実際にシミュレーターを修正して ウェイポイントを視覚化しました

00:14:13.490 --> 00:14:16.955
それで 最初の検証チェックは

00:14:16.955 --> 00:14:20.160
これらの作業をすべて行ってから シミュレーターを起動して

00:14:20.159 --> 00:14:24.375
緑色の球体が車の周りに浮かんでいるのを確認できるかどうかを確認するのと同じようなものです

00:14:24.375 --> 00:14:27.649
前半部分は終了です

00:14:27.649 --> 00:14:30.929
ありがとうございますまた お会いしましょう

