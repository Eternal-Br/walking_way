WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.935
在这里 我会全面接受 arm_mover 代码并解释发生了什么

00:00:03.935 --> 00:00:06.660
导入的 arm_mover 模块与

00:00:06.660 --> 00:00:09.945
Simple_arm 完全相同 除了两个新的导入

00:00:09.945 --> 00:00:14.250
即 关节状态消息和简单机器臂服务模块

00:00:14.250 --> 00:00:19.230
关节状态消息发布到 simple_arm/joint_states主题

00:00:19.230 --> 00:00:21.914
并用于监测机器臂的位置

00:00:21.914 --> 00:00:25.439
简单机器臂包和服务模块

00:00:25.440 --> 00:00:29.925
SRV 由 Catkin 自动生成 这是构建过程的一部分

00:00:29.925 --> 00:00:34.590
如果联合位置接近目标 则应用目标函数返回 true

00:00:34.590 --> 00:00:37.158
当从现实世界的传感器取测量值时

00:00:37.158 --> 00:00:39.340
总会有一些噪音

00:00:39.340 --> 00:00:43.280
由 gazebos 模拟器报告的联合位置也是如此

00:00:43.280 --> 00:00:48.265
如果两个位置都在目标的 0.05 弧度范围内 则返回 true

00:00:48.265 --> 00:00:51.210
夹具和边界功能负责

00:00:51.210 --> 00:00:55.064
执行每个关节的最小和最大关节角度

00:00:55.064 --> 00:00:58.109
如果传递的关节角度在可操作范围之外

00:00:58.109 --> 00:01:00.982
则会被限制在最接近的允许值

00:01:00.982 --> 00:01:04.799
每次夹具和边界被调用时

00:01:04.799 --> 00:01:07.304
都会从参数服务器中检索最小和最大关节角度

00:01:07.305 --> 00:01:10.245
这里的 Tildy 私有名称空间限定符

00:01:10.245 --> 00:01:15.335
它表明了希望得到的参数在节点的名称空间内

00:01:15.334 --> 00:01:20.634
例如 这里是 /simple_arm/

00:01:20.635 --> 00:01:24.689
第二个参数是 Rospy.get_param 无法从参数服务器

00:01:24.689 --> 00:01:29.569
获取参数时 返回的默认值

00:01:29.569 --> 00:01:33.344
如果需要 该函数的其余部分可以仅负责夹紧关节角度

00:01:33.344 --> 00:01:37.515
如果请求的关节角度超出范围 则会记录警告消息

00:01:37.515 --> 00:01:40.469
移动臂功能会命令机器臂移动

00:01:40.469 --> 00:01:44.435
并返回机器臂移动时所耗费的时间

00:01:44.435 --> 00:01:48.510
注意： 在函数内我们使用 rospy.wait_for_message

00:01:48.510 --> 00:01:53.590
调用以接收来自 /simple_arm/joint_states 主题的 joint_state
消息

00:01:53.590 --> 00:01:55.760
这是一个阻塞函数调用

00:01:55.760 --> 00:01:58.079
意思是说 在收到在简单机器臂/联合状态主题上消息之前

00:01:58.079 --> 00:02:01.739
它不会返回

00:02:01.739 --> 00:02:04.274
一般来说 你不应该使用 wait_for_message

00:02:04.275 --> 00:02:08.520
为了清晰起见 我们在这里地使用了它 因为 move_arm 被从

00:02:08.520 --> 00:02:11.280
Handle_safe_move_request 中函数调用

00:02:11.280 --> 00:02:14.805
该函数要求 该响应消息作为返回参数传回

00:02:14.805 --> 00:02:17.219
我们稍后再讨论这个问题

00:02:17.219 --> 00:02:19.500
这是服务句柄函数

00:02:19.500 --> 00:02:20.699
当服务客户端发送

00:02:20.699 --> 00:02:25.185
一个 GoToPositionRequest 到 safe_move 服务时 这个函数被调用

00:02:25.185 --> 00:02:28.349
函数参数 REQ 或请求是

00:02:28.349 --> 00:02:34.405
GoToPositionRequest 类型 服务响应是 GoToPositionResponse
类型

00:02:34.405 --> 00:02:38.504
只要收到新的服务请求 就会调用此服务函数处理程序

00:02:38.504 --> 00:02:42.990
从该函数返回对服务请求的响应

00:02:42.990 --> 00:02:44.381
还有个地方需要注意

00:02:44.381 --> 00:02:46.860
移动手臂功能正在阻塞

00:02:46.860 --> 00:02:50.150
直到手臂完成移动才会返回

00:02:50.150 --> 00:02:53.460
可以在机器臂执行其移动命令时 传入的消息无法处理

00:02:53.460 --> 00:02:57.480
也无法在python脚本中完成其他有效的工作

00:02:57.479 --> 00:02:59.669
虽然这对本例而言并不构成真正的问题

00:02:59.669 --> 00:03:04.614
但通常应该避免这种做法

00:03:04.615 --> 00:03:06.780
一种避免执行阻塞发生的好方法是

00:03:06.780 --> 00:03:10.900
使用动作而不是服务

00:03:10.900 --> 00:03:13.590
在下面的链接里 你可以找到关于何时最适合使用

00:03:13.590 --> 00:03:16.759
主题 何时使用服务的更多说明

00:03:16.759 --> 00:03:19.979
这里 节点是用名字 arm_mover 初始化的

00:03:19.979 --> 00:03:23.840
并使用名称 safe_move 创建了 GoToPositionService

00:03:23.840 --> 00:03:27.360
如前所述 Tildy 限定词表示

00:03:27.360 --> 00:03:32.265
该 safe_move 应该属于节点私有名称空间

00:03:32.264 --> 00:03:38.654
生成的服务名称将为 /arm_mover/safe_move

00:03:38.655 --> 00:03:41.319
Thirm 参数

00:03:41.319 --> 00:03:44.340
在 rospy.service_call 中是

00:03:44.340 --> 00:03:48.060
收到服务请求时调用的功能

00:03:48.060 --> 00:03:53.955
最后 rospy.spin 会保持阻塞 直到节点收到关闭请求为止

00:03:53.955 --> 00:03:56.760
如未能包括这一行 会导致

00:03:56.759 --> 00:04:00.840
Mover_service 返回 并且脚本完成执行

00:04:00.840 --> 00:04:03.974
最后 我们有 if_name _=_ main 这部分代码

00:04:03.974 --> 00:04:07.000
它与 simple_mover 类似

