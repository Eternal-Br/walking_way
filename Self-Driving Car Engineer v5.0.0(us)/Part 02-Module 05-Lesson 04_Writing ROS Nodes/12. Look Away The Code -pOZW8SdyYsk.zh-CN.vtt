WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:02.430
好的 我们继续

00:00:02.430 --> 00:00:05.115
我们逐步学习 LookAway 节点

00:00:05.115 --> 00:00:08.381
导入的模块与简单机器臂类似

00:00:08.381 --> 00:00:09.839
但是这次 我们

00:00:09.839 --> 00:00:14.375
正在导入图像信息类型 以便使用摄像机数据

00:00:14.375 --> 00:00:17.429
在这里 我们为这个节点定义一个类 来更好地跟踪

00:00:17.429 --> 00:00:20.850
机器人臂当前的运动状态和位置历史

00:00:20.850 --> 00:00:23.175
就像之前的节点定义一样

00:00:23.175 --> 00:00:27.120
该节点使用 rospy.init_node 函数进行初始化

00:00:27.120 --> 00:00:28.380
在本方法的末尾

00:00:28.379 --> 00:00:33.240
使用 rospy.spin 进行阻塞 直到节点收到关闭请求

00:00:33.240 --> 00:00:36.179
第一个订阅者 self.sub1

00:00:36.179 --> 00:00:40.079
订阅 simple_arm/joint_states 主题

00:00:40.079 --> 00:00:43.934
只有当机器臂没有移动时 才会写入节点 检查摄像机

00:00:43.935 --> 00:00:46.800
通过订阅 simple_arm/joint_state

00:00:46.799 --> 00:00:49.709
可以跟踪机器臂位置的变化

00:00:49.710 --> 00:00:54.450
这个主题的消息类型是 joint_state 伴随着每条消息

00:00:54.450 --> 00:00:58.410
消息数据都会被传递给 joint_states_callback 函数

00:00:58.409 --> 00:01:00.884
第二个订阅者 self.sub2

00:01:00.884 --> 00:01:04.364
订阅 rgb_camera/image _raw 主题

00:01:04.364 --> 00:01:07.829
这里的消息类型是图像 伴随着每条消息

00:01:07.829 --> 00:01:10.064
Look_away_callback 函数都会被调用

00:01:10.064 --> 00:01:14.545
通过服务代理 rospy 可以从节点调用服务

00:01:14.545 --> 00:01:18.765
此处的服务代理是使用你希望调用的服务的名称

00:01:18.765 --> 00:01:21.060
以及服务类定义创建的

00:01:21.060 --> 00:01:25.935
在本例中 arm_mover/safe_move 然后 GoToPosition

00:01:25.935 --> 00:01:30.609
实际的服务调用将发生在 look_away_callback 方法中

00:01:30.609 --> 00:01:32.594
代码中定义了两个助手

00:01:32.594 --> 00:01:36.614
uniform_image 以及 coord_equal

00:01:36.614 --> 00:01:40.784
Uniform_image 方法将图像作为输入 并检查是否

00:01:40.784 --> 00:01:45.149
图像中的所有颜色值与第一个像素的颜色值相同

00:01:45.150 --> 00:01:48.705
它会检查图像中的所有颜色值是否都相同

00:01:48.704 --> 00:01:52.890
如果坐标 coord_1 和 coord_2 的分量相同 满足规定公差

00:01:52.890 --> 00:01:57.545
则 coord_equal 方法返回 true

00:01:57.545 --> 00:02:02.219
当 self.sub1 在 simple_arm/joint _states 主题上收到消息时

00:02:02.219 --> 00:02:06.510
该消息被传递给变量数据中的 joint_states_callback

00:02:06.510 --> 00:02:10.500
Joint_states_callback 使用 coord_equal 帮助函数检查

00:02:10.500 --> 00:02:14.759
数据中提供的当前 joint_states 与之前的 joint_states 是否相同

00:02:14.759 --> 00:02:18.299
它们存储在 self.last_position 中

00:02:18.300 --> 00:02:20.925
如果当前和之前的 joint_states 相同

00:02:20.925 --> 00:02:22.439
满足规定公差

00:02:22.439 --> 00:02:24.335
则机器臂已经停止移动

00:02:24.335 --> 00:02:27.735
所以 self.arm_moving 标志被设置为 false

00:02:27.735 --> 00:02:30.755
如果当前和之前的 joint_states 不同

00:02:30.754 --> 00:02:32.400
那么机器臂仍在移动

00:02:32.400 --> 00:02:36.180
这时 该方法使用当前位置数据

00:02:36.180 --> 00:02:40.795
更新 self.last_position 并将 self.arm_moving 设置为 true

00:02:40.794 --> 00:02:48.299
Look_away_callback 正在接收来自 rgb_camera/image_raw
主题的数据

00:02:48.300 --> 00:02:52.995
该方法的第一行验证手臂没有移动 同时检查

00:02:52.995 --> 00:02:54.680
图像是否均匀

00:02:54.680 --> 00:02:57.780
如果手臂不在移动 并且图像均匀

00:02:57.780 --> 00:03:03.185
则创建 GoToPositionRequest 消息并使用 safe_move 服务发送该消息

00:03:03.185 --> 00:03:06.425
将两个关节角度调整至 1.57

00:03:06.425 --> 00:03:10.260
该方法还会记录一条消息 警告你相机已检测到

00:03:10.259 --> 00:03:14.649
一个均匀的图像 随着时间的推移 会返回一个更好的图像

