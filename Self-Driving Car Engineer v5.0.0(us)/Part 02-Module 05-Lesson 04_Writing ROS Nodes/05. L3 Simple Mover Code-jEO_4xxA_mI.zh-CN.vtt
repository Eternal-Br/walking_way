WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:02.160
在这里 我将介绍

00:00:02.160 --> 00:00:06.150
这个简单的 mover 节点的代码 并解释每一步发生的事情

00:00:06.150 --> 00:00:09.804
Rospy 是 ROS 的官方 Python 客户端库

00:00:09.804 --> 00:00:11.939
它提供了大部分

00:00:11.939 --> 00:00:14.924
通过 Python 与 ROS 进行交互所需的基本功能

00:00:14.925 --> 00:00:18.030
它拥有创建与主题交互的节点的工具

00:00:18.030 --> 00:00:20.429
服务、参数等等

00:00:20.429 --> 00:00:22.140
因此 务必花时间去看看

00:00:22.140 --> 00:00:25.289
Rospy API 文档和下面的链接

00:00:25.289 --> 00:00:26.640
关于 rospy 的一般信息

00:00:26.640 --> 00:00:30.660
包括可以在 ROS 维基上找到的其他教程

00:00:30.660 --> 00:00:33.149
首先 从标准消息包中

00:00:33.149 --> 00:00:38.119
我们导入 Float64 它是 ROS 中的一种原始消息类型

00:00:38.119 --> 00:00:41.289
该软件包还包含了所有其他基元类型

00:00:41.289 --> 00:00:42.574
稍后 在这个脚本中

00:00:42.575 --> 00:00:47.010
我们将发布 Float64 消息到每个联合的位置命令主题

00:00:47.009 --> 00:00:48.739
在 mover 函数开始

00:00:48.740 --> 00:00:50.414
声明了两个发布者

00:00:50.414 --> 00:00:52.199
一个用于 joint one 命令

00:00:52.200 --> 00:00:55.484
一个用于 joint two 命令

00:00:55.484 --> 00:00:58.950
这里 队列大小参数用于确定消息丢弃之前

00:00:58.950 --> 00:01:03.385
发布者可以存储的最大消息数量

00:01:03.384 --> 00:01:06.465
有关此参数的更多信息 请查看下面的链接

00:01:06.465 --> 00:01:10.700
这里 我正在初始化客户机节点并向主机注册

00:01:10.700 --> 00:01:12.460
Mover 是节点的名称

00:01:12.459 --> 00:01:14.729
并且必须先调用 init 节点函数

00:01:14.730 --> 00:01:17.400
然后才能调用任何其他 Rospy 包函数

00:01:17.400 --> 00:01:20.900
在第 13 行 创建了速率对象 rate

00:01:20.900 --> 00:01:23.670
在这里 我们将其设置为 10 赫兹

00:01:23.670 --> 00:01:27.829
速率用于限制某些环路在 ROS 中旋转的频率

00:01:27.829 --> 00:01:32.954
选择太高的速率可能会导致不必要的高 CPU 使用率

00:01:32.954 --> 00:01:37.144
而选择过低的速率可能会导致整个系统的高延迟

00:01:37.144 --> 00:01:41.579
为 ROS 系统中的所有节点选择合理的值是一种艺术

00:01:41.579 --> 00:01:44.774
开始时间用于确定已经过了多长时间

00:01:44.775 --> 00:01:46.950
当使用模拟时间操作 ROS 时

00:01:46.950 --> 00:01:48.180
就行我们现在这样

00:01:48.180 --> 00:01:51.120
Rospy.time.now 最初将返回

00:01:51.120 --> 00:01:56.100
零 直到在时钟主题上收到第一条消息

00:01:56.099 --> 00:02:01.530
这就是为什么 开始时间被设定并持续拉动 直到返回非零值

00:02:01.530 --> 00:02:05.135
在这里 由于调用 rate.sleep 我们有 main 循环

00:02:05.135 --> 00:02:07.785
循环遍历速度大约为 10 赫兹

00:02:07.784 --> 00:02:09.974
每次通过循环体将会导致

00:02:09.974 --> 00:02:12.599
发布两条关节命令消息

00:02:12.599 --> 00:02:16.125
关节角度以 10 秒的周期从正弦波中采样

00:02:16.125 --> 00:02:19.907
振幅为负二分之一 π 到正二分之一 π

00:02:19.907 --> 00:02:22.200
当节点收到关闭信号时

00:02:22.199 --> 00:02:23.429
无论是来自主机

00:02:23.430 --> 00:02:25.620
还是通过控制台窗口的 SIGINT

00:02:25.620 --> 00:02:28.460
都会退出循环 并且程序将继续

00:02:28.460 --> 00:02:31.695
这里 如果 name 变量被设置为 main

00:02:31.694 --> 00:02:34.935
以表明该脚本正在直接执行

00:02:34.935 --> 00:02:37.094
则 mover 函数将被调用

00:02:37.094 --> 00:02:42.525
当 Rospy 广泛使用异常时 这里的 try-except 代码部分很重要

00:02:42.525 --> 00:02:46.349
这里捕捉到的特殊异常是 ROS 中断异常

00:02:46.349 --> 00:02:50.129
当节点已收到关闭信号时 会引发此异常

00:02:50.129 --> 00:02:52.439
如果在节点关闭之前 需要进行一些清理工作

00:02:52.439 --> 00:02:55.409
清理将在这里完成

00:02:55.409 --> 00:02:59.555
有关 Rospy 异常的更多信息 请查看下面的链接

00:02:59.555 --> 00:03:01.620
假设你的工作空间

00:03:01.620 --> 00:03:03.914
刚刚建立 而且它的 setup.bash 已经完成

00:03:03.914 --> 00:03:08.009
你可以按如下方式启动简单机器臂

00:03:08.009 --> 00:03:15.179
一旦 ROS 主进程

00:03:15.180 --> 00:03:18.015
Gazebo 和所有的相关节点都正常运行

00:03:18.014 --> 00:03:20.209
我们就启动 simple mover 节点了

00:03:20.210 --> 00:03:29.932
好的

00:03:29.931 --> 00:03:34.959
结果应该大致这样

00:03:34.960 --> 00:03:38.129
祝贺你！ 你已经完成了的第一个ROS节点

