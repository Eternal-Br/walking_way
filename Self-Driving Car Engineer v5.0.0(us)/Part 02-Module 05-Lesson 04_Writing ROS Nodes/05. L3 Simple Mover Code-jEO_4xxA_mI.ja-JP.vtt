WEBVTT
Kind: captions
Language: ja-JP

00:00:00.000 --> 00:00:02.160
ここでは シンプル mover ノードのコードを実施して

00:00:02.160 --> 00:00:06.150
各ステップで何が起こっているのかを説明します

00:00:06.150 --> 00:00:09.804
Rospy は ROS 向けの公式 Python クライアントライブラリです

00:00:09.804 --> 00:00:11.939
Python と ROS を連動させる上で

00:00:11.939 --> 00:00:14.924
必要な基本的機能のほとんどが備わっています

00:00:14.925 --> 00:00:18.030
トピックやサービス パラメーターなどと連動して

00:00:18.030 --> 00:00:20.429
ノードを作成するインターフェースも含まれています

00:00:20.429 --> 00:00:22.140
詳細は Rospy API ドキュメンテーションと下記のリンクを

00:00:22.140 --> 00:00:25.289
ぜひ参照してください

00:00:25.289 --> 00:00:26.640
Rospy に関する一般的な情報とその他のチュートリアルは

00:00:26.640 --> 00:00:30.660
ROS Wiki で確認できます

00:00:30.660 --> 00:00:33.149
まず初めに 標準メッセージパッケージから

00:00:33.149 --> 00:00:38.119
ROSの主要なメッセージタイプの一つであるFloat64をインポートしてます

00:00:38.119 --> 00:00:41.289
このパッケージには他の全ての主要なタイプも含まれます

00:00:41.289 --> 00:00:42.574
このスクリプトでは後ほど

00:00:42.575 --> 00:00:47.010
Float64 メッセージを各ジョイントの位置コマンドトピックにパブリッシュします

00:00:47.009 --> 00:00:48.739
mover 関数の先頭で

00:00:48.740 --> 00:00:50.414
2 つのパブリッシャーが宣言されています

00:00:50.414 --> 00:00:52.199
1 つは joint_1 についての

00:00:52.200 --> 00:00:55.484
もう 1 つは jouint_2 についてのコマンドです

00:00:55.484 --> 00:00:58.950
ここで queue_size パラメーターは メッセージが削除される前に

00:00:58.950 --> 00:01:03.385
パブリッシャーに格納される最大メッセージ数を決定するために使用されます

00:01:03.384 --> 00:01:06.465
このパラメーターに関する詳細は 以下のリンクを参照してください

00:01:06.465 --> 00:01:10.700
ここでクライアントノードを初期化して マスターに登録します

00:01:10.700 --> 00:01:12.460
ここでの arm_mover はノードの名前です

00:01:12.459 --> 00:01:14.729
他の Rospy パッケージ関数が呼び出される前に

00:01:14.730 --> 00:01:17.400
init_node 関数を呼び出す必要があります

00:01:17.400 --> 00:01:20.900
13 行でレートオブジェクトが作成されます

00:01:20.900 --> 00:01:23.670
ここでオブジェクトは 10 ヘルツ の値に設定します

00:01:23.670 --> 00:01:27.829
このレートはROSで特定のループが回る頻度を制限するために使用されます

00:01:27.829 --> 00:01:32.954
レートが高すぎると CPU 使用率が不必要に高くなり

00:01:32.954 --> 00:01:37.144
レートが低すぎるとシステム全体に遅延が生じる可能性があります

00:01:37.144 --> 00:01:41.579
ROS システムのすべてのノードで適度な値を選択するには 高度な技術が必要です

00:01:41.579 --> 00:01:44.774
start_time は経過時間を特定するために使用します

00:01:44.775 --> 00:01:46.950
ここで行っているように

00:01:46.950 --> 00:01:48.180
シミュレーション時間で ROS を使用している場合

00:01:48.180 --> 00:01:51.120
rospy.time.now はクロックトピックで最初のメッセージが受信されるまで

00:01:51.120 --> 00:01:56.100
最初は 0 を返します

00:01:56.099 --> 00:02:01.530
このためスタート時間を設定し 0 以外の値が返されるまで定期的にポーリングを行います

00:02:01.530 --> 00:02:05.135
ここでは rate.sleep を呼び出すためメインループがあります

00:02:05.135 --> 00:02:07.785
ループはおよそ 10 ヘルツでスキャンします

00:02:07.784 --> 00:02:09.974
ループの本体を走査するたびに

00:02:09.974 --> 00:02:12.599
2 つのジョイントコマンドメッセージがパブリッシュされます

00:02:12.599 --> 00:02:16.125
ジョイント角はマイナス 2 分のパイからプラス 2 分のパイまでの間の

00:02:16.125 --> 00:02:19.907
正弦波から 10 秒周期でサンプリングされます

00:02:19.907 --> 00:02:22.200
ノードがシャットダウンシグナルを

00:02:22.199 --> 00:02:23.429
マスターから

00:02:23.430 --> 00:02:25.620
またはコンソールウィンドウの SIGINT シグナルを介して受信すると

00:02:25.620 --> 00:02:28.460
ノードは終了しプログラムが継続します

00:02:28.460 --> 00:02:31.695
name 変数を main に設定すると

00:02:31.694 --> 00:02:34.935
このスクリプトを直接実行し

00:02:34.935 --> 00:02:37.094
mover 関数を呼び出します

00:02:37.094 --> 00:02:42.525
Rospy は例外を広く使用するため この try-except ブロックは重要な役割を担っています

00:02:42.525 --> 00:02:46.349
 ここで ROS  interrupt exception という例外がキャッチされています

00:02:46.349 --> 00:02:50.129
この例外は ノードにシャットダウンシグナルが送信された場合に発生します

00:02:50.129 --> 00:02:52.439
ノードをシャットダウンする前に何らかのクリーンアップが必要な場合は

00:02:52.439 --> 00:02:55.409
ここで実行します

00:02:55.409 --> 00:02:59.555
 Rospy 例外に関する詳細は 以下のリンクを参照してください

00:02:59.555 --> 00:03:01.620
ワークスペースを最近構築して

00:03:01.620 --> 00:03:03.914
setup.bash をソースしている場合には

00:03:03.914 --> 00:03:08.009
以下のようにシンプルアームを起動することができます

00:03:08.009 --> 00:03:15.179
ROS マスターと Gazebo

00:03:15.180 --> 00:03:18.015
すべての関連ノードが立ち上がり実行されると

00:03:18.014 --> 00:03:20.209
シンプル mover ノードが起動できます

00:03:20.210 --> 00:03:29.932
はい

00:03:29.931 --> 00:03:34.959
このようになります

00:03:34.960 --> 00:03:38.129
お疲れさまでしたこれで 1 つ目の ROS ノードの記述が完了しました

