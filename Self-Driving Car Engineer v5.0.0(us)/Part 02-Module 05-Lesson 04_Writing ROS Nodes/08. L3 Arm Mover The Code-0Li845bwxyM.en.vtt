WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.935
Here, I'll step through the arm_mover code and explain what's going on.

00:00:03.935 --> 00:00:06.660
The imported modules for arm_mover are the same as

00:00:06.660 --> 00:00:09.945
simple_arm with the exception of two new imports.

00:00:09.945 --> 00:00:14.250
Namely, the joint state message and the simple Arm Service Module.

00:00:14.250 --> 00:00:19.230
Joint state messages are published to the simple_arm/joint_states topic,

00:00:19.230 --> 00:00:21.914
and are used for monitoring the position of the arm.

00:00:21.914 --> 00:00:25.439
The simple arm package and the service module,

00:00:25.440 --> 00:00:29.925
SRV, are automatically generated by Catkin as part of the build process.

00:00:29.925 --> 00:00:34.590
The app goal function returns true if the joint positions are close to the goals.

00:00:34.590 --> 00:00:37.158
When taking measurements from sensors in the real world,

00:00:37.158 --> 00:00:39.340
there'll always be some amount of noise.

00:00:39.340 --> 00:00:43.280
The same is true for joint positions reported by the gazebos simulator.

00:00:43.280 --> 00:00:48.265
If both positions are within 0.05 radians of the goal, true is returned.

00:00:48.265 --> 00:00:51.210
The clamp and boundaries function is responsible for

00:00:51.210 --> 00:00:55.064
enforcing the minimum and maximum joint angles for each joint.

00:00:55.064 --> 00:00:58.109
If the joint angles passed are outside of the operable range,

00:00:58.109 --> 00:01:00.982
they'll be clamped to the nearest allowable value.

00:01:00.982 --> 00:01:04.799
The minimum and maximum joint angles are retrieved from the parameter server,

00:01:04.799 --> 00:01:07.304
each time clamp and boundaries is called.

00:01:07.305 --> 00:01:10.245
The Tildy here is the private namespace qualifier,

00:01:10.245 --> 00:01:15.335
and indicates that the parameter which we wish to get is within the node's namespace.

00:01:15.334 --> 00:01:20.634
For example, here it's /simple_ arm/.

00:01:20.635 --> 00:01:24.689
The second parameter is the default value to be returned in the case

00:01:24.689 --> 00:01:29.569
that rospy.get_param was unable to get the parameter from the param server.

00:01:29.569 --> 00:01:33.344
The rest of this function simply clamps the joint angle if necessary.

00:01:33.344 --> 00:01:37.515
Warning messages are logged if the requested joint angles are out of bounds.

00:01:37.515 --> 00:01:40.469
The move arm function commands the arm to move,

00:01:40.469 --> 00:01:44.435
returning the amount of time that elapsed while the arm was moving.

00:01:44.435 --> 00:01:48.510
Note. Within the function we are using the rospy.wait_for_message

00:01:48.510 --> 00:01:53.590
call to receive joint_state messages from the /simple_arm/joint_states topic.

00:01:53.590 --> 00:01:55.760
This is a blocking function call.

00:01:55.760 --> 00:01:58.079
Meaning that it will not return until a message has been

00:01:58.079 --> 00:02:01.739
received on the simple arm/joint states topic.

00:02:01.739 --> 00:02:04.274
In general, you should not use wait_for_message.

00:02:04.275 --> 00:02:08.520
We simply use it here for the sake of clarity and because move_arm is being called from

00:02:08.520 --> 00:02:11.280
the handle_safe_move_request function which demands

00:02:11.280 --> 00:02:14.805
that the response message is passed back as a return parameter.

00:02:14.805 --> 00:02:17.219
We'll talk more about this in a moment.

00:02:17.219 --> 00:02:19.500
This is the service handler function.

00:02:19.500 --> 00:02:20.699
When a service client sends

00:02:20.699 --> 00:02:25.185
a GoToPositionRequest to the safe_move service this function is called.

00:02:25.185 --> 00:02:28.349
The function parameter REQ or request is a type

00:02:28.349 --> 00:02:34.405
GoToPositionRequest the service response is a type GoToPositionResponse.

00:02:34.405 --> 00:02:38.504
This service function handler is called whenever a new service request is received.

00:02:38.504 --> 00:02:42.990
The response to the service request is returned from the function.

00:02:42.990 --> 00:02:44.381
Another note here.

00:02:44.381 --> 00:02:46.860
The move arm function is blocking and

00:02:46.860 --> 00:02:50.150
will not return until the arm has finished its movement.

00:02:50.150 --> 00:02:53.460
Incoming messages cannot be processed and no other useful work

00:02:53.460 --> 00:02:57.480
can be done in the python script while the arm is performing its movement command.

00:02:57.479 --> 00:02:59.669
While this poses no real problem for

00:02:59.669 --> 00:03:04.614
this example it is a practice that should generally be avoided.

00:03:04.615 --> 00:03:06.780
One great way to avoid blocking the threat of

00:03:06.780 --> 00:03:10.900
execution would be to use an action rather than a service.

00:03:10.900 --> 00:03:13.590
You can find some more information about when it's best to use

00:03:13.590 --> 00:03:16.759
a topic versus a service versus an action in the links below.

00:03:16.759 --> 00:03:19.979
Here the node is initialized with the name arm_mover

00:03:19.979 --> 00:03:23.840
and the GoToPositionService is created with the name safe_move.

00:03:23.840 --> 00:03:27.360
As mentioned previously the Tildy qualifier identifies

00:03:27.360 --> 00:03:32.265
that safe_move is meant to belong to the nodes private namespace.

00:03:32.264 --> 00:03:38.654
The resulting service name will be /arm_mover/safe_move.

00:03:38.655 --> 00:03:41.319
The thirm parameter to the

00:03:41.319 --> 00:03:44.340
rospy.service_call is the function

00:03:44.340 --> 00:03:48.060
that should be called when a service request is received.

00:03:48.060 --> 00:03:53.955
Lastly, rospy.spin simply blocks until the shutdown request is received by the node.

00:03:53.955 --> 00:03:56.760
Failure to include this line would result in

00:03:56.759 --> 00:04:00.840
mover_service returning and the script completing execution.

00:04:00.840 --> 00:04:03.974
Finally, we have the if_name_=_main block.

00:04:03.974 --> 00:04:07.000
This section of code is similar to that of simple_mover.

