{
  "data": {
    "lesson": {
      "id": 627666,
      "key": "2ac1492e-9320-4e42-91a5-0845e4f77b0c",
      "title": "Markov Localization",
      "semantic_type": "Lesson",
      "is_public": true,
      "version": "1.0.0",
      "locale": "en-us",
      "summary": "Learn the math behind localization as well as how to implement Markov localization in C++.",
      "lesson_type": "Classroom",
      "display_workspace_project_only": false,
      "resources": {
        "files": [
          {
            "name": "Videos Zip File",
            "uri": "https://zips.udacity-data.com/2ac1492e-9320-4e42-91a5-0845e4f77b0c/627666/1538942217177/Markov+Localization+Videos.zip"
          },
          {
            "name": "Transcripts Zip File",
            "uri": "https://zips.udacity-data.com/2ac1492e-9320-4e42-91a5-0845e4f77b0c/627666/1538942209485/Markov+Localization+Subtitles.zip"
          }
        ],
        "google_plus_link": null,
        "career_resource_center_link": null,
        "coaching_appointments_link": null,
        "office_hours_link": null,
        "aws_provisioning_link": null
      },
      "project": null,
      "lab": null,
      "concepts": [
        {
          "id": 663302,
          "key": "78c2a2ee-f41b-429a-8d32-445f0a64df39",
          "title": "Return to Bayes' Rule",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "78c2a2ee-f41b-429a-8d32-445f0a64df39",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 663303,
              "key": "5f5db9fd-8377-43d6-8b38-e24b569ab553",
              "title": "05 Localization A02 A Return To Bayes Ruls",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "7FgzbyeJCp8",
                "china_cdn_id": "7FgzbyeJCp8.mp4"
              }
            }
          ]
        },
        {
          "id": 279139,
          "key": "d18b242f-9ed9-43a4-802e-fd1ed6767042",
          "title": "Overview",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "d18b242f-9ed9-43a4-802e-fd1ed6767042",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 464114,
              "key": "583e7997-1cf5-4981-b4e7-bdd412a0ca58",
              "title": "Markov Location Lesson Overview",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "rSj5lpzliQg",
                "china_cdn_id": "rSj5lpzliQg.mp4"
              }
            },
            {
              "id": 394651,
              "key": "d9d9e3ef-ffb8-437d-ba0c-7581d4934a23",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Markov Localization and the Kidnapped Vehicle Project\n\nThe localization module culminates in the Kidnapped Vehicle Project.  In that project our vehicle has been kidnapped and placed in an unknown location.  We must leverage our knowledge of localization to determine where our vehicle is.  The Kidnapped Vehicle Project relies heavily on the particle filter approach to localization, particularly \"Implementation of a Particle Filter,\" an upcoming lesson.  This leaves the question;  How does Markov Localization relate to the Kidnapped Vehicle project?\n\nMarkov Localization or Bayes Filter for Localization is a generalized filter for localization and all other localization approaches are realizations of this approach, as we'll discuss later on.  By learning how to derive and implement (coding exercises) this filter we develop intuition and methods that will help us solve any vehicle localization task, including implementation of a particle filter.  We don't know exactly where our vehicle is at any given time, but can approximate it's location.  As such, we generally think of our vehicle location as a probability distribution, each time we move, our distribution becomes more diffuse (wider).  We pass our variables (map data, observation data, and control data) into the filter to concentrate (narrow) this distribution, at each time step.  Each state prior to applying the filter represents our prior and the narrowed distribution represents our Bayes' posterior.",
              "instructor_notes": ""
            },
            {
              "id": 380166,
              "key": "d72eb5f3-09a4-4f12-9051-26949a9739cd",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Bayes' Rule\nIf you'd like a reminder about how Bayes' rule works, make sure to go back and watch Sebastian's Bayes' rule video from the Localization Overview lesson!",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 279140,
          "key": "aa553fe7-4db5-4d09-a5bc-cc6070888183",
          "title": "Localization Posterior: Introduction",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "aa553fe7-4db5-4d09-a5bc-cc6070888183",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 464115,
              "key": "030982b7-4a26-47f7-9b06-1bad672b62f8",
              "title": "ND013 M4 L3 02 L Localization Posterior",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "WCva9DtGgGA",
                "china_cdn_id": "WCva9DtGgGA.mp4"
              }
            },
            {
              "id": 380165,
              "key": "488eb429-9836-41b6-a96b-16d1da76d3fe",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Formal Definition of Variables\n\n<span class=\"mathquill\">  z_{1:t} </span> represents the observation vector from time 0 to t (range measurements, bearing, images, etc.).\n\n<span class=\"mathquill\">u_{1:t}</span> represents the control vector from time 0 to t (yaw/pitch/roll rates and velocities).\n\n<span class=\"mathquill\">m </span> represents the map (grid maps, feature maps, landmarks)\n\n<span class=\"mathquill\">x_t</span> represents the pose (position (x,y) + orientation <span class=\"mathquill\">\\theta</span>)\n\n",
              "instructor_notes": ""
            },
            {
              "id": 287343,
              "key": "6be77385-f6e1-4663-bd7b-d9493081d045",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Quiz\n\nGiven the map, the control elements of the car, and the observations, what is the definition of the posterior distribution for the state x at time t?\n\n(A) <div class=\"mathquill\"> bel(x_t) = p(x_t|z_t, m, u_t)</div>\n\n(B) <div class=\"mathquill\">bel(x_t) = p(x_t| z_{1:t}, u_{1:t})</div>\n\n(C) <div class=\"mathquill\">bel(x_t) = p(x_t, m_t|z_{1:t}, u_{1:t})</div>\n\n(D) <div class=\"mathquill\">bel(x_t) = p(x_t|z_{1:t}, u_{1:t}, m)</div>",
              "instructor_notes": ""
            },
            {
              "id": 287334,
              "key": "a114c630-e72b-40f3-ada9-2089a04694aa",
              "title": "Localization Posterior: Probabilistic Formulation",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "a114c630-e72b-40f3-ada9-2089a04694aa",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "Given the map, the control elements of the car, and the observations, what is the definition of the posterior distribution for the state x at time t?",
                "answers": [
                  {
                    "id": "a1490233153425",
                    "text": "(A)",
                    "is_correct": false
                  },
                  {
                    "id": "a1490233203897",
                    "text": "(B)",
                    "is_correct": false
                  },
                  {
                    "id": "a1490233204632",
                    "text": "(C)",
                    "is_correct": false
                  },
                  {
                    "id": "a1490233205233",
                    "text": "(D)",
                    "is_correct": true
                  }
                ]
              }
            }
          ]
        },
        {
          "id": 279141,
          "key": "f62b09b7-ea93-46a7-9c5f-53dffb6d1621",
          "title": "Localization Posterior Explanation and Implementation",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "f62b09b7-ea93-46a7-9c5f-53dffb6d1621",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 464116,
              "key": "d9b5f6a2-c411-4cfb-8fdf-6612473f66eb",
              "title": "03 L Explain Localization Posterior V2",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "lGpIgbA5ZdA",
                "china_cdn_id": "lGpIgbA5ZdA.mp4"
              }
            }
          ]
        },
        {
          "id": 458685,
          "key": "d46d4428-2c64-46a8-ae23-6ba3c77484e8",
          "title": "Bayes' Rule",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "d46d4428-2c64-46a8-ae23-6ba3c77484e8",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 458686,
              "key": "cfc6d31a-67b1-46e4-9717-6f8dc90b0da4",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Before we dive into deeper into Markov localization, we should review Bayes' Rule.  This will serve as a refresher for those familiar with Bayesian methods and we provide some additional resources for those less familiar.  \n\n  Recall that Bayes' Rule enables us to determine the conditional probability of a state given evidence P(a|b) by relating it to the conditional probability of the evidence given the state P(b|a) in the form of:\n\n <div class=\"mathquill\">P(a)*P(b|a) = P(b)*P(a|b)</div>\n\nwhich can be rearranged to:\n\n<div class=\"mathquill\">P(a|b) = \\frac{P(b|a) \\, P(a)}{P(b)} </div>\n\n  In other words the probability of state a, given evidence b, is the probability of evidence b, given state a, multiplied by the probability of state a, normalized by the total probability of b over all states.  \n\nLet's move on to an example to illustrate the utility of Bayes' Rule.",
              "instructor_notes": ""
            },
            {
              "id": 458703,
              "key": "c665d63d-2d8e-48f8-9779-148c11c922a5",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Bayes' Rule Applied\n\nLet's say we have two bags of marbles, bag 1 and bag 2, filled with two types of marbles, red and blue.  Bag 1 contains 10 blue marbles and 30 red marbles, whereas bag 2 contains 20 of each color marble.  \n\nIf a friend were to choose a bag at random and then a marble at random, from that bag, how can we determine the probability that that marble came from a specific bag?  You guessed it - Bayes' Rule! \n\nIn this scenario, our friend produces a red marble, in that case, what is the probability that the marble came from bag 1?  Rewriting this in terms of Bayes' Rule, our solution becomes:\n\n<div class=\"mathquill\">P(Bag1 | Red) = \\frac{P(Red | Bag1) \\, P(Bag1)}{P(Red)} </div>  \n\n Let's walk through the process in the following quizzes.",
              "instructor_notes": ""
            },
            {
              "id": 458723,
              "key": "6ce315d7-a6c7-4a2f-ba0a-d9ef9a198861",
              "title": "Calculate Prior",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "6ce315d7-a6c7-4a2f-ba0a-d9ef9a198861",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "What is the prior probability of choosing bag 1?  This is the term <span class= \"mathquill\"> P(Bag1) </span>.",
                "answers": [
                  {
                    "id": "a1510255150501",
                    "text": "0.75",
                    "is_correct": false
                  },
                  {
                    "id": "a1510255180636",
                    "text": "0.50",
                    "is_correct": true
                  },
                  {
                    "id": "a1510255183070",
                    "text": "0.25",
                    "is_correct": false
                  },
                  {
                    "id": "a1510255195931",
                    "text": "0.60",
                    "is_correct": false
                  }
                ]
              }
            },
            {
              "id": 458731,
              "key": "4527c436-9c8c-4c48-8329-f6c21d02048c",
              "title": "Calculate Likelihood",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "4527c436-9c8c-4c48-8329-f6c21d02048c",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "What is the probability of choosing a red marble from bag 1?  This is our likelihood term <span class= \"mathquill\"> P(Red|Bag1) </span>.",
                "answers": [
                  {
                    "id": "a1510255339188",
                    "text": "0.50",
                    "is_correct": false
                  },
                  {
                    "id": "a1510255619316",
                    "text": "0.30",
                    "is_correct": false
                  },
                  {
                    "id": "a1510255620492",
                    "text": "0.25",
                    "is_correct": false
                  },
                  {
                    "id": "a1510255621660",
                    "text": "0.75",
                    "is_correct": true
                  }
                ]
              }
            },
            {
              "id": 458734,
              "key": "1e4b6cb8-eb5b-40d6-8cc4-4788bc0ee2c4",
              "title": "",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "1e4b6cb8-eb5b-40d6-8cc4-4788bc0ee2c4",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "What is the total probability of choosing a red marble?  This is our normalization term (denominator) <span class= \"mathquill\"> P(Red) </span>.",
                "answers": [
                  {
                    "id": "a1510256282535",
                    "text": "0.50",
                    "is_correct": false
                  },
                  {
                    "id": "a1510256900662",
                    "text": "1.25",
                    "is_correct": false
                  },
                  {
                    "id": "a1510256901739",
                    "text": "0.625",
                    "is_correct": true
                  },
                  {
                    "id": "a1510256902665",
                    "text": "0.75",
                    "is_correct": false
                  }
                ]
              }
            },
            {
              "id": 458735,
              "key": "1a60e5ff-afde-42b7-b022-1607abb86842",
              "title": "",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "1a60e5ff-afde-42b7-b022-1607abb86842",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "Now, putting everything together, using the formula for Bayes' Rule, what is our posterior probability of the red marble originating from bag 1?  This is our posterior term <span class= \"mathquill\"> P(Bag1|Red) </span>?",
                "answers": [
                  {
                    "id": "a1510256976498",
                    "text": "0.815",
                    "is_correct": false
                  },
                  {
                    "id": "a1510257022682",
                    "text": "0.625",
                    "is_correct": false
                  },
                  {
                    "id": "a1510257024281",
                    "text": "0.375",
                    "is_correct": false
                  },
                  {
                    "id": "a1510257079817",
                    "text": "0.60",
                    "is_correct": true
                  }
                ]
              }
            },
            {
              "id": 458692,
              "key": "6ff99fbc-1279-4b76-91e2-b6d77200d1cf",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Bayesian Methods Resources\n\n- [Sebastian Discusses Bayes Rule](https://classroom.udacity.com/nanodegrees/nd013/parts/30260907-68c1-4f24-b793-89c0c2a0ad32/modules/28233e55-d2e8-4071-8810-e83d96b5b092/lessons/3c8dae65-878d-4bee-8c83-70e39d3b96e0/concepts/487221690923?contentVersion=2.0.0&contentLocale=en-us)\n- [More Bayes Rule Content from Udacity](https://classroom.udacity.com/courses/st101/lessons/48703346/concepts/483698470923)\n- [Bayes Rule with Ratios](https://betterexplained.com/articles/understanding-bayes-theorem-with-ratios)\n- [A Deep Dive into Bayesian Methods, for Programmers](http://greenteapress.com/wp/think-bayes/)",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 458767,
          "key": "89b71ff9-8058-415d-b5cc-ea01954f2825",
          "title": "Bayes' Filter For Localization",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "89b71ff9-8058-415d-b5cc-ea01954f2825",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 458770,
              "key": "4694a13a-ff67-4d2a-a870-57a7546e1da0",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "We can apply Bayes' Rule to vehicle localization by passing variables through Bayes' Rule for each time step, as our vehicle moves.  This is known as a Bayes' Filter for Localization.  We will cover the specific as the lesson continues, but the generalized form Bayes' Filter for Localization is shown below.  You may recognize this as being similar to a Kalman filter.  In fact, many localization filters, including the Kalman filter are special cases of Bayes' Filter.\n\nRemember the general form for Bayes' Rule:\n\n <div class=\"mathquill\">P(a|b) = \\frac{P(b|a) \\, P(a)}{P(b)} </div>  \n\nWith respect to localization, these terms are:\n\n1.  <span class=\"mathquill\">P(location|observation)</span>: This is P(a|b), the **normalized** probability of a position given an observation (posterior). \n-  <span class=\"mathquill\">P(observation|location)</span>: This is P(b|a), the probability of an observation given a position (likelihood)\n-  <span class=\"mathquill\">P(location)</span>:  This is P(a), the prior probability of a position \n- <span class=\"mathquill\">P(observation) </span>: This is P(b), the total probability of an observation\n\nWithout going into detail yet, be aware that <span class=\"mathquill\">P(location)</span> is determined by the motion model.  The probability returned by the motion model is the product of the transition model probability (the probability of moving from <span class=\"mathquill\">x_{t-1}</span> --> <span class=\"mathquill\">x_t</span>  and the probability of the state <span class=\"mathquill\">x_{t-1}</span>. \n\n",
              "instructor_notes": ""
            },
            {
              "id": 461196,
              "key": "6ad4d0ae-40b9-406a-acd8-53335be89022",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Over the course of this lesson, you’ll build your own Bayes’ filter. In the next few quizzes, you’ll write code to:\n1. Compute Bayes’ rule\n2. Calculate Bayes' posterior for localization\n3. Initialize a prior belief state\n4. Create a function to initialize a prior belief state given landmarks and assumptions\n",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 461194,
          "key": "6f24b54a-d753-4281-a36a-df012c6a11ba",
          "title": "Calculate Localization Posterior",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "6f24b54a-d753-4281-a36a-df012c6a11ba",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 461225,
              "key": "3a8f3d5e-49f7-4cf3-8ddc-30da086143db",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "To continue developing our intuition for this filter and prepare for later coding exercises, let's walk through calculations for determining posterior probabilities at several pseudo positions x, for a single time step.  We will start with a time step after the filter has already been initialized and run a few times.  We will cover initialization of the filter in an upcoming concept.",
              "instructor_notes": ""
            },
            {
              "id": 461234,
              "key": "e3d57603-c126-4e59-bbd1-cd22cb009969",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "| pseudo_position (x) | P(location) | P(observation∣location) |Raw P(location∣observation) | Normalized P(location∣observation) |\n|:------------:|:-----------------:|:--------------:|:------------:|:-----------------------:|\n|       1      |      1.67E-02     |    0.00E+00    |   0.00E+00   |         0.00E+00        |\n|       2      |      3.86E-02     |    6.99E-03    |   ?   |         2.59E-02        |\n|       3      |      4.90E-02     |    8.52E-02    |   4.18E-03   |         4.01E-01        |\n|       4      |      3.86E-02     |    ?   |   5.42E-03   |         5.21E-01        |\n|       5      |      1.69E-02     |    3.13E-02    |   5.31E-04   |         5.10E-02        |\n|       6      |      6.51E-03     |    9.46E-04    |   6.16E-06   |         ?        |\n|       7      |      ?     |    3.87E-06    |   6.55E-08   |         6.29E-06        |\n|       8      |      3.86E-02     |    0.00E+00    |   0.00E+00   |         0.00E+00        |\n\n**Normalized P(location_observation) vs. Raw P(location|observation):** The **Raw P(location|observation)** is the result prior to dividing by the total probability of P(observation), the P(b) term (denominator) of the generalized Bayes`rule. The **normalized P(location|observation)** is the result of  after dividing by P(observation).\n\nRemember the general form for Bayes' Rule:\n\n <div class=\"mathquill\">P(a|b) = \\frac{P(b|a) \\, P(a)}{P(b)} </div> \n\nWith respect to localization, these terms are:\n\n1.  <span class=\"mathquill\">P(location|observation)</span>: This is P(a|b), the **normalized** probability of a position given an observation (posterior)  \n-  <span class=\"mathquill\">P(observation|location)</span>: This is P(b|a), the probability of an observation given a position (likelihood)\n-  <span class=\"mathquill\">P(location)</span>:  This is P(a), the prior probability of a position \n- <span class=\"mathquill\">P(observation) </span>: This is P(b), the total probability of an observation\n\n\n",
              "instructor_notes": ""
            },
            {
              "id": 461240,
              "key": "c74ba89f-b642-4c37-a1cf-da7be2e3c052",
              "title": "P(observation∣location)",
              "semantic_type": "ValidatedQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "c74ba89f-b642-4c37-a1cf-da7be2e3c052",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "What is P(observation∣location) for x = 4? Write the answer in scientific notation with an accuracy of two decimal places, for example 3.14E-15",
                "matchers": [
                  {
                    "expression": "1.40E-(0|)1"
                  }
                ]
              }
            },
            {
              "id": 465899,
              "key": "c28f0995-da1a-453e-9d6c-9c39dffdf086",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "<div id=\"spoiler\" style=\"display:none\">\nTo determine the observation probability divide the P(posterior) by P(position):\n\n**5.42E-3/3.86E-2 = 1.40E-1**\n</div>\n<button title=\"Click to show/hide content\" type=\"button\" onclick=\"if(document.getElementById('spoiler') .style.display=='none') {document.getElementById('spoiler') .style.display=''}else{document.getElementById('spoiler') .style.display='none'}\">Show Solution</button>",
              "instructor_notes": ""
            },
            {
              "id": 461239,
              "key": "9efdd092-e510-4af3-a581-7252d76d0014",
              "title": "P(Posterior)",
              "semantic_type": "ValidatedQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "9efdd092-e510-4af3-a581-7252d76d0014",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "What is the raw posterior probability P(location|observation) for x = 2? Be sure to put the answer in scientific notation with an accuracy of two decimal places, for example 3.14E-15.",
                "matchers": [
                  {
                    "expression": "2.7[0-1]E-(0|)4"
                  },
                  {
                    "expression": "2.7E-(0|)4"
                  }
                ]
              }
            },
            {
              "id": 465905,
              "key": "890ae184-16f4-4e93-a5f3-f77ff6316dd8",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "<div id=\"spoiler_1\" style=\"display:none\">\nTo determine the raw posterior probability multiply the P(observation|location) by P(location):\n\n**6.99E-3 * 3.86E-2 = 2.70E-4**\n</div>\n<button title=\"Click to show/hide content\" type=\"button\" onclick=\"if(document.getElementById('spoiler_1') .style.display=='none') {document.getElementById('spoiler_1') .style.display=''}else{document.getElementById('spoiler_1') .style.display='none'}\">Show Solution</button>",
              "instructor_notes": ""
            },
            {
              "id": 461241,
              "key": "4c3f4016-1536-4b36-be22-38ff6f1fdd9e",
              "title": "Normalized Posterior Probability",
              "semantic_type": "ValidatedQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "4c3f4016-1536-4b36-be22-38ff6f1fdd9e",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "What is the normalized posterior probability for x = 6?  Write the answer in scientific notation with an accuracy of two decimal places, for example 3.14E-15.",
                "matchers": [
                  {
                    "expression": "5.9[1-3]E-(0|)4"
                  }
                ]
              }
            },
            {
              "id": 465910,
              "key": "e135619d-160e-4002-b4f5-4d4c4a05a78b",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "<div id=\"spoiler_2\" style=\"display:none\">\nTo determine the normalized posterior probability, first sum the raw P(Posterior) to get the total:\n\n**0.00E+00 + 2.70E-04 + 4.18E-03 + 5.42E-03 + 5.31E-04 + 6.16E-06 + 6.55E-08 + 0.00E+00 = 1.04E-02**\n\nNext, divide the P(Posterior) by the sum:\n\n**6.16E-06/1.04E-02 = 5.92E-4**\n\n\n\n</div>\n<button title=\"Click to show/hide content\" type=\"button\" onclick=\"if(document.getElementById('spoiler_2') .style.display=='none') {document.getElementById('spoiler_2') .style.display=''}else{document.getElementById('spoiler_2') .style.display='none'}\">Show Solution</button>",
              "instructor_notes": ""
            },
            {
              "id": 461242,
              "key": "033d09b3-21f1-44ba-91d5-464e8ef1b584",
              "title": "P(Position)",
              "semantic_type": "ValidatedQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "033d09b3-21f1-44ba-91d5-464e8ef1b584",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "What is the position probability for x = 7? Write your answer in scientific notation with an accuracy of two decimal places, for example 3.14E-15",
                "matchers": [
                  {
                    "expression": "1.6[7-9]E-(0|)2"
                  }
                ]
              }
            },
            {
              "id": 465911,
              "key": "af7f325b-8b36-4f19-9c2a-12df7f030c05",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "<div id=\"spoiler_3\" style=\"display:none\">\nTo determine the position probability  divide P(posterior) by P(observation):\n\n**3.87E-06 * 6.55E-08 = 1.69E-2**\n</div>\n<button title=\"Click to show/hide content\" type=\"button\" onclick=\"if(document.getElementById('spoiler_3') .style.display=='none') {document.getElementById('spoiler_3') .style.display=''}else{document.getElementById('spoiler_3') .style.display='none'}\">Show Solution</button>",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 458845,
          "key": "b04b578e-ac58-4012-a7ec-0fba40fe1558",
          "title": "Initialize Belief State",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "b04b578e-ac58-4012-a7ec-0fba40fe1558",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 458853,
              "key": "b0bb6b07-59a5-4343-9e54-8602131f94db",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "To help develop an intuition for this filter and prepare for later coding exercises, let's walk through the process of initializing our prior belief state.  That is, what values should our initial belief state take for each possible position?  Let's say we have a 1D map extending from 0  to 25 meters.  We have landmarks at x = 5.0, 10.0, and 20.0 meters, with position standard deviation of 1.0 meter.  If we know that our car's initial position is at one of these three landmarks, how should we define our initial belief state?\n\nSince we know that we are parked next to a landmark, we can set our probability of being next to a landmark as 1.0.  Accounting for a position precision of +/- 1.0 meters, this places our car at an initial position in the range **[4, 6]** (5 +/- 1),  **[9, 11]** (10 +/- 1), or **[19, 21]** (20 +/- 1).  All other positions, not within 1.0 meter of a landmark, are initialized to 0.  We normalize these values to a total probability of 1.0 by dividing by the total number of positions that are potentially occupied.   In this case, that is 9 positions, 3 for each landmark (the landmark position and one position on either side). This gives us a value of 1.11E-01 for positions +/- 1 from our landmarks (1.0/9).  So, our initial belief state is:\n\n```{0, 0, 0, 1.11E-01, 1.11E-01, 1.11E-01, 0, 0, 1.11E-01, 1.11E-01, 1.11E-01, 0, 0, 0, 0, 0, 0, 0, 1.11E-01, 1.11E-01, 1.11E-01, 0, 0, 0, 0}```\n\nTo reinforce this concept, let's practice with a quiz.\n\n- **map size:** 100 meters\n- **landmark positions:** {8, 15, 30, 70, 80}\n- **position standard deviation:** 2 meters\n\nAssuming we are parked next to a landmark, answer the following questions about our initial belief state.\n\n",
              "instructor_notes": ""
            },
            {
              "id": 465511,
              "key": "bbc1afc3-fded-4785-94be-7d8d21f2bfb6",
              "title": "Initial Probability for Position 11",
              "semantic_type": "ValidatedQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "bbc1afc3-fded-4785-94be-7d8d21f2bfb6",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "What is our initial probability (initial belief state) for position 11? If the answer is non-zero, enter it in scientific notation with an accuracy of two decimal places, for example 3.14E-15. ",
                "matchers": [
                  {
                    "expression": "0"
                  }
                ]
              }
            },
            {
              "id": 465512,
              "key": "a5abe86f-626c-4df2-b85d-1254741d7102",
              "title": "Initial Probability for Position 71",
              "semantic_type": "ValidatedQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "a5abe86f-626c-4df2-b85d-1254741d7102",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "What is our initial probability (initial belief state) for position 71? If the answer is non-zero, enter it in scientific notation with an accuracy of two decimal places, for example 3.14E-15. ",
                "matchers": [
                  {
                    "expression": "4.0[0-1]E-(0|)2"
                  }
                ]
              }
            },
            {
              "id": 465927,
              "key": "f1858314-5481-4a4f-a0d2-ba73c50bafe6",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "<div id=\"spoiler_1\" style=\"display:none\">\nTo determine the initial probability we will divide 1.0 by the total number of positions within 2 meters of a landmark.  In this case we have 5 landmarks and a position standard deviation of 2.0 meters.  This gives us 5 potentially occupied positions per landmark (the landmark position and 2 each side), yielding 25 potentially occupied positions (5 landmarks * 5 positions/landmark).\n\n**1.0/25 = 4.00E-02** - remember to enter two decimal places!\n</div>\n<button title=\"Click to show/hide content\" type=\"button\" onclick=\"if(document.getElementById('spoiler_1') .style.display=='none') {document.getElementById('spoiler_1') .style.display=''}else{document.getElementById('spoiler_1') .style.display='none'}\">Show Solution</button>",
              "instructor_notes": ""
            },
            {
              "id": 466026,
              "key": "3143f153-b23b-4d55-b872-dc34368aeee5",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "In the next concept, we will implement belief state initialization in C++.",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 465514,
          "key": "8e42e4c9-a33c-4138-9009-ff049c6e56cf",
          "title": "Initialize Priors Function",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "8e42e4c9-a33c-4138-9009-ff049c6e56cf",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 465515,
              "key": "6ec74538-3295-4fdd-a67c-041b690c9783",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "In this quiz we will create a function that initializes priors (initial belief state for each position on the map) given landmark positions, a position standard deviation (+/- 1.0), and the assumption that our car is parked next to a landmark.\n\nNote that the control standard deviation represents the spread from movement (movement is the result of our control input in this case). We input a control of moving 1 step but our actual movement could be in the range of 1 +/- control standard deviation. The position standard deviation is the spread in our actual position. For example, we may believe start at a particular location, but we could be anywhere in that location +/- our position standard deviation.",
              "instructor_notes": ""
            },
            {
              "id": 465517,
              "key": "ba48e858-2eb5-4ecc-993e-154571064767",
              "title": "",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "user_state": {
                "node_key": "ba48e858-2eb5-4ecc-993e-154571064767",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "instruction": null,
              "question": {
                "title": "",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "4671261679157248",
                "initial_code_files": [
                  {
                    "text": "#include <iostream>\n#include <vector>\n\nusing std::vector;\n\n// initialize priors assuming vehicle at landmark +/- 1.0 meters position stdev\nvector<float> initialize_priors(int map_size, vector<float> landmark_positions,\n                                float position_stdev);\n\nint main() {\n  // set standard deviation of position\n  float position_stdev = 1.0f;\n\n  // set map horizon distance in meters \n  int map_size = 25;\n\n  // initialize landmarks\n  vector<float> landmark_positions {5, 10, 20};\n\n  // initialize priors\n  vector<float> priors = initialize_priors(map_size, landmark_positions,\n                                           position_stdev);\n\n  // print values to stdout \n  for (int p = 0; p < priors.size(); ++p) {\n    std::cout << priors[p] << std::endl;\n  }\n\n  return 0;\n}\n\n// TODO: Complete the initialize_priors function\nvector<float> initialize_priors(int map_size, vector<float> landmark_positions,\n                                float position_stdev) {\n\n  // initialize priors assuming vehicle at landmark +/- 1.0 meters position stdev\n\n  // set all priors to 0.0\n  vector<float> priors(map_size, 0.0);\n    \n  // TODO: YOUR CODE HERE\n\n\n  return priors;\n}",
                    "name": "main.cpp"
                  }
                ]
              },
              "answer": null
            }
          ]
        },
        {
          "id": 465519,
          "key": "4e653fee-d7b1-4519-9f02-2d9dbaa5ddb8",
          "title": "Solution: Initialize Priors Function",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "4e653fee-d7b1-4519-9f02-2d9dbaa5ddb8",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 465520,
              "key": "53f11be7-5fb5-4e83-9b4c-33bdcd3fb1d8",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "There is more than on way to initialize priors, here is one possible approach.",
              "instructor_notes": ""
            },
            {
              "id": 465522,
              "key": "681253d4-9842-4184-90c9-2f6f52ddbaee",
              "title": "",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "For simplicity we assumed a position standard deviation of 1.0 and coded a solution for initializing priors accordingly.  A more robust approach would be to create a function that accepts a position standard deviation as an argument and adjusts initialization and normalization based on its value.  ",
              "user_state": {
                "node_key": "681253d4-9842-4184-90c9-2f6f52ddbaee",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "instruction": null,
              "question": {
                "title": "",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "4764409319260160",
                "initial_code_files": [
                  {
                    "text": "#include <iostream>\n#include <vector>\n\nusing std::vector;\n\n// initialize priors assuming vehicle at landmark +/- 1.0 meters position stdev\nvector<float> initialize_priors(int map_size, vector<float> landmark_positions,\n                                float position_stdev);\n\nint main() {\n  // set standard deviation of position\n  float position_stdev = 1.0f;\n\n  // set map horizon distance in meters \n  int map_size = 25;\n\n  // initialize landmarks\n  vector<float> landmark_positions {5, 10, 20};\n\n  // initialize priors\n  vector<float> priors = initialize_priors(map_size, landmark_positions,\n                                           position_stdev);\n\n  // print values to stdout \n  for (int p = 0; p < priors.size(); ++p) {\n    std::cout << priors[p] << std::endl;\n  }\n\n  return 0;\n}\n\n// TODO: Complete the initialize_priors function\nvector<float> initialize_priors(int map_size, vector<float> landmark_positions,\n                                float position_stdev) {\n\n  // initialize priors assuming vehicle at landmark +/-1.0 meters position stdev\n\n  // set all priors to 0.0\n  vector<float> priors(map_size, 0.0);\n    \n  // TODO: YOUR CODE HERE\n  // set each landmark positon +/-1 to 1.0/9.0 (9 possible postions)\n  float norm_term = landmark_positions.size() * (position_stdev * 2 + 1);\n  for (int i=0; i < landmark_positions.size(); ++i) {\n    for (float j=1; j <= position_stdev; ++j) {\n      priors.at(int(j+landmark_positions[i]+map_size)%map_size) += 1.0/norm_term;\n      priors.at(int(-j+landmark_positions[i]+map_size)%map_size) += 1.0/norm_term;\n    }\n    priors.at(landmark_positions[i]) += 1.0/norm_term;\n  }\n\n  return priors;\n}",
                    "name": "main.cpp"
                  }
                ]
              },
              "answer": null
            }
          ]
        },
        {
          "id": 279144,
          "key": "3cd6a4d8-8c65-47bc-8e07-3c3b1c66af26",
          "title": "Quiz: How Much Data?",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "3cd6a4d8-8c65-47bc-8e07-3c3b1c66af26",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 464117,
              "key": "9b194b41-0f6c-49cc-bb21-29be839f88aa",
              "title": "Quiz: How Much Data",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "wzcFHAf-9lo",
                "china_cdn_id": "wzcFHAf-9lo.mp4"
              }
            },
            {
              "id": 287345,
              "key": "fddd0155-8d34-41fe-b876-c2f56f7dbe90",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Quiz\n\nAbout how much data is in <span class=\"mathquill\">z_{1:t}</span>?",
              "instructor_notes": ""
            },
            {
              "id": 287338,
              "key": "059c815d-26a9-45b6-9a2c-7a9e91885d31",
              "title": "How much data?",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "059c815d-26a9-45b6-9a2c-7a9e91885d31",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "Remember:\n- The car has driven for 6 hours\n- LIDAR refreshes 10 times per seconds (10 Hertz)\n- LIDAR sends 100,000 data points per observation\n- Each of the 100,000 observations contains 5 pieces of data\n- Each piece of data requires 4 bytes\n",
                "answers": [
                  {
                    "id": "a1490234715337",
                    "text": "4 kB",
                    "is_correct": false
                  },
                  {
                    "id": "a1490234724252",
                    "text": "430 kB",
                    "is_correct": false
                  },
                  {
                    "id": "a1490234724893",
                    "text": "4 MB",
                    "is_correct": false
                  },
                  {
                    "id": "a1490234725444",
                    "text": "430 MB",
                    "is_correct": false
                  },
                  {
                    "id": "a1490234727876",
                    "text": "4 GB",
                    "is_correct": false
                  },
                  {
                    "id": "a1490234731764",
                    "text": "430 GB",
                    "is_correct": true
                  }
                ]
              }
            }
          ]
        },
        {
          "id": 279147,
          "key": "e53f0826-31d2-48b7-974c-77d2654b177a",
          "title": "How Much Data: Explanation",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "e53f0826-31d2-48b7-974c-77d2654b177a",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 464118,
              "key": "86296808-1ade-4f2c-9e80-9f037dfbd0b4",
              "title": "03.5 S How Much Data",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "432 billion bytes is actually a little closer to 400 GB if you consider 1,073,741,824 bytes to a GB.",
              "video": {
                "youtube_id": "PQV6gWuyVOs",
                "china_cdn_id": "PQV6gWuyVOs.mp4"
              }
            }
          ]
        },
        {
          "id": 279150,
          "key": "3f96f26d-08b0-478e-8b7f-b989b2bbe42b",
          "title": "Derivation Outline",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "3f96f26d-08b0-478e-8b7f-b989b2bbe42b",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 286305,
              "key": "fdb39137-214a-42d5-95b7-1dcc94693c2a",
              "title": "Derivation Outline",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "coHodx-I56U",
                "china_cdn_id": "coHodx-I56U.mp4"
              }
            }
          ]
        },
        {
          "id": 279177,
          "key": "67ceda64-735e-4b3a-95dd-901f0d5993f5",
          "title": "Apply Bayes Rule with Additional Conditions",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "67ceda64-735e-4b3a-95dd-901f0d5993f5",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 464192,
              "key": "70f8bfd2-3bda-484a-a72f-b4ec7bcac5fd",
              "title": "Apply Bayes Rule With Additional Conditions",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "RsHS2o3zjcw",
                "china_cdn_id": "RsHS2o3zjcw.mp4"
              }
            },
            {
              "id": 384291,
              "key": "f85c0be7-e707-485a-9af7-cca93398f5a5",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/August/59a5cc76_06-l-apply-bayes-rule-with-additional-conditions.00-01-30-28.still002/06-l-apply-bayes-rule-with-additional-conditions.00-01-30-28.still002.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/f85c0be7-e707-485a-9af7-cca93398f5a5",
              "caption": "",
              "alt": null,
              "width": 1920,
              "height": 1080,
              "instructor_notes": null
            },
            {
              "id": 384292,
              "key": "2a93e673-8804-47d1-a574-d31edd12529e",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "We aim to estimate state beliefs <span class=\"mathquill\">bel(x_t)</span> without the need to carry our entire observation history.  We will accomplish this by manipulating our posterior <span class=\"mathquill\">p(x_t|z_{1:t-1},\\mu_{1:t},m)</span>, obtaining a recursive state estimator.  For this to work, we must demonstrate that our current belief <span class=\"mathquill\">bel(x_t)</span> can be expressed by the belief one step earlier <span class=\"mathquill\">bel(x_{t-1})</span>, then use new data to update only the current belief.  This recursive filter is known as the Bayes Localization filter or Markov Localization, and enables us to avoid carrying historical observation and motion data.  We will achieve this recursive state estimator using Bayes Rule, the Law of Total Probability, and the Markov Assumption.\n",
              "instructor_notes": ""
            },
            {
              "id": 384293,
              "key": "82204591-7d85-451b-a9eb-9ccfc6e4834b",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/August/59a5cd41_06-l-apply-bayes-rule-with-additional-conditions.00-01-48-09.still003/06-l-apply-bayes-rule-with-additional-conditions.00-01-48-09.still003.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/82204591-7d85-451b-a9eb-9ccfc6e4834b",
              "caption": "",
              "alt": null,
              "width": 1920,
              "height": 1080,
              "instructor_notes": null
            },
            {
              "id": 384294,
              "key": "76d6c779-a6e5-4188-a2d9-03e7d762e864",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "We take the first step towards our recursive structure by splitting our observation vector <span class=\"mathquill\"> z_{1:t} </span> into current observations <span class=\"mathquill\">z_t</span>  and previous information <span class=\"mathquill\">z_{1:t-1}</span>.  The posterior can then be rewritten as <span class=\"mathquill\">p(x_t|z_t,z_{1:t-1},u_{1:t}, m) </span>.\n",
              "instructor_notes": ""
            },
            {
              "id": 384295,
              "key": "eae242d6-9261-4201-857c-49d0f78e3787",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/August/59a5cdb3_06-l-apply-bayes-rule-with-additional-conditions.00-02-12-10.still004/06-l-apply-bayes-rule-with-additional-conditions.00-02-12-10.still004.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/eae242d6-9261-4201-857c-49d0f78e3787",
              "caption": "",
              "alt": null,
              "width": 1920,
              "height": 1080,
              "instructor_notes": null
            },
            {
              "id": 384297,
              "key": "3189b98b-bea8-4652-ab2e-0b0268caa38f",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Now, we apply Bayes' rule, with an additional challenge, the presence of multiple distributions on the right side (likelihood, prior, normalizing constant).  How can we best handle multiple conditions within Bayes Rule?  As a hint, we can use substitution, where <span class=\"mathquill\"> x_t </span> is a, and the observation vector at time t, is b.  Don’t forget to include <span class=\"mathquill\"> u </span> and <span class=\"mathquill\"> m </span> as well.\n\n### Bayes Rule\n<div class=\"mathquill\">P(a \\mid b) = \\frac{P(b \\mid a) \\, P(a)}{P(b)}</div>",
              "instructor_notes": ""
            },
            {
              "id": 287648,
              "key": "3cfc6f69-695e-41b6-8346-7fa0880178bb",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Quiz\n\nPlease apply Bayes Rule to determine the right side of Bayes rule, where the posterior, <span class=\"mathquill\">P(a|b)</span>, is <span class=\"mathquill\">p(x_t|z_t,z_{1:t-1},u_{1:t},m)</span>\n\n(A) <div class=\"mathquill\">\\frac{p(x_t|z_t,z_{1:t-1},u_{1:t},m)p(z_t|x_t,z_{1:t-1},u_{1:t},m)}{p(z_t|z_{1:t-1},u_{1:t},m)}</div>\n\n(B) <div class=\"mathquill\">\\frac{p(z_t|x_t,z_{1:t-1},u_{1:t},m)p(x_t|z_{1:t-1},u_{1:t},m)}{p(z_t|z_{1:t-1},u_{1:t},m)}</div>\n\n(C) <div class=\"mathquill\">\n\\frac{p(z_t|x_t,z_{1:t-1},u_{1:t},m)p(x_t|z_{1:t-1},u_{1:t},m)}{p(x_t|z_{1:t-1},u_{1:t},m)}</div>\n",
              "instructor_notes": ""
            },
            {
              "id": 287339,
              "key": "8d606a1d-d4a9-4999-a96b-01faad8e099c",
              "title": "Apply Bayes Rules with Additional Conditions",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "8d606a1d-d4a9-4999-a96b-01faad8e099c",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "Choose the correct answer:",
                "answers": [
                  {
                    "id": "a1490237017776",
                    "text": "A",
                    "is_correct": false
                  },
                  {
                    "id": "a1490237079673",
                    "text": "B",
                    "is_correct": true
                  },
                  {
                    "id": "a1490338690899",
                    "text": "C",
                    "is_correct": false
                  }
                ]
              }
            }
          ]
        },
        {
          "id": 279154,
          "key": "d56d2238-9528-46c8-b1e1-ad086a73f3bb",
          "title": "Bayes Rule and Law of Total Probability",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "d56d2238-9528-46c8-b1e1-ad086a73f3bb",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 464119,
              "key": "18683aa9-1d92-458f-9978-19e86ef94e4f",
              "title": "Explain Bayes Rule And Apply Law Of Total Probability",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "p2qfHa9G7_k",
                "china_cdn_id": "p2qfHa9G7_k.mp4"
              }
            }
          ]
        },
        {
          "id": 279156,
          "key": "932c99ae-83f3-4db2-b603-1e793f1c9813",
          "title": "Total Probability and Markov Assumption",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "932c99ae-83f3-4db2-b603-1e793f1c9813",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 464120,
              "key": "2052434f-593c-4557-9716-1afee9d23e20",
              "title": "Explain Law Of Total Probability And Markov Assumption",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "9hGU7s5m8c0",
                "china_cdn_id": "9hGU7s5m8c0.mp4"
              }
            },
            {
              "id": 380549,
              "key": "1be0ce06-9a5f-4dbb-8a00-6a0f657175c1",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Law of Total Probability\n\n<div class=\"mathquill\">P(B) = \\sum\\limits_{i-1}^{\\infty} P(B|A_i)P(A_i)</div>\n",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 279157,
          "key": "13494154-a27e-4fcd-a760-0fdcf3c24faf",
          "title": "Markov Assumption for Motion Model: Quiz",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "13494154-a27e-4fcd-a760-0fdcf3c24faf",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 287669,
              "key": "6817eaec-07ef-4540-968b-6f9c41d72704",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Markov Assumption for Motion Model Quiz",
              "instructor_notes": ""
            },
            {
              "id": 287664,
              "key": "68163998-64e1-44dd-b67d-7370fcfb3477",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "What do you think about these two assumptions:\n\n(a) Since we (hypothetically) know in which state the system is at time step t-1, the past observations <span class=\"mathquill\">z_{1:t-1}</span> and controls  <span class=\"mathquill\">u_{1:t-1}</span> would not provide us additional information to estimate the posterior for <span class=\"mathquill\">x_t</span>, because they were already used to estimate  <span class=\"mathquill\">x_{t-1}</span>. This means, we can simplify <span class=\"mathquill\">p(x_t|x_{t-1}, z_{1:t-1}, u_{1:t},m)</span> to  <span class=\"mathquill\">p(x_t|x_{t-1}, u_t, m)</span>.\n\n(b) Since  <span class=\"mathquill\">u_t</span> is “in the future” with reference to <span class=\"mathquill\">x_{t-1}, u_t</span> does not tell us much about <span class=\"mathquill\">x_{t-1}</span>. This means the term <span class=\"mathquill\">p(x_{t-1}|z_{1:t-1}, u_{1:t}, m)</span> can be simplified to <span class=\"mathquill\">p(x_{t-1}|z_{1:t-1}, u_{1:t-1}, m)</span> .\n",
              "instructor_notes": ""
            },
            {
              "id": 287668,
              "key": "c2adde4e-cefe-4151-899d-381f23a2861d",
              "title": "Markov Assumptions for Motion",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "c2adde4e-cefe-4151-899d-381f23a2861d",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "What do you think about the two assumptions?",
                "answers": [
                  {
                    "id": "a1490339634860",
                    "text": "Only assumption (a) is meaningful",
                    "is_correct": false
                  },
                  {
                    "id": "a1490339686207",
                    "text": "Both assumptions are not meaningful",
                    "is_correct": false
                  },
                  {
                    "id": "a1490339687126",
                    "text": "Only assumption (b) is meaningful",
                    "is_correct": false
                  },
                  {
                    "id": "a1490339702797",
                    "text": "Both assumptions are meaningful",
                    "is_correct": true
                  }
                ]
              }
            }
          ]
        },
        {
          "id": 279158,
          "key": "c12ca8a6-10d4-4f34-bcf6-6894fd9ceba2",
          "title": "Markov Assumption for Motion Model: Explanation",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "c12ca8a6-10d4-4f34-bcf6-6894fd9ceba2",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 464194,
              "key": "7bdb8324-e337-413c-b5bf-520e8e84bac8",
              "title": "Explain Markov Assumption For Motion Model",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "YFLAFptKU5E",
                "china_cdn_id": "YFLAFptKU5E.mp4"
              }
            },
            {
              "id": 383918,
              "key": "fb3355f7-7b67-4af8-943d-e0c50c514a7a",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Markov Assumption\n\nA Markov process is one in which the conditional probability distribution of future states (ie the next state) is dependent only upon\nthe current state and not on other preceding states.  This can be expressed mathematically as:\n\n<div class=\"mathquill\">\nP(x_t|x_{1-t},....,x_{t-i},...., x_0) = P(x_t|x_{t-1})\n</div>\n\nIt is important to note that the current state may contain all information from preceding states. That is the case discussed in this lesson.\n",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 279159,
          "key": "081af219-6a95-40ac-b97b-081462000eea",
          "title": "After Applying Markov Assumption: Quiz",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "081af219-6a95-40ac-b97b-081462000eea",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 287670,
              "key": "69883217-6094-4f8a-b544-b289847a85cf",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### After Applying Markov Assumption Quiz",
              "instructor_notes": ""
            },
            {
              "id": 288149,
              "key": "bfac7950-560c-45e6-a099-0fffbd4e3c45",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "**Statement 1**\n\nAfter applying the Markov Assumption, the term <span class=\"mathquill\">p(x_{t-1} | z_{1:t-1}, u_{1:t-1}, m)</span>  describes exactly the belief at <span class=\"mathquill\">x_{t-1}</span> ! This means we achieved a recursive structure! \n\n**Statement 2**\n\nAfter applying the Markov Assumption, we can neglect the term <span class=\"mathquill\">p(x_{t-1} | z_{1:t-1}, u_{1:t-1}, m)</span> completely and we only have to estimate the posterior.\n",
              "instructor_notes": ""
            },
            {
              "id": 287672,
              "key": "53aa9588-b17c-4579-b640-59c61ac23f76",
              "title": "After Applying Markov Assumption",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "53aa9588-b17c-4579-b640-59c61ac23f76",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "Which statement is correct? ",
                "answers": [
                  {
                    "id": "a1490339877163",
                    "text": "Statement 1",
                    "is_correct": true
                  },
                  {
                    "id": "a1490339899158",
                    "text": "Statement 2",
                    "is_correct": false
                  }
                ]
              }
            }
          ]
        },
        {
          "id": 279161,
          "key": "530a769e-637e-40ce-ab73-ad5293a24d88",
          "title": "Recursive Structure",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "530a769e-637e-40ce-ab73-ad5293a24d88",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 464193,
              "key": "2264da16-7299-4a6b-9c55-730c5f7fa9f1",
              "title": "Explain Recursive Structure",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "d0GrWJeVFjU",
                "china_cdn_id": "d0GrWJeVFjU.mp4"
              }
            },
            {
              "id": 385935,
              "key": "b72204b5-1ea1-4c60-b6ec-4ff56f7564c2",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/September/59a9d33b_14-l-explain-recursive-structure-.00-00-34-00.still001/14-l-explain-recursive-structure-.00-00-34-00.still001.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/b72204b5-1ea1-4c60-b6ec-4ff56f7564c2",
              "caption": "",
              "alt": null,
              "width": 1920,
              "height": 1080,
              "instructor_notes": null
            },
            {
              "id": 385940,
              "key": "d00fba84-e1aa-4de7-9955-76c9dcf115ae",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "We have achieved a very important step towards the final form of our recursive state estimator.  Let’s see why.  If we rewrite the second term in our integral to split <span class=\"mathquill\">z_{1-t}</span> to <span class=\"mathquill\">z_{t-1}</span> and <span class=\"mathquill\">z_{t-2}</span> we arrive at a function that is exactly the belief from the previous time step, namely <span class=\"mathquill\">bel(x_{t-1})</span>. \n",
              "instructor_notes": ""
            },
            {
              "id": 385936,
              "key": "cda9ba48-9fd1-4114-9860-9a682445ea3e",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/September/59a9d34d_14-l-explain-recursive-structure-.00-00-38-09.still002/14-l-explain-recursive-structure-.00-00-38-09.still002.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/cda9ba48-9fd1-4114-9860-9a682445ea3e",
              "caption": "",
              "alt": null,
              "width": 1920,
              "height": 1080,
              "instructor_notes": null
            },
            {
              "id": 385942,
              "key": "930a648f-c073-41a7-9cc8-79122922a9af",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Now we can rewrite out integral as the belief of <span class=\"mathquill\"> x_{t-1}</span>.",
              "instructor_notes": ""
            },
            {
              "id": 385937,
              "key": "e57bfe7e-30d5-4020-a026-9f5b43537858",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/September/59a9d35f_14-l-explain-recursive-structure-.00-01-05-00.still003/14-l-explain-recursive-structure-.00-01-05-00.still003.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/e57bfe7e-30d5-4020-a026-9f5b43537858",
              "caption": "",
              "alt": null,
              "width": 1920,
              "height": 1080,
              "instructor_notes": null
            },
            {
              "id": 385943,
              "key": "c9885d5a-959f-42b7-951a-7f9436086385",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "The amazing thing is that we have a recursive update formula and can now use the estimated state from the previous time step to predict the current state at t. This is a critical step in a recursive Bayesian filter because it renders us independent from the entire observation and control history. So in the graph structure, we will replace the previous state terms (highlighted) with our belief of the state at <span class=\"mathquill\">x</span> at <span class=\"mathquill\">t-1</span> (next image).",
              "instructor_notes": ""
            },
            {
              "id": 385938,
              "key": "fff86d6c-8544-4101-a147-64969610daa2",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/September/59a9d373_14-l-explain-recursive-structure-.00-01-55-15.still004/14-l-explain-recursive-structure-.00-01-55-15.still004.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/fff86d6c-8544-4101-a147-64969610daa2",
              "caption": "",
              "alt": null,
              "width": 1920,
              "height": 1080,
              "instructor_notes": null
            },
            {
              "id": 385944,
              "key": "500d9da6-2ccd-4ed1-92d1-a822aad8aacd",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Finally, we replace the integral by a sum over all <span class=\"mathquill\">x_i</span> because we have a discrete localization scenario in this case, to get the same formula in Sebastian's lesson for localization. The process of predicting <span class=\"mathquill\">x_t</span> with a previous beliefs (<span class=\"mathquill\">x_{t-1}</span>) and the transition model is technically a convolution.  If you take a look to the formula again, it is essential that the belief at <span class=\"mathquill\">x_t = 0</span> is initialized with a meaningful assumption. It depends on the localization scenario how you set the belief or in other words, how you initialize your filter.  For example, you can use GPS to get a coarse estimate of your location.",
              "instructor_notes": ""
            },
            {
              "id": 385939,
              "key": "ab02c109-33cb-4b86-b2cf-ae2c93053f25",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/September/59a9d38f_14-l-explain-recursive-structure-.00-02-36-09.still005/14-l-explain-recursive-structure-.00-02-36-09.still005.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/ab02c109-33cb-4b86-b2cf-ae2c93053f25",
              "caption": "",
              "alt": null,
              "width": 1920,
              "height": 1080,
              "instructor_notes": null
            }
          ]
        },
        {
          "id": 650329,
          "key": "7720581d-54e5-40f6-a08b-ec3b005bb4c6",
          "title": "Lesson Breakpoint",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "7720581d-54e5-40f6-a08b-ec3b005bb4c6",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 650330,
              "key": "0c43a85e-a406-4983-8d4d-d86954498143",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Lesson Breakpoint",
              "instructor_notes": ""
            },
            {
              "id": 650334,
              "key": "9018c680-6b78-4cee-86ba-dddb04265307",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/September/59a9d38f_14-l-explain-recursive-structure-.00-02-36-09.still005/14-l-explain-recursive-structure-.00-02-36-09.still005.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/9018c680-6b78-4cee-86ba-dddb04265307",
              "caption": "",
              "alt": "",
              "width": 1920,
              "height": 1080,
              "instructor_notes": null
            },
            {
              "id": 650333,
              "key": "7f67b8a0-1e31-4bad-a69c-0b6edb6c868f",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Awesome work! Summing up, here is what we have learned so far:\n\n- How to apply the law of total probability by including the new variable <span class=\"mathquill\">x_{t-1}</span>.\n- The Markov assumption, which is very important for probabilistic reasoning, and allows us to make recursive state estimation without carrying our entire history of information\n- How to derive the recursive filter structure.\n\nThis is a lesson breakpoint, as it's a good place to pause if you're trying to decide how to tackle this longer lesson. While you'll still use the earlier concepts later on, we'll next be implementing a motion model in C++ and learning how to initialize our localizer.\n\nWhether it's a ten minute break to absorb all the information so far, or coming back tomorrow for more, we'll look forward to seeing you back in the classroom!",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 279162,
          "key": "5bea5fef-4076-4c0c-b837-396755773a12",
          "title": "Implementation Details for Motion Model",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "5bea5fef-4076-4c0c-b837-396755773a12",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 464124,
              "key": "fed44f32-a2df-4907-a4b0-19d42f0dfa86",
              "title": "Implementation Details For Motion Model",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "O47bOcJm1eE",
                "china_cdn_id": "O47bOcJm1eE.mp4"
              }
            }
          ]
        },
        {
          "id": 279163,
          "key": "ad50b128-34f3-46e6-bc47-5ac0e170711b",
          "title": "Noise in Motion Model: Quiz",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "ad50b128-34f3-46e6-bc47-5ac0e170711b",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 286316,
              "key": "5bfcd057-7845-4c9e-b337-6328aef705d6",
              "title": "ND013 M4 L3 15.5 Q Noise In Motion Model",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "zRbT36RTlhs",
                "china_cdn_id": "zRbT36RTlhs.mp4"
              }
            },
            {
              "id": 291743,
              "key": "0629c197-e8b2-44a6-93c1-f9878c21f3a7",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Here is a screenshot of the quiz for reference:",
              "instructor_notes": ""
            },
            {
              "id": 291742,
              "key": "058d4f79-6a54-4784-b69a-0198ae5f0562",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/April/58e7e3f0_screen-shot-2017-04-07-at-12.08.14-pm/screen-shot-2017-04-07-at-12.08.14-pm.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/058d4f79-6a54-4784-b69a-0198ae5f0562",
              "caption": "quiz screenshot ",
              "alt": null,
              "width": 780,
              "height": 369,
              "instructor_notes": null
            },
            {
              "id": 287674,
              "key": "c2239a3f-baf3-4dba-aeda-9b25d3355eb0",
              "title": "Noise in Motion Model",
              "semantic_type": "MatchingQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "c2239a3f-baf3-4dba-aeda-9b25d3355eb0",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "complex_prompt": {
                  "text": "What would happen in each case?"
                },
                "concepts_label": "Robot Motion",
                "answers_label": "Result",
                "concepts": [
                  {
                    "text": "Moves forward 10m with high noise",
                    "correct_answer": {
                      "id": "a1490340242181",
                      "text": "A"
                    }
                  },
                  {
                    "text": "Moves forward 10m with low noise",
                    "correct_answer": {
                      "id": "a1490340278432",
                      "text": "B"
                    }
                  },
                  {
                    "text": "Moves forward 10m with no noise",
                    "correct_answer": {
                      "id": "a1490340330534",
                      "text": "C"
                    }
                  }
                ],
                "answers": [
                  {
                    "id": "a1490340278432",
                    "text": "B"
                  },
                  {
                    "id": "a1490340330534",
                    "text": "C"
                  },
                  {
                    "id": "a1490340242181",
                    "text": "A"
                  },
                  {
                    "id": "a1490340284576",
                    "text": "D"
                  }
                ]
              }
            }
          ]
        },
        {
          "id": 286321,
          "key": "1566467b-c434-475b-97c2-36422dd04caf",
          "title": "Noise in Motion Model: Solution",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "1566467b-c434-475b-97c2-36422dd04caf",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 286322,
              "key": "8f511565-cb5b-46db-8d26-5697ece7c31c",
              "title": "Noise In Motion Model Solution",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "zJ9NWz7IlOM",
                "china_cdn_id": "zJ9NWz7IlOM.mp4"
              }
            }
          ]
        },
        {
          "id": 461351,
          "key": "709ea190-3a07-4c64-892e-1c496e7a7d99",
          "title": "Determine Probabilities",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "709ea190-3a07-4c64-892e-1c496e7a7d99",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 461357,
              "key": "2960765e-21a7-4cf9-ac16-43dbb77e124f",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "To implement these models in code, we need a function to which we can pass model parameters/values and return a probability.  Fortunately, we can use a normalized probability density function (PDF).  Let's revisit Sebastian's discussion of this topic.\n",
              "instructor_notes": ""
            },
            {
              "id": 833522,
              "key": "9c767de2-ca97-4886-a8a3-9518bf15783f",
              "title": "Gaussian Intro",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "6IhtnM1e0IY",
                "china_cdn_id": "6IhtnM1e0IY.mp4"
              }
            },
            {
              "id": 463179,
              "key": "c9a2ad0d-4307-4fe9-ab73-f5839e24ef7a",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "We have implemented this Gaussian Distribution as a C++ function, ```normpdf```, and will practice using it at the end of this concept.  ```normpdf``` accepts a value, a parameter, and a standard deviation, returning a probability.  \n\n## Additional Resources for Gaussian Distributions\n- [Udacity's Statistics Course content on PDF](https://classroom.udacity.com/courses/st095/lessons/86217921/concepts/1020887710923)\n- http://mathworld.wolfram.com/NormalDistribution.html\n- http://stattrek.com/statistics/dictionary.aspx?definition=Probability_density_function",
              "instructor_notes": ""
            },
            {
              "id": 461500,
              "key": "574b35c9-8f19-4ef6-b394-1c07df04487c",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Let's practice using ```normpdf``` to determine transition model probabilities.  Specifically, we need to determine the probability of moving from <span class=\"mathquill\">x_{t-1}</span> --> <span class=\"mathquill\">x_t</span>.  The value entered into ```normpdf``` will be the distance between these two positions.  We will refer to potential values of these positions as pseudo position and pre-pseudo position.  For example, if our pseudo position x is 8 and our pre-pseudo position is 5, our sample value will be 3, and our transition will be from x - 3 --> x.  \n\nTo calculate our transition model probability, pass any difference in distances into ```normpdf``` using our control parameter and position standard deviation.  \n\n  ",
              "instructor_notes": ""
            },
            {
              "id": 461397,
              "key": "77f1f28c-3e7f-413c-a867-0fe735c602b9",
              "title": "Maximize Gaussian",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "77f1f28c-3e7f-413c-a867-0fe735c602b9",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": " Given pseudo position x and a control parameter of 1 (move 1 unit each time step), which pre-pseudo position maximizes our probability?",
                "answers": [
                  {
                    "id": "a1510599231139",
                    "text": "x-4",
                    "is_correct": false
                  },
                  {
                    "id": "a1510599368937",
                    "text": "x-2",
                    "is_correct": false
                  },
                  {
                    "id": "a1510599373116",
                    "text": "x-3",
                    "is_correct": false
                  },
                  {
                    "id": "a1510599377767",
                    "text": "x-1",
                    "is_correct": true
                  }
                ]
              }
            },
            {
              "id": 461358,
              "key": "6ad47938-dcc2-47b1-a30c-03d7b318b1f7",
              "title": "",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "user_state": {
                "node_key": "6ad47938-dcc2-47b1-a30c-03d7b318b1f7",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "instruction": null,
              "question": {
                "title": "Experiment with norm_pdf",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "5695221627748352",
                "initial_code_files": [
                  {
                    "text": "#include <iostream>\n#include \"help_functions.h\"\n\n// TODO: assign a value, the difference in distances between x_t and x_{t-1}\n// that maximizes the returned probability of norm_pdf\n\nfloat value = ?;  // YOUR VALUE HERE\n\n\nfloat parameter = 1.0;  // set as control parameter or observation measurement\nfloat stdev = 1.0;  // position or observation standard deviation\n\nint main() {\n\n  float prob = Helpers::normpdf(value, parameter, stdev);\n\n  std::cout << prob << std::endl;\n\n  return 0;\n}",
                    "name": "main.cpp"
                  },
                  {
                    "text": "#ifndef HELP_FUNCTIONS_H\n#define HELP_FUNCTIONS_H\n\n#include <math.h>\n\nclass Helpers {\n public:\n  // definition of one over square root of 2*pi:\n  constexpr static float STATIC_ONE_OVER_SQRT_2PI = 1/sqrt(2*M_PI);\n\n  /**\n   * normpdf(X,mu,sigma) computes the probability function at values x using the\n   * normal distribution with mean mu and standard deviation std. x, mu and \n   * sigma must be scalar! The parameter std must be positive. \n   * The normal pdf is y=f(x,mu,std)= 1/(std*sqrt(2pi)) e[ -(x−mu)^2 / 2*std^2 ]\n   */\n  static float normpdf(float x, float mu, float std) {\n    return (STATIC_ONE_OVER_SQRT_2PI/std)*exp(-0.5*pow((x-mu)/std,2));\n  }\n};\n\n#endif  // HELP_FUNCTIONS_H",
                    "name": "help_functions.h"
                  }
                ]
              },
              "answer": null
            }
          ]
        },
        {
          "id": 463187,
          "key": "1828ac28-5d2d-4bff-87c7-4a1088cdb8e3",
          "title": "Motion Model Probabiity I",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "1828ac28-5d2d-4bff-87c7-4a1088cdb8e3",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 463188,
              "key": "80cccf95-65f1-4232-8c91-0e82f2c8e616",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Now we will practice implementing the motion model to determine P(location) for our Bayesian filter.   We discussed the derivation of the model in **Recursive Structure\n** and **Implementation Details for Motion Model**.\n\nRecall that we derived the following recursive structure for the motion model:\n\n<div class=\"mathquill\">\\int p(x_t|x_{t-1}, u_t, m)bel(x_{t-1})dx_{t-1}</div>\n\nand that we will implement this in the discretized form:\n\n<div class=\"mathquill\">\\sum\\limits_{i} p(x_t|x_{t-1}^{(i)}, u_t, m)bel(x_{t-1}^{(i)})</div>\n\n\n\n\n\n",
              "instructor_notes": ""
            },
            {
              "id": 463189,
              "key": "63067411-991b-4cd7-966b-3fb6945ee333",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Let's consider again what the summation above is doing - calculating the probability that the vehicle is now at a given location, <span class=\"mathquill\"> x_t</span>.\n\nHow is the summation doing that? It's looking at each prior location where the vehicle could have been, <span class=\"mathquill\">x_{t-1}</span>. Then the summation iterates over every possible prior location, <span class=\"mathquill\">x_{t-1}^{(1)}...x_{t-1}^{(n)}</span>. For each possible prior location in that list, <span class=\"mathquill\">x_{t-1}^{(i)}</span>, the summation yields the **total probability** that the vehicle really did start at that prior location __and__ that it wound up at  <span class=\"mathquill\"> x_t</span>.\n\nThat now raises the question, how do we calculate the individual probability that the vehicle really did start at that prior location __and__ that it wound up at  <span class=\"mathquill\"> x_t</span>, for each possible starting position  <span class=\"mathquill\"> x_{t-1}</span>?\n\nThat's where each individual element of the summation contributes. The likelihood of starting at <span class=\"mathquill\">x_{t-1}</span> and arriving at <span class=\"mathquill\">x_{t}</span> is simply \n<span class=\"mathquill\">p(x_t|x_{t-1}) * p(x_{t-1})</span>.\n\nWe can say the same thing, using different notation and incorporating all of our knowledge about the world, by writing: <span class=\"mathquill\">p(x_t|x_{t-1}^{(i)}, u_t, m) * bel(x_{t-1}^{(i)})</span>\n\nFrom the equation above we can see that our final position probability is the sum of n discretized motion model calculations, where each calculation is the product of the 'i'th transition probability, <span class=\"mathquill\"> p(x_t|x_{t-1}^{(i)}, u_t, m)</span>,\n and 'i'th belief state, <span class=\"mathquill\">bel(x_{t-1}^{(i)})</span>.  Let's try out a single, discreet calculation.  \n\n'**i**'**th Motion Model Probability:**\n\n<div class=\"mathquill\">p(x_t|x_{t-1}^{(i)}, u_t, m) * bel(x_{t-1}^{(i)})</div>\n",
              "instructor_notes": ""
            },
            {
              "id": 463190,
              "key": "5ab240bb-ce0d-41a5-93a1-73abc9556bf6",
              "title": "Discretized Motional Model Calculation",
              "semantic_type": "ValidatedQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "5ab240bb-ce0d-41a5-93a1-73abc9556bf6",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "Given a transition probability of 3.99E-1 and a belief state <span class=\"mathquill\">bel(x_{t-1})</span> of 5.56E-2, what is the position probability returned by the motion model?  Write the answer in scientific notation with an accuracy of two decimal places, for example 3.14E-15.",
                "matchers": [
                  {
                    "expression": "2.2[0-4]E-(0|)2"
                  }
                ]
              }
            },
            {
              "id": 797567,
              "key": "d3667886-8db1-452f-885e-a48689410a34",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "<div id=\"spoiler_1\" style=\"display:none\">\n**2.22E-2** - remember to enter two decimal places!\n</div>\n<button title=\"Click to show/hide content\" type=\"button\" onclick=\"if(document.getElementById('spoiler_1') .style.display=='none') {document.getElementById('spoiler_1') .style.display=''}else{document.getElementById('spoiler_1') .style.display='none'}\">Show Solution</button>",
              "instructor_notes": ""
            },
            {
              "id": 463191,
              "key": "cfe5c889-d771-4078-b469-d6611186ab50",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "In the next concept, we will practice determining other values relevant to the motion model.",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 461353,
          "key": "32a93bdf-034c-4987-b4cd-18a40d2c680e",
          "title": "Motion Model Probability II",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "32a93bdf-034c-4987-b4cd-18a40d2c680e",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 461513,
              "key": "7a915668-354f-4b0b-90d6-9afa4fd9ca96",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "| pseudo_position (x) | pre-pseudo_position | delta position | P(transition) | <span class=\"mathquill\">bel(x_{t-1})</span> | P(position) |\n|:------------:|:---------------:|:--------------:|:-------------:|:--------:|:-----------:|\n|       7      |        1        |        6       |    1.49E-06   | 5.56E-02 |   8.27E-08  |\n|       7      |        2        |        5       |    1.34E-04   | 5.56E-02 |   7.44E-06  |\n|       7      |        3        |        4       |    4.43E-03   | 5.56E-02 |   2.46E-04  |\n|       7      |        4        |        ?       |    5.40E-02   | 0.00E+00 |   0.00E+00  |\n|       7      |        5        |        2       |    ?   | 0.00E+00 |   0.00E+00  |\n|       7      |        6        |        1       |    3.99E-01   | 0.00E+00 |   0.00E+00  |\n|       7      |        7        |        0       |    2.42E-01   | ? |   1.66E-03  |\n|       7      |        8        |       -1       |    5.40E-02   | 1.79E-03 |   ?  |",
              "instructor_notes": ""
            },
            {
              "id": 462394,
              "key": "31e602e7-437d-4853-be1d-abf1a1a96c5b",
              "title": "Delta Position",
              "semantic_type": "ValidatedQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "31e602e7-437d-4853-be1d-abf1a1a96c5b",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "What is difference in position for an x of 7 and a pre-pseudo position of 4? ",
                "matchers": [
                  {
                    "expression": "3"
                  }
                ]
              }
            },
            {
              "id": 465938,
              "key": "0ee487dc-119a-418d-adb4-618491cc7fea",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "<div id=\"spoiler\" style=\"display:none\">\npseudo_position - pre-pseudo_position = **7 - 4 = 3**\n</div>\n<button title=\"Click to show/hide content\" type=\"button\" onclick=\"if(document.getElementById('spoiler') .style.display=='none') {document.getElementById('spoiler') .style.display=''}else{document.getElementById('spoiler') .style.display='none'}\">Show Solution</button>",
              "instructor_notes": ""
            },
            {
              "id": 462396,
              "key": "b548c036-7867-4798-af51-cebe86154acd",
              "title": "Transition Probability ",
              "semantic_type": "ValidatedQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "b548c036-7867-4798-af51-cebe86154acd",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "Use ```normpdf``` (bottom of page) to determine the transition probability for x = 7 and a pre-pseudo_position of 5, and a control parameter of 1, and a standard deviation of 1.  The transition probability can be determined through ```normpdf(delta_position, control_parameter, position_stdev)```.  The answer must be in scientific notation with two decimal place accuracy, for example 3.14E-15.  \n",
                "matchers": [
                  {
                    "expression": "2.4[0-4]E-(0|)1"
                  }
                ]
              }
            },
            {
              "id": 465939,
              "key": "ef0e2674-6a45-43a5-a8e3-81b8902c01d7",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "<div id=\"spoiler_1\" style=\"display:none\">\n```\n#include <iostream>\n#include \"help_functions.h\"\n\n//Assign 2 to the value term\n//This is 7 - 5 = 2\nfloat value = 2;\n\nfloat parameter = 1.0; //set as control parameter or observation measurement\nfloat stdev = 1.0; //position or observation standard deviation\n\nint main() {\n\n    float prob = Helpers::normpdf(value, parameter, stdev);\n\n    std::cout << prob << endl;\n\n    return 0;\n}\n```\n\n</div>\n<button title=\"Click to show/hide content\" type=\"button\" onclick=\"if(document.getElementById('spoiler_1') .style.display=='none') {document.getElementById('spoiler_1') .style.display=''}else{document.getElementById('spoiler') .style.display='none'}\">Show Solution</button>",
              "instructor_notes": ""
            },
            {
              "id": 462398,
              "key": "e0770b32-6d2d-4d30-be60-ee13eb0f14f9",
              "title": "Determine the belief state",
              "semantic_type": "ValidatedQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "e0770b32-6d2d-4d30-be60-ee13eb0f14f9",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "In practice we only set our initial belief state, but making the following calculation is helpful in building intuition.  What is the belief state <span class=\"mathquill\">bel(x_{t-1})</span> for the penultimate row of our table above? Write the answer in scientific notation with an accuracy of two decimal places, for example 3.14E-15.",
                "matchers": [
                  {
                    "expression": "6.8[5-9]E-(0|)3"
                  }
                ]
              }
            },
            {
              "id": 465952,
              "key": "60a79c9a-6ded-49a3-804a-d53757c351f5",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "<div id=\"spoiler_8\" style=\"display:none\">\nOur positon probability is the product of the transition probability and our belief state at t - 1.  Rearranging yields:\n\n**1.66E-03/2.42E-01 = 6.86E-03**\n\n</div>\n<button title=\"Click to show/hide content\" type=\"button\" onclick=\"if(document.getElementById('spoiler_8') .style.display=='none') {document.getElementById('spoiler_8') .style.display=''}else{document.getElementById('spoiler_8') .style.display='none'}\">Show Solution</button>",
              "instructor_notes": ""
            },
            {
              "id": 462401,
              "key": "b5175cd0-c93d-4fb9-ab31-0ff4e0d005e6",
              "title": "Position Probability",
              "semantic_type": "ValidatedQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "b5175cd0-c93d-4fb9-ab31-0ff4e0d005e6",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "What is the discretized position probability for x = 7 and a pre-pseudo_position of 8, given the belief state in the table above?  Write the answer in scientific notation with an accuracy of two decimal places, for example 3.14E-15.",
                "matchers": [
                  {
                    "expression": "9.6[4-8]E-(0|)5"
                  }
                ]
              }
            },
            {
              "id": 465941,
              "key": "e14ec27d-d29f-4046-a672-64355e6a0848",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "<div id=\"spoiler_9\" style=\"display:none\">\nOur positon probability is the product of the transition probability and our belief state for our pre-pseudo position.\n\n**5.40E-02 * 1.79E-03 = 9.66E-05**\n\n</div>\n<button title=\"Click to show/hide content\" type=\"button\" onclick=\"if(document.getElementById('spoiler_9') .style.display=='none') {document.getElementById('spoiler_9') .style.display=''}else{document.getElementById('spoiler_9') .style.display='none'}\">Show Solution</button>",
              "instructor_notes": ""
            },
            {
              "id": 463183,
              "key": "f7e8a3df-6e75-4b4c-849a-9cdcbfd5d606",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "We have completed our table of discretized calculation for each <span class=\"mathquill\">i</span>th positon probability value. To determine the final probability returned by the motion model, we must sum the probabilities.\n",
              "instructor_notes": ""
            },
            {
              "id": 462403,
              "key": "80a55ffa-66db-4ffa-aca3-766dee32534b",
              "title": "Aggregating Discretized P(position)",
              "semantic_type": "ValidatedQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "80a55ffa-66db-4ffa-aca3-766dee32534b",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "Given the table above, what is the final probability returned by our motion model.  Enter the answer in scientific notation with an accuracy of two decimal places, for example 3.14E-15.",
                "matchers": [
                  {
                    "expression": "2.0[0-4]E-(0|)3"
                  }
                ]
              }
            },
            {
              "id": 465942,
              "key": "20d304f1-674c-4602-8757-e021830a4ca2",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "<div id=\"spoiler_10\" style=\"display:none\">\nBy summing the discrete probabilities from the table, we obtain the total probability, which estimates the probability from a continuous function.\n\n8.27E-08 + 7.44E-06 + 2.46E-04 + 0.00E+00 + 0.00E+00 + 0.00E+00 + 1.66E-03 + 9.66E-05 = 2.02E-03\n\n\n</div>\n<button title=\"Click to show/hide content\" type=\"button\" onclick=\"if(document.getElementById('spoiler_10') .style.display=='none') {document.getElementById('spoiler_10') .style.display=''}else{document.getElementById('spoiler_10') .style.display='none'}\">Show Solution</button>",
              "instructor_notes": ""
            },
            {
              "id": 640594,
              "key": "2bc02c1c-0944-453b-a45f-f766295c4b8c",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Recall that the transition probability can be determined through ```norm_pdf(delta_position, control_parameter, position_stdev)```",
              "instructor_notes": ""
            },
            {
              "id": 463184,
              "key": "c8f28893-e027-45ff-86fe-571aafd4dc90",
              "title": "",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "user_state": {
                "node_key": "c8f28893-e027-45ff-86fe-571aafd4dc90",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "instruction": null,
              "question": {
                "title": "",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "5160183240720384",
                "initial_code_files": [
                  {
                    "text": "#include <iostream>\n#include \"help_functions.h\"\n\n// TODO: assign a value, the difference in distances between x_t and x_{t-1}\n// for an x of 7 and a pre-pseudo position of 5\n\nfloat value = ?;  // YOUR VALUE HERE\n\n\nfloat parameter = 1.0;  // set as control parameter or observation measurement\nfloat stdev = 1.0;  // position or observation standard deviation\n\nint main() {\n\n  float prob = Helpers::normpdf(value, parameter, stdev);\n\n  std::cout << prob << std::endl;\n\n  return 0;\n}",
                    "name": "main.cpp"
                  },
                  {
                    "text": "#ifndef HELP_FUNCTIONS_H\n#define HELP_FUNCTIONS_H\n\n#include <math.h>\n\nclass Helpers {\n public:\n  // definition of one over square root of 2*pi:\n  constexpr static float STATIC_ONE_OVER_SQRT_2PI = 1/sqrt(2*M_PI);\n\n  /**\n   * normpdf(X,mu,sigma) computes the probability function at values x using the\n   * normal distribution with mean mu and standard deviation std. x, mu and \n   * sigma must be scalar! The parameter std must be positive. \n   * The normal pdf is y=f(x,mu,std)= 1/(std*sqrt(2pi)) e[ -(x−mu)^2 / 2*std^2 ]\n   */\n  static float normpdf(float x, float mu, float std) {\n    return (STATIC_ONE_OVER_SQRT_2PI/std)*exp(-0.5*pow((x-mu)/std,2));\n  }\n};\n\n#endif  // HELP_FUNCTIONS_H",
                    "name": "help_functions.h"
                  }
                ]
              },
              "answer": null
            },
            {
              "id": 466027,
              "key": "42a645e2-6161-4a24-8a36-2e30cdd29072",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "In the next concept we will implement the motion model in C++.",
              "instructor_notes": ""
            },
            {
              "id": 463192,
              "key": "d65eab93-a8d7-44d3-8186-3c78e19d1f74",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Reference Equations\n\n\n- **Discretized Motion Model:** \n\n<div class=\"mathquill\"> \\sum\\limits_{i} p(x_t|x_{t-1}^{(i)}, u_t, m)bel(x_{t-1}^{(i)})</div>\n\n- **Transition Model:**\n\n<div class=\"mathquill\"> p(x_t|x_{t-1}^{(i)}, u_t, m)</div>\n\n\n- '**i**'**th Motion Model Probability:**\n\n<div class=\"mathquill\"> p(x_t|x_{t-1}^{(i)}  u_t, m) *bel(x_{t-1}^{(i)})</div>\n\n\n\n\n\n",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 465609,
          "key": "7b3d6eb8-f2fc-4598-b5ed-250b6b4b4c0d",
          "title": "Coding the Motion Model",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "7b3d6eb8-f2fc-4598-b5ed-250b6b4b4c0d",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 465811,
              "key": "45048948-10de-4748-8842-097b5de13856",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Now that we have manually calculated each step for determining the motion model probability, we will implement these steps in a function.    The starter code below steps through each position x, calls the ```motion_model``` function and prints the results to ```stdout```.  To complete this exercise fill in the ```motion_model``` function which will involve:\n\n- For each <span class=\"mathquill\">x_{t}</span>. :\n\n    + Calculate the transition probability for each potential value <span class=\"mathquill\">x_{t-1}</span> \n    + Calculate the discrete motion model probability by multiplying the transition model probability by the belief state (prior) for <span class=\"mathquill\">x_{t-1}</span> \n- Return total probability (sum)  of each discrete probability",
              "instructor_notes": ""
            },
            {
              "id": 465612,
              "key": "aba54385-5621-4ee7-919b-854bc430d647",
              "title": "",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "user_state": {
                "node_key": "aba54385-5621-4ee7-919b-854bc430d647",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "instruction": null,
              "question": {
                "title": "",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "6077391793946624",
                "initial_code_files": [
                  {
                    "text": "#include <iostream>\n#include <vector>\n\n#include \"helpers.h\"\n\nusing std::vector;\n\nvector<float> initialize_priors(int map_size, vector<float> landmark_positions,\n                                float position_stdev);\n\nfloat motion_model(float pseudo_position, float movement, vector<float> priors,\n                   int map_size, int control_stdev);\n\nint main() {\n  // set standard deviation of control:\n  float control_stdev = 1.0f;\n\n  // set standard deviation of position:\n  float position_stdev = 1.0f;\n\n  // meters vehicle moves per time step\n  float movement_per_timestep = 1.0f;\n\n  // number of x positions on map\n  int map_size = 25;\n\n  // initialize landmarks\n  vector<float> landmark_positions {5, 10, 20};\n    \n  // initialize priors\n  vector<float> priors = initialize_priors(map_size, landmark_positions,\n                                           position_stdev);\n    \n  // step through each pseudo position x (i)    \n  for (float i = 0; i < map_size; ++i) {\n    float pseudo_position = i;\n\n    // get the motion model probability for each x position\n    float motion_prob = motion_model(pseudo_position, movement_per_timestep,\n                                     priors, map_size, control_stdev);\n        \n    // print to stdout\n    std::cout << pseudo_position << \"\\t\" << motion_prob << std::endl;\n  }    \n\n  return 0;\n}\n\n// TODO: implement the motion model: calculates prob of being at \n// an estimated position at time t\nfloat motion_model(float pseudo_position, float movement, vector<float> priors,\n                   int map_size, int control_stdev) {\n  // initialize probability\n  float position_prob = 0.0f;\n  \n  // YOUR CODE HERE\n\n  \n  return position_prob;\n}\n\n// initialize priors assuming vehicle at landmark +/- 1.0 meters position stdev\nvector<float> initialize_priors(int map_size, vector<float> landmark_positions,\n                                     float position_stdev) {\n\n  // set all priors to 0.0\n  vector<float> priors(map_size, 0.0);\n\n  // set each landmark positon +/-1 to 1.0/9.0 (9 possible postions)\n  float norm_term = landmark_positions.size() * (position_stdev * 2 + 1);\n  for (int i=0; i < landmark_positions.size(); ++i) {\n    for (float j=1; j <= position_stdev; ++j) {\n      priors.at(int(j+landmark_positions[i]+map_size)%map_size) += 1.0/norm_term;\n      priors.at(int(-j+landmark_positions[i]+map_size)%map_size) += 1.0/norm_term;\n    }\n    priors.at(landmark_positions[i]) += 1.0/norm_term;\n  }\n  \n  return priors;\n}",
                    "name": "main.cpp"
                  },
                  {
                    "text": "#ifndef HELP_FUNCTIONS_H\r\n#define HELP_FUNCTIONS_H\r\n\r\n#include <math.h>\r\n\r\nclass Helpers {\r\n public:\r\n  // definition of one over square root of 2*pi:\r\n  constexpr static float STATIC_ONE_OVER_SQRT_2PI = 1/sqrt(2*M_PI);\r\n\r\n  /**\r\n   * normpdf(X,mu,sigma) computes the probability function at values x using the\r\n   * normal distribution with mean mu and standard deviation std. x, mu and \r\n   * sigma must be scalar! The parameter std must be positive. \r\n   * The normal pdf is y=f(x,mu,std)= 1/(std*sqrt(2pi)) e[ -(x−mu)^2 / 2*std^2 ]\r\n   */\r\n  static float normpdf(float x, float mu, float std) {\r\n    return (STATIC_ONE_OVER_SQRT_2PI/std)*exp(-0.5*pow((x-mu)/std,2));\r\n  }\r\n};\r\n\r\n#endif  // HELP_FUNCTIONS_H\r\n",
                    "name": "helpers.h"
                  }
                ]
              },
              "answer": null
            }
          ]
        },
        {
          "id": 465629,
          "key": "71f01d25-acfe-440e-9e2e-6f2b44fc9c2e",
          "title": "Solution: Coding the Motion Model",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "71f01d25-acfe-440e-9e2e-6f2b44fc9c2e",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 465812,
              "key": "2c373b12-0c08-4cf7-ba06-564695931609",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Below is one possible implementation of the motion model.",
              "instructor_notes": ""
            },
            {
              "id": 465630,
              "key": "fbfbfcf8-98dc-47ea-89d4-0f5bb920e2d6",
              "title": "",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "user_state": {
                "node_key": "fbfbfcf8-98dc-47ea-89d4-0f5bb920e2d6",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "instruction": null,
              "question": {
                "title": "",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "5932122712440832",
                "initial_code_files": [
                  {
                    "text": "#include <iostream>\n#include <vector>\n\n#include \"helpers.h\"\n\nusing std::vector;\n\nvector<float> initialize_priors(int map_size, vector<float> landmark_positions,\n                                float position_stdev);\n\nfloat motion_model(float pseudo_position, float movement, vector<float> priors,\n                   int map_size, int control_stdev);\n\nint main() {\n  // set standard deviation of control:\n  float control_stdev = 1.0f;\n\n  // set standard deviation of position:\n  float position_stdev = 1.0f;\n\n  // meters vehicle moves per time step\n  float movement_per_timestep = 1.0f;\n\n  // number of x positions on map\n  int map_size = 25;\n\n  // initialize landmarks\n  vector<float> landmark_positions {5, 10, 20};\n    \n  // initialize priors\n  vector<float> priors = initialize_priors(map_size, landmark_positions,\n                                           position_stdev);\n    \n  // step through each pseudo position x (i)    \n  for (float i = 0; i < map_size; ++i) {\n    float pseudo_position = i;\n\n    // get the motion model probability for each x position\n    float motion_prob = motion_model(pseudo_position, movement_per_timestep,\n                                     priors, map_size, control_stdev);\n        \n    // print to stdout\n    std::cout << pseudo_position << \"\\t\" << motion_prob << std::endl;\n  }    \n\n  return 0;\n}\n\n// TODO: implement the motion model: calculates prob of being at \n// an estimated position at time t\nfloat motion_model(float pseudo_position, float movement, vector<float> priors,\n                   int map_size, int control_stdev) {\n  // initialize probability\n  float position_prob = 0.0f;\n  \n  // YOUR CODE HERE\n  // loop over state space for all possible positions x (convolution):\n  for (float j=0; j< map_size; ++j) {\n    float next_pseudo_position = j;\n    // distance from i to j\n    float distance_ij = pseudo_position-next_pseudo_position;\n\n    // transition probabilities:\n    float transition_prob = Helpers::normpdf(distance_ij, movement, \n                                             control_stdev);\n    // estimate probability for the motion model, this is our prior\n    position_prob += transition_prob*priors[j];\n  }\n\n  return position_prob;\n}\n\n// initialize priors assuming vehicle at landmark +/- 1.0 meters position stdev\nvector<float> initialize_priors(int map_size, vector<float> landmark_positions,\n                                     float position_stdev) {\n\n  // set all priors to 0.0\n  vector<float> priors(map_size, 0.0);\n\n  // set each landmark positon +/-1 to 1.0/9.0 (9 possible postions)\n  float norm_term = landmark_positions.size() * (position_stdev * 2 + 1);\n  for (int i=0; i < landmark_positions.size(); ++i) {\n    for (float j=1; j <= position_stdev; ++j) {\n      priors.at(int(j+landmark_positions[i]+map_size)%map_size) += 1.0/norm_term;\n      priors.at(int(-j+landmark_positions[i]+map_size)%map_size) += 1.0/norm_term;\n    }\n    priors.at(landmark_positions[i]) += 1.0/norm_term;\n  }\n\n  return priors;\n}",
                    "name": "main.cpp"
                  },
                  {
                    "text": "#ifndef HELP_FUNCTIONS_H\r\n#define HELP_FUNCTIONS_H\r\n\r\n#include <math.h>\r\n\r\nclass Helpers {\r\n public:\r\n  // definition of one over square root of 2*pi:\r\n  constexpr static float STATIC_ONE_OVER_SQRT_2PI = 1/sqrt(2*M_PI);\r\n\r\n  /**\r\n   * normpdf(X,mu,sigma) computes the probability function at values x using the\r\n   * normal distribution with mean mu and standard deviation std. x, mu and \r\n   * sigma must be scalar! The parameter std must be positive. \r\n   * The normal pdf is y=f(x,mu,std)= 1/(std*sqrt(2pi)) e[ -(x−mu)^2 / 2*std^2 ]\r\n   */\r\n  static float normpdf(float x, float mu, float std) {\r\n    return (STATIC_ONE_OVER_SQRT_2PI/std)*exp(-0.5*pow((x-mu)/std,2));\r\n  }\r\n};\r\n\r\n#endif  // HELP_FUNCTIONS_H\r\n",
                    "name": "helpers.h"
                  }
                ]
              },
              "answer": null
            }
          ]
        },
        {
          "id": 279166,
          "key": "b547aa3e-058a-4f9b-8c26-0a01ebca23a0",
          "title": "Observation Model Introduction",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "b547aa3e-058a-4f9b-8c26-0a01ebca23a0",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 464122,
              "key": "adf599c6-de3b-4b2e-a199-52d41af7120c",
              "title": "Observation Model Intro",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "SDM1aVqRBCk",
                "china_cdn_id": "SDM1aVqRBCk.mp4"
              }
            },
            {
              "id": 384059,
              "key": "f4dd98a6-ee1a-4e5d-a442-523332bba5bc",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Observation Model\n<div class=\"mathquill\">\np(z_t|x_t,z_{1:t-1},u_{1:t},m)\n</div>\n\n### Motion Model\n<div class=\"mathquill\">\np(x_t|z_{1:t-1},u_{1:t},m)\n</div>\n",
              "instructor_notes": ""
            },
            {
              "id": 287680,
              "key": "36d2be5c-bf60-43c6-9c14-2053a3103334",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "#### Quiz: Simplifying the Observation Model",
              "instructor_notes": ""
            },
            {
              "id": 287679,
              "key": "6033949e-91f3-4905-b071-9bfe0a2a4501",
              "title": "How can we manipulate/simplify the observation model?",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "6033949e-91f3-4905-b071-9bfe0a2a4501",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "What “trick” can we use there, which helps us  to manipulate/simplify the observation model:",
                "answers": [
                  {
                    "id": "a1490343073622",
                    "text": "Using well-known Bayes Rule again!",
                    "is_correct": false
                  },
                  {
                    "id": "a1490343103288",
                    "text": "Using the law of total Probability! ",
                    "is_correct": false
                  },
                  {
                    "id": "a1490343104072",
                    "text": "Using the Markov Assumption (Completeness of the State Assumption)",
                    "is_correct": true
                  }
                ]
              }
            }
          ]
        },
        {
          "id": 279168,
          "key": "17fdc941-ea11-4438-b8b7-4dedf70283fd",
          "title": "Markov Assumption for Observation Model",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "17fdc941-ea11-4438-b8b7-4dedf70283fd",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 464123,
              "key": "9b79d060-292b-4227-a93e-dbf963c71991",
              "title": "Markov Assumption For Observation Model",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "dyDjINdrIz0",
                "china_cdn_id": "dyDjINdrIz0.mp4"
              }
            },
            {
              "id": 385091,
              "key": "18b8af48-0c19-4beb-bd82-c8e49a78c474",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/August/59a72419_20-i-markov-assumption-for-observation-model-first-try.00-00-22-16.still001/20-i-markov-assumption-for-observation-model-first-try.00-00-22-16.still001.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/18b8af48-0c19-4beb-bd82-c8e49a78c474",
              "caption": "",
              "alt": null,
              "width": 1920,
              "height": 1080,
              "instructor_notes": null
            },
            {
              "id": 385095,
              "key": "582b3d72-ec7c-4af4-a94b-85c141348bb7",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "The Markov assumption can help us simplify the observation model.  Recall that the Markov Assumption is that the next state is dependent only upon the preceding states and that preceding state information has already been used in our state estimation.  As such, we can ignore terms in our observation model prior to <span class=\"mathquill\"> x_t </span> since these values have already been accounted for in our current state and assume that t is independent of previous observations and controls.  ",
              "instructor_notes": ""
            },
            {
              "id": 385090,
              "key": "3609652e-f50b-45d7-9c45-cfc286b9e6ac",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/August/59a72409_20-i-markov-assumption-for-observation-model-first-try.00-00-36-11.still002/20-i-markov-assumption-for-observation-model-first-try.00-00-36-11.still002.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/3609652e-f50b-45d7-9c45-cfc286b9e6ac",
              "caption": "",
              "alt": null,
              "width": 1920,
              "height": 1080,
              "instructor_notes": null
            },
            {
              "id": 385096,
              "key": "0c816848-b75a-41ea-8bc2-30959dd369fe",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "With these assumptions we simplify our posterior distribution such that the observations at t are dependent only on x at time t and the map.",
              "instructor_notes": ""
            },
            {
              "id": 385094,
              "key": "cf3d11cd-4f1e-4206-94d7-6771a9566e17",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/August/59a72485_20-i-markov-assumption-for-observation-model-first-try.00-01-18-09.still003/20-i-markov-assumption-for-observation-model-first-try.00-01-18-09.still003.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/cf3d11cd-4f1e-4206-94d7-6771a9566e17",
              "caption": "",
              "alt": null,
              "width": 1920,
              "height": 1080,
              "instructor_notes": null
            },
            {
              "id": 385097,
              "key": "32b63d25-4407-4d0e-b746-0264c4b46eeb",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Since <span class=\"mathquill\"> z_t </span> can be a vector of multiple observations we rewrite our observation model to account for the observation models for each single range measurement.  We assume that the noise behavior of the individual range values <span class=\"mathquill\"> z_t^1 </span> to <span class=\"mathquill\"> z_t^k </span> is independent and that our observations are independent, allowing us to represent the observation model as a product over the individual probability distributions of each single range measurement.  Now we must determine how to define the observation model for a single range measurement.",
              "instructor_notes": ""
            },
            {
              "id": 385093,
              "key": "3daf3389-9e4b-4602-ad96-695b456f2dc1",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/August/59a72443_20-i-markov-assumption-for-observation-model-first-try.00-03-23-08.still004/20-i-markov-assumption-for-observation-model-first-try.00-03-23-08.still004.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/3daf3389-9e4b-4602-ad96-695b456f2dc1",
              "caption": "",
              "alt": "",
              "width": 1920,
              "height": 1080,
              "instructor_notes": null
            },
            {
              "id": 385098,
              "key": "e1004ec6-6765-4824-90b1-07bb94170ba9",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "In general there exists a variety of observation models due to different sensor, sensor specific noise behavior and performance, and map types.  For our 1D example we assume that our sensor measures to the n closest objects in the driving direction, which represent the landmarks on our map.  We also assume that observation noise can be modeled as a Gaussian with a standard deviation of 1 meter and that our sensor can measure in a range of 0 – 100 meters.\n\nTo implement the observation model we use the given state <span class=\"mathquill\">  x_t </span>,  and the given map to estimate pseudo ranges, which represent the true range values under the assumption that your car would stand at a specific position <span class=\"mathquill\">  x_t </span>, on the map.   For example, if our car is standing at position 20 it would make use <span class=\"mathquill\">  x_t </span>,  and m to make pseudo range (<span class=\"mathquill\"> z_t^* </span>) observations in the order of the first landmark to the last landmark or 5, 11, 39, and 57 meters.  Compared to our real observations (<span class=\"mathquill\"> z_t </span> = [19, 37]) the position <span class=\"mathquill\">  x_t </span>,  = 20 seems unlikely and our observation would rather fit to a position around 40.  \n\nBased on this example the observation model for a single range measurement is defined by the probability of the following normal distribution <span class=\"mathquill\"> p(z_t^k|x_t )\\tilde\\ N(z_t^k,z_t^{*k},\\sigma z_t)</span> where <span class=\"mathquill\"> z_t^{*k} </span> is the mean.  This insight will ultimately allow us to implement the observation model in c++.\n",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 279169,
          "key": "3967f970-584e-4fcd-9708-677f9b5f43f9",
          "title": "Finalize the Bayes Localization Filter",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "3967f970-584e-4fcd-9708-677f9b5f43f9",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 464121,
              "key": "975d932f-2c57-41b0-aa66-14ee8036d5e5",
              "title": "Finalize The Bayes Localization Filter",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "teVw2J-_6ZE",
                "china_cdn_id": "teVw2J-_6ZE.mp4"
              }
            },
            {
              "id": 385733,
              "key": "6308523f-8e59-4698-9c5d-3cd944e63b77",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/September/59a8ea6e_21-i-finalize-the-bayes-localization-filter.00-01-00-15.still001/21-i-finalize-the-bayes-localization-filter.00-01-00-15.still001.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/6308523f-8e59-4698-9c5d-3cd944e63b77",
              "caption": "",
              "alt": "",
              "width": 1920,
              "height": 1080,
              "instructor_notes": null
            },
            {
              "id": 385734,
              "key": "16b7f748-78b3-4140-a931-077011e53abf",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "We have accomplished a lot in this lesson. \n- [Starting with the generalized form of Bayes Rule](https://classroom.udacity.com/nanodegrees/nd013/parts/40f38239-66b6-46ec-ae68-03afd8a601c8/modules/2c318113-724b-4f9f-860c-cb334e6e4ad7/lessons/47f9b7a1-317f-4fab-88d3-bb3ce215d575/concepts/d56d2238-9528-46c8-b1e1-ad086a73f3bb) we expressed our posterior, the belief of x at t as <span class=\"mathquill\">\\eta</span> (normalizer) multiplied with the observation model and the motion model.  \n- [We simplified the observation model](https://classroom.udacity.com/nanodegrees/nd013/parts/40f38239-66b6-46ec-ae68-03afd8a601c8/modules/2c318113-724b-4f9f-860c-cb334e6e4ad7/lessons/47f9b7a1-317f-4fab-88d3-bb3ce215d575/concepts/17fdc941-ea11-4438-b8b7-4dedf70283fd) using the Markov assumption to determine the probability of z at time t, given only x at time t, and the map.\n- We expressed the [motion model](https://classroom.udacity.com/nanodegrees/nd013/parts/40f38239-66b6-46ec-ae68-03afd8a601c8/modules/2c318113-724b-4f9f-860c-cb334e6e4ad7/lessons/47f9b7a1-317f-4fab-88d3-bb3ce215d575/concepts/530a769e-637e-40ce-ab73-ad5293a24d88) as a recursive state estimator using the Markov assumption and the law of total probability, resulting in a model that includes our belief at t – 1 and our transition model.\n- Finally we derived the general Bayes Filter for Localization (Markov Localization) by expressing our belief of x at t as a simplified version of our original posterior expression (top equation), <span class=\"mathquill\">\\eta</span> multiplied by the simplified observation model and the motion model.  Here the motion model is written as <span class=\"mathquill\">\\hat{bel}</span>, a prediction model.\n",
              "instructor_notes": ""
            },
            {
              "id": 385735,
              "key": "e9f9dbc2-b817-4a92-8bd8-d38db2e10204",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/September/59a8eb0c_21-i-finalize-the-bayes-localization-filter.00-01-17-24.still002/21-i-finalize-the-bayes-localization-filter.00-01-17-24.still002.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/e9f9dbc2-b817-4a92-8bd8-d38db2e10204",
              "caption": "",
              "alt": null,
              "width": 1920,
              "height": 1080,
              "instructor_notes": null
            },
            {
              "id": 385736,
              "key": "10147ca9-5ee4-4d31-9078-42ee6e8eaad6",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "The Bayes Localization Filter dependencies can be represented as a graph, by combining our sub-graphs.  To estimate the new state x at t we only need to consider the previous belief state, the current observations and controls, and the map.",
              "instructor_notes": ""
            },
            {
              "id": 385737,
              "key": "88eca25f-de5e-4725-bed5-270494ad0fb8",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/September/59a8eb3b_21-i-finalize-the-bayes-localization-filter.00-01-35-19.still003/21-i-finalize-the-bayes-localization-filter.00-01-35-19.still003.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/88eca25f-de5e-4725-bed5-270494ad0fb8",
              "caption": "",
              "alt": null,
              "width": 1920,
              "height": 1080,
              "instructor_notes": null
            },
            {
              "id": 385738,
              "key": "3d06af63-58ea-4d91-8ee6-1816bb06c2d4",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "It is a common practice to represent this filter without the belief <span class=\"mathquill\">x_t</span> and to remove the map from the motion model.  Ultimately we define <span class=\"mathquill\">bel(x_t)</span> as the following expression.",
              "instructor_notes": ""
            },
            {
              "id": 385755,
              "key": "a206bac2-8e3b-45e1-ba03-848e196b11df",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Bayes Filter for Localization (Markov Localization)\n<div class=\"mathquill\">\nbel(x_t) = p(x_t|z_t,z_{1:t-1},\\mu_{1:t},m) = \\eta *p(z_t|x_t,m) \\hat{bel}(x_t)\n</div>",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 279170,
          "key": "22bc5a5c-4c44-453f-9a17-ab904e351fe4",
          "title": "Bayes Filter Theory Summary",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "22bc5a5c-4c44-453f-9a17-ab904e351fe4",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 286327,
              "key": "678778ee-7f14-4e5d-90f2-4a96b6544ebe",
              "title": "Bayes Filter Theory Summary",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "lMyu2-PZGuk",
                "china_cdn_id": "lMyu2-PZGuk.mp4"
              }
            },
            {
              "id": 384455,
              "key": "7a2ecdce-5d0d-4c08-bc50-d8c5796e7f4c",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/August/59a64b7d_22-l-bayes-filter-theory-summary.00-00-22-29.still001/22-l-bayes-filter-theory-summary.00-00-22-29.still001.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/7a2ecdce-5d0d-4c08-bc50-d8c5796e7f4c",
              "caption": "",
              "alt": null,
              "width": 960,
              "height": 1080,
              "instructor_notes": null
            },
            {
              "id": 384457,
              "key": "72f6689d-3b23-4353-b87e-c8ee5ecb8012",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "The image above sums up the core achievements of this lesson.\n- The Bayes Localization Filter Markov Localization is a general framework for recursive state estimation.\n- That means this framework allows us to use the previous state (state at t-1) to estimate a new state (state at t) using only current observations and controls (observations and control at t), rather than the entire data history (data from 0:t).\n",
              "instructor_notes": ""
            },
            {
              "id": 384456,
              "key": "3861a3fb-35b8-46e6-950b-8c2dade36c33",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/August/59a64b8e_22-l-bayes-filter-theory-summary.00-00-52-03.still002/22-l-bayes-filter-theory-summary.00-00-52-03.still002.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/3861a3fb-35b8-46e6-950b-8c2dade36c33",
              "caption": "",
              "alt": null,
              "width": 960,
              "height": 1080,
              "instructor_notes": null
            },
            {
              "id": 384458,
              "key": "d8ef6cb2-f31d-4727-bc49-4ae9afcf5925",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "- The motion model describes the prediction step of the filter while the observation model is the update step.\n- The state estimation using the Bayes filter is dependent upon the interaction between prediction (motion model) and update (observation model steps) and all the localization methods discussed so far are realizations of the Bayes filter.\n- In the next few sections we will learn how to estimate pseudo ranges, calculate the observation model probability, and complete the implementation of the observation model in C++.\n",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 461355,
          "key": "ad5439d9-cad4-447a-a6b4-6d3fc94186cd",
          "title": "Observation Model Probability",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "ad5439d9-cad4-447a-a6b4-6d3fc94186cd",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 462597,
              "key": "7692b4f8-b50c-4adf-8428-4425c31e0d42",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "We will complete our Bayes' filter by implementing the observation model.  The observation model uses pseudo range estimates and observation measurements as inputs.  Let's recap what is meant by a pseudo range estimate and an observation measurement.  \n\nFor the figure below, the top 1d map (green car) shows our observation measurements.  These are the distances from our actual car position at time t,  to landmarks, as detected by sensors.  In this example, those distances are 19m and 37m.   \n\nThe bottom 1d map (yellow car) shows our pseudo range estimates.  These are the distances we would expect given the landmarks and assuming a given position x at time t, of 20m.  In this example, those distances are 5, 11, 39, and 57m.    \n\n",
              "instructor_notes": ""
            },
            {
              "id": 463688,
              "key": "8b3b8ffd-a46c-407b-a337-26616986f38c",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/November/5a0e1a58_obs-model-measurements-pseudoranges/obs-model-measurements-pseudoranges.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/8b3b8ffd-a46c-407b-a337-26616986f38c",
              "caption": "",
              "alt": "",
              "width": 1920,
              "height": 532,
              "instructor_notes": null
            },
            {
              "id": 463689,
              "key": "3d19425f-91bf-4ea0-bcda-da729948c2bb",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "The observation model will be implemented by performing the following at each time step:\n\n- Measure the range to landmarks up to 100m from the vehicle, in the driving direction (forward)\n- Estimate a pseudo range from each landmark by subtracting pseudo position from the landmark position\n- Match each pseudo range estimate to its closest observation measurement\n- For each pseudo range and observation measurement pair, calculate a probability by passing relevant values to norm_pdf: ```norm_pdf(observation_measurement, pseudo_range_estimate, observation_stdev)``` \n- Return the product of all probabilities\n\nWhy do we multiply all the probabilities in the last step?  Our final signal (probability) must reflect all pseudo range, observation pairs.  This blends our signal.  For example, if we have a high probability match (small difference between the pseudo range estimate and the observation measurement) and low probability match (large difference between the pseudo range estimate and the observation measurement), our resultant probability will be somewhere in between, reflecting the overall belief we have in that state.\n",
              "instructor_notes": ""
            },
            {
              "id": 462598,
              "key": "1be8da95-f363-4199-8051-d6f972e3b512",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Let's practice this process using the following information and ```norm_pdf```.\n\n- **pseudo position:** x = 10m\n- **vector of landmark positions from our map:** [6m, 15m, 21m, 40m]\n- **observation measurements:** [5.5m, 11m]\n- **observation standard deviation:** 1.0m\n",
              "instructor_notes": ""
            },
            {
              "id": 463170,
              "key": "829a6b5e-c2fc-4a00-ade1-1cc09bc239a6",
              "title": "Estimate Pseudo Ranges",
              "semantic_type": "ValidatedQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "829a6b5e-c2fc-4a00-ade1-1cc09bc239a6",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "Our first step is to estimate pseudo ranges, please enter the response as a vector with no spaces, in ascending order.  For example [5, 4, 7, 20].",
                "matchers": [
                  {
                    "expression": "\\[5,11,30\\]"
                  }
                ]
              }
            },
            {
              "id": 463256,
              "key": "b47e0cc5-9afb-46e5-ae98-a8b614d47b06",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "<div id=\"spoiler\" style=\"display:none\">\n- 6m is not in the driving direction, so we reject this\n- The remaining calculations are shown within the vector: [15-10,21-10,40-10] = **[5,11,30]**\n</div>\n<button title=\"Click to show/hide content\" type=\"button\" onclick=\"if(document.getElementById('spoiler') .style.display=='none') {document.getElementById('spoiler') .style.display=''}else{document.getElementById('spoiler') .style.display='none'}\">Show Solution</button>",
              "instructor_notes": ""
            },
            {
              "id": 463171,
              "key": "5b489e5d-e170-4479-a4e9-c78ef0b3db39",
              "title": "Association",
              "semantic_type": "ValidatedQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "5b489e5d-e170-4479-a4e9-c78ef0b3db39",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "Match each observation measurement with the nearest estimated pseudo range.  We will only use each measurement and pseudo range once.  Enter each pair as a vector of tuples, with no spaces, with tuples ordered as (observation,pseudo_range).  For example [(5.5,10),(11,15)]",
                "matchers": [
                  {
                    "expression": "\\[\\(5.5,5\\),\\(11,11\\)\\]"
                  },
                  {
                    "expression": "\\[\\(5,5.5\\),\\(11,11\\)\\]"
                  },
                  {
                    "expression": "\\[\\(11,11\\),\\(5.5,5\\)\\]"
                  },
                  {
                    "expression": "\\[\\(11,11\\),\\(5,5.5\\)\\]"
                  }
                ]
              }
            },
            {
              "id": 463258,
              "key": "ae2a1f7b-e880-4692-8a45-fb286fe823e9",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "<div id=\"spoiler_2\" style=\"display:none\">\n\n[(5.5,5),(11,11)]\n\n</div>\n<button title=\"Click to show/hide content\" type=\"button\" onclick=\"if(document.getElementById('spoiler_2') .style.display=='none') {document.getElementById('spoiler_2') .style.display=''}else{document.getElementById('spoiler_2') .style.display='none'}\">Show Solution</button>",
              "instructor_notes": ""
            },
            {
              "id": 463172,
              "key": "913faa62-504a-41b3-8e3a-813872aa41aa",
              "title": "Determine Probabilities",
              "semantic_type": "ValidatedQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "913faa62-504a-41b3-8e3a-813872aa41aa",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "Calculate a probability for each observation measurement and pseudo range estimate pair by passing relevant data to ```norm_pdf```   Enter your response as a vector of probabilities in scientific notation with an accuracy of two decimal places, and no spaces.  For example [3.14E-15,1.23E-5].",
                "matchers": [
                  {
                    "expression": "\\[3.9[7-9]E-(0|)1,3.5[1-3]E-(0|)1\\]"
                  },
                  {
                    "expression": "\\[3.5[1-3]E-(0|)1,3.9[7-9]E-(0|)1\\]"
                  },
                  {
                    "expression": "\\[4.0[0-1]E-(0|)1,3.5[1-3]E-(0|)1\\]"
                  },
                  {
                    "expression": "\\[3.5[1-3]E-(0|)1, 4.0[0-1]E-(0|)1\\]"
                  }
                ]
              }
            },
            {
              "id": 640604,
              "key": "cbc91aba-1eb6-4c28-ac61-fd4f44301a92",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Recall that our observation model probability can be determined through ```norm_pdf(observation_measurement, pseudo_range_estimate, observation_stdev)```. ",
              "instructor_notes": ""
            },
            {
              "id": 463692,
              "key": "d42cfab0-2abf-4944-a549-9c87bc8f7f58",
              "title": "",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "user_state": {
                "node_key": "d42cfab0-2abf-4944-a549-9c87bc8f7f58",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "instruction": null,
              "question": {
                "title": "",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "5811442016714752",
                "initial_code_files": [
                  {
                    "text": "#include <iostream>\n#include \"help_functions.h\"\n\nfloat value = ?; // TODO: assign a value, the difference in distances\nfloat parameter = 1.0; // set as control parameter or observation measurement\nfloat stdev = 1.0; // position or observation standard deviation\n\nint main() {\n\n  float prob = Helpers::normpdf(value, parameter, stdev);\n\n  std::cout << prob << std::endl;\n\n  return 0;\n}",
                    "name": "main.cpp"
                  },
                  {
                    "text": "#ifndef HELP_FUNCTIONS_H\n#define HELP_FUNCTIONS_H\n\n#include <math.h>\n\nclass Helpers {\n public:\n  // definition of one over square root of 2*pi:\n  constexpr static float STATIC_ONE_OVER_SQRT_2PI = 1/sqrt(2*M_PI);\n\n  /**\n   * normpdf(X,mu,sigma) computes the probability function at values x using the\n   * normal distribution with mean mu and standard deviation std. x, mu and \n   * sigma must be scalar! The parameter std must be positive. \n   * The normal pdf is y=f(x,mu,std)= 1/(std*sqrt(2pi)) e[ -(x−mu)^2 / 2*std^2 ]\n   */\n  static float normpdf(float x, float mu, float std) {\n    return (STATIC_ONE_OVER_SQRT_2PI/std)*exp(-0.5*pow((x-mu)/std,2));\n  }\n};\n\n#endif  // HELP_FUNCTIONS_H",
                    "name": "help_functions.h"
                  }
                ]
              },
              "answer": null
            },
            {
              "id": 463262,
              "key": "88df7c72-0efd-408f-a9da-c4e4b78fdc79",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "<div id=\"spoiler_3\" style=\"display:none\">\nUse the following with ```norm_pdf``` pressing \"test run\" to return each probability.\n\n```python\nfloat value = 5.5; //TODO: assign a value, the difference in distances\nfloat parameter = 5; //set as control parameter or observation measurement\nfloat stdev = 1.0; //position or observation standard deviation\n```\nand \n\n```python\nfloat value = 11; //TODO: assign a value, the difference in distances\nfloat parameter = 11; //set as control parameter or observation measurement\nfloat stdev = 1.0; //position or observation standard deviation\n```\n\n### Result in vector form\n[3.99E-1,3.52E-1]  Please note that grader allows any order and allows for slight differences in precision.\n</div>\n<button title=\"Click to show/hide content\" type=\"button\" onclick=\"if(document.getElementById('spoiler_3') .style.display=='none') {document.getElementById('spoiler_3') .style.display=''}else{document.getElementById('spoiler_3') .style.display='none'}\">Show Solution</button>",
              "instructor_notes": ""
            },
            {
              "id": 463173,
              "key": "5102059d-c0cc-4774-9f58-9cf9183e5929",
              "title": "Observation Model Probability",
              "semantic_type": "ValidatedQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "5102059d-c0cc-4774-9f58-9cf9183e5929",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "To complete our observation model probability, determine the product of each observation probability from the previous quiz. Remember that our observation model probability is the product of the probabilities determined using each (pseudo_range, observation) pair and ```norm_pdf```.  Enter your response in scientific notation with an accuracy of two decimal places.  For example 2.99E-1.",
                "matchers": [
                  {
                    "expression": "1.4[0-3]E-(0|)1"
                  },
                  {
                    "expression": "1.3[8-9]E-(0|)1"
                  }
                ]
              }
            },
            {
              "id": 463263,
              "key": "0c7affa8-f765-48ee-8c38-364877ef2aa2",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "<div id=\"spoiler_4\" style=\"display:none\">\n\n3.99E-01 * 3.52E-01 =  __1.40E-01__  Please note that the grader allows for slight differences in precision.\n</div>\n<button title=\"Click to show/hide content\" type=\"button\" onclick=\"if(document.getElementById('spoiler_4') .style.display=='none') {document.getElementById('spoiler_4') .style.display=''}else{document.getElementById('spoiler_4') .style.display='none'}\">Show Solution</button>",
              "instructor_notes": ""
            },
            {
              "id": 463174,
              "key": "fde5fa6b-7af0-47cd-8b03-85ca8f60b57c",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Now that we have implemented the observation model manually, we will try out a code implementation in the next few concepts.",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 465728,
          "key": "4b59fed7-0228-4f77-9cb7-09e64b15e28f",
          "title": "Get Pseudo Ranges",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "4b59fed7-0228-4f77-9cb7-09e64b15e28f",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 465816,
              "key": "af72c0cd-ad5b-4422-885d-819e21df1d36",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "In the previous exercises we manually executed the steps for determining pseudo ranges and our observation model probability.  Now let's implement a function that accepts a vector of landmark positions, a pseudo position (x), and returns a vector of sorted (ascending) pseudo ranges.  Later, we will use the pseudo range vector as an input for our observation model function.\n\nTo implement the ```pseudo_range_estimator``` function we must do the following for each pseudo position x:\n\n- For each landmark position:\n    + determine the distance between each pseudo position x and each landmark position\n    + if the distance is positive (landmark is forward of the pseudo position) push the distance to the pseudo range vector\n    + sort the pseudo range vector in ascending order\n    + return the pseudo range vector\n\nThere may be missing x values in the output.  This is because not all x values have a forward landmark (positive pseudo range).\n",
              "instructor_notes": ""
            },
            {
              "id": 465730,
              "key": "7511e344-9a75-4561-b185-889dd8b0d9d8",
              "title": "",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "user_state": {
                "node_key": "7511e344-9a75-4561-b185-889dd8b0d9d8",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "instruction": null,
              "question": {
                "title": "",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "6730477675872256",
                "initial_code_files": [
                  {
                    "text": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\n#include \"helpers.h\"\n\nusing std::vector;\n\n// set standard deviation of control:\nfloat control_stdev = 1.0f;\n\n// meters vehicle moves per time step\nfloat movement_per_timestep = 1.0f;\n\n// number of x positions on map\nint map_size = 25;\n\n// define landmarks\nvector<float> landmark_positions {5, 10, 12, 20};\n\n// declare pseudo_range_estimator function\nvector<float> pseudo_range_estimator(vector<float> landmark_positions, \n                                     float pseudo_position);\n\n\nint main() {    \n  // step through each pseudo position x (i)\n  for (int i = 0; i < map_size; ++i) {\n    float pseudo_position = float(i);\n    // get pseudo ranges\n    vector<float> pseudo_ranges = pseudo_range_estimator(landmark_positions, \n                                                         pseudo_position);\n    // print to stdout\n    if (pseudo_ranges.size() > 0) {\n      for (int s = 0; s < pseudo_ranges.size(); ++s) {\n        std::cout << \"x: \" << i << \"\\t\" << pseudo_ranges[s] << std::endl;\n      }\n      std::cout << \"-----------------------\" << std::endl;\n    }   \n  } \n\n  return 0;\n}\n\n// TODO: Complete pseudo range estimator function\nvector<float> pseudo_range_estimator(vector<float> landmark_positions, \n                                     float pseudo_position) {\n  // define pseudo observation vector\n  vector<float> pseudo_ranges;\n            \n  // loop over number of landmarks and estimate pseudo ranges\n  // YOUR CODE HERE\n        \n\n  // sort pseudo range vector\n  // YOUR CODE HERE\n    \n  return pseudo_ranges;\n}",
                    "name": "main.cpp"
                  },
                  {
                    "text": "#ifndef HELP_FUNCTIONS_H\n#define HELP_FUNCTIONS_H\n\n#include <math.h>\n\nclass Helpers {\n public:\n  // definition of one over square root of 2*pi:\n  constexpr static float STATIC_ONE_OVER_SQRT_2PI = 1/sqrt(2*M_PI);\n\n  /**\n   * normpdf(X,mu,sigma) computes the probability function at values x using the\n   * normal distribution with mean mu and standard deviation std. x, mu and \n   * sigma must be scalar! The parameter std must be positive. \n   * The normal pdf is y=f(x,mu,std)= 1/(std*sqrt(2pi)) e[ -(x−mu)^2 / 2*std^2 ]\n   */\n  static float normpdf(float x, float mu, float std) {\n    return (STATIC_ONE_OVER_SQRT_2PI/std)*exp(-0.5*pow((x-mu)/std,2));\n  }\n};\n\n#endif  // HELP_FUNCTIONS_H",
                    "name": "helpers.h"
                  }
                ]
              },
              "answer": null
            }
          ]
        },
        {
          "id": 465729,
          "key": "819fc290-5c07-464b-89d3-0f4c9fa9bcd6",
          "title": "Solution: Get Pseudo Ranges",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "819fc290-5c07-464b-89d3-0f4c9fa9bcd6",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 465819,
              "key": "5c0a355c-d19e-4e86-bcd6-4da708ef5846",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Below is one possible implementation of the pseudo_range_estimator function.",
              "instructor_notes": ""
            },
            {
              "id": 465731,
              "key": "8218cdba-6408-44f9-b45a-6b1cf8a13597",
              "title": "",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "user_state": {
                "node_key": "8218cdba-6408-44f9-b45a-6b1cf8a13597",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "instruction": null,
              "question": {
                "title": "",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "4564585798041600",
                "initial_code_files": [
                  {
                    "text": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\n#include \"helpers.h\"\n\nusing std::vector;\n\n// set standard deviation of control:\nfloat control_stdev = 1.0f;\n\n// meters vehicle moves per time step\nfloat movement_per_timestep = 1.0f;\n\n// number of x positions on map\nint map_size = 25;\n\n// define landmarks\nvector<float> landmark_positions {5, 10, 12, 20};\n\n// declare pseudo_range_estimator function\nvector<float> pseudo_range_estimator(vector<float> landmark_positions, \n                                     float pseudo_position);\n\n\nint main() {    \n  // step through each pseudo position x (i)\n  for (int i = 0; i < map_size; ++i) {\n    float pseudo_position = float(i);\n    // get pseudo ranges\n    vector<float> pseudo_ranges = pseudo_range_estimator(landmark_positions, \n                                                         pseudo_position);\n    // print to stdout\n    if (pseudo_ranges.size() > 0) {\n      for (int s = 0; s < pseudo_ranges.size(); ++s) {\n        std::cout << \"x: \" << i << \"\\t\" << pseudo_ranges[s] << std::endl;\n      }\n      std::cout << \"-----------------------\" << std::endl;\n    }   \n  } \n\n  return 0;\n}\n\n// TODO: Complete pseudo range estimator function\nvector<float> pseudo_range_estimator(vector<float> landmark_positions, \n                                     float pseudo_position) {\n  // define pseudo observation vector\n  vector<float> pseudo_ranges;\n            \n  // loop over number of landmarks and estimate pseudo ranges\n  // YOUR CODE HERE\n  for (int l=0; l< landmark_positions.size(); ++l) {\n    // estimate pseudo range for each single landmark \n    // and the current state position pose_i:\n    float range_l = landmark_positions[l] - pseudo_position;\n\n    // check if distances are positive: \n    if (range_l > 0.0f) {\n      pseudo_ranges.push_back(range_l);\n    }\n  }\n\n  // sort pseudo range vector\n  // YOUR CODE HERE\n  sort(pseudo_ranges.begin(), pseudo_ranges.end());\n\n  return pseudo_ranges;\n}",
                    "name": "main.cpp"
                  },
                  {
                    "text": "#ifndef HELP_FUNCTIONS_H\r\n#define HELP_FUNCTIONS_H\r\n\r\n#include <math.h>\r\n\r\nclass Helpers {\r\n public:\r\n  // definition of one over square root of 2*pi:\r\n  constexpr static float STATIC_ONE_OVER_SQRT_2PI = 1/sqrt(2*M_PI);\r\n\r\n  /**\r\n   * normpdf(X,mu,sigma) computes the probability function at values x using the\r\n   * normal distribution with mean mu and standard deviation std. x, mu and \r\n   * sigma must be scalar! The parameter std must be positive. \r\n   * The normal pdf is y=f(x,mu,std)= 1/(std*sqrt(2pi)) e[ -(x−mu)^2 / 2*std^2 ]\r\n   */\r\n  static float normpdf(float x, float mu, float std) {\r\n    return (STATIC_ONE_OVER_SQRT_2PI/std)*exp(-0.5*pow((x-mu)/std,2));\r\n  }\r\n};\r\n\r\n#endif  // HELP_FUNCTIONS_H",
                    "name": "helpers.h"
                  }
                ]
              },
              "answer": null
            }
          ]
        },
        {
          "id": 465732,
          "key": "062fbfa5-42fc-47bd-8e0e-0bb8eccd60d6",
          "title": "Coding the Observation Model",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "062fbfa5-42fc-47bd-8e0e-0bb8eccd60d6",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 465839,
              "key": "714071a5-1166-4547-a2dc-6e1934c15bb5",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "The final individual model we will implement is the observation model.  The observation model accepts the pseudo range vector from the previous assignment, an observation vector (from vehicle sensors), and returns the observation model probability.  Ultimately, we will multiply this by the motion model probability, then normalize to produce the belief state for the current time step.\n\nThe starter code below steps through each pseudo position x, calls the ```observation_model```  function and prints the results to standout. To complete this exercise fill in the ```observation_model function```.\n\nTo implement the observation_model function we must do the following for each pseudo position x:\n\n- For each observation:\n    + determine if a pseudo range vector exists for the current pseudo position x\n    + if the vector exists, extract and store the minimum distance, element 0 of the sorted vector, and remove that element (so we don't re-use it).  This will be passed to ```norm_pdf```\n    + if the pseudo range vector does not exist,  pass the maximum distance to ```norm_pdf```\n    + use ```norm_pdf``` to determine the observation model probability\n    + return the total probability \n    \n    \n",
              "instructor_notes": ""
            },
            {
              "id": 465734,
              "key": "f8673485-b49d-4883-8306-cfbaadad7115",
              "title": "",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "user_state": {
                "node_key": "f8673485-b49d-4883-8306-cfbaadad7115",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "instruction": null,
              "question": {
                "title": "",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "4692263901462528",
                "initial_code_files": [
                  {
                    "text": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\n#include \"helpers.h\"\n\nusing std::vector;\n\n// function to get pseudo ranges\nvector<float> pseudo_range_estimator(vector<float> landmark_positions, \n                                     float pseudo_position);\n\n// observation model: calculate likelihood prob term based on landmark proximity\nfloat observation_model(vector<float> landmark_positions, \n                        vector<float> observations, vector<float> pseudo_ranges,\n                        float distance_max, float observation_stdev);\n\nint main() {  \n  // set observation standard deviation:\n  float observation_stdev = 1.0f;\n\n  // number of x positions on map\n  int map_size = 25;\n\n  // set distance max\n  float distance_max = map_size;\n\n  // define landmarks\n  vector<float> landmark_positions {5, 10, 12, 20};\n\n  // define observations\n  vector<float> observations {5.5, 13, 15};\n\n  // step through each pseudo position x (i)\n  for (int i = 0; i < map_size; ++i) {\n    float pseudo_position = float(i);\n\n    // get pseudo ranges\n    vector<float> pseudo_ranges = pseudo_range_estimator(landmark_positions, \n                                                         pseudo_position);\n\n    //get observation probability\n    float observation_prob = observation_model(landmark_positions, observations, \n                                               pseudo_ranges, distance_max, \n                                               observation_stdev);\n    //print to stdout\n    std::cout << observation_prob << std::endl; \n  }      \n\n  return 0;\n}\n\n// TODO: Complete the observation model function\n// calculates likelihood prob term based on landmark proximity\nfloat observation_model(vector<float> landmark_positions, \n                        vector<float> observations, vector<float> pseudo_ranges, \n                        float distance_max, float observation_stdev) {\n  float distance_prob;\n  // YOUR CODE HERE\n\n\n  return distance_prob;\n}\n\nvector<float> pseudo_range_estimator(vector<float> landmark_positions, \n                                     float pseudo_position) {\n  // define pseudo observation vector\n  vector<float> pseudo_ranges;\n            \n  // loop over number of landmarks and estimate pseudo ranges\n  for (int l=0; l< landmark_positions.size(); ++l) {\n    // estimate pseudo range for each single landmark \n    // and the current state position pose_i:\n    float range_l = landmark_positions[l] - pseudo_position;\n\n    // check if distances are positive: \n    if (range_l > 0.0f) {\n      pseudo_ranges.push_back(range_l);\n    }\n  }\n\n  // sort pseudo range vector\n  sort(pseudo_ranges.begin(), pseudo_ranges.end());\n\n  return pseudo_ranges;\n}",
                    "name": "main.cpp"
                  },
                  {
                    "text": "#ifndef HELP_FUNCTIONS_H\r\n#define HELP_FUNCTIONS_H\r\n\r\n#include <math.h>\r\n\r\nclass Helpers {\r\n public:\r\n  // definition of one over square root of 2*pi:\r\n  constexpr static float STATIC_ONE_OVER_SQRT_2PI = 1/sqrt(2*M_PI);\r\n\r\n  /**\r\n   * normpdf(X,mu,sigma) computes the probability function at values x using the\r\n   * normal distribution with mean mu and standard deviation std. x, mu and \r\n   * sigma must be scalar! The parameter std must be positive. \r\n   * The normal pdf is y=f(x,mu,std)= 1/(std*sqrt(2pi)) e[ -(x−mu)^2 / 2*std^2 ]\r\n   */\r\n  static float normpdf(float x, float mu, float std) {\r\n    return (STATIC_ONE_OVER_SQRT_2PI/std)*exp(-0.5*pow((x-mu)/std,2));\r\n  }\r\n};\r\n\r\n#endif  // HELP_FUNCTIONS_H\r\n",
                    "name": "helpers.h"
                  }
                ]
              },
              "answer": null
            }
          ]
        },
        {
          "id": 465733,
          "key": "75a3badf-8c69-4c45-b64a-081403e9e656",
          "title": "Solution: Coding the Observation Model",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "75a3badf-8c69-4c45-b64a-081403e9e656",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 465841,
              "key": "0c64cf2e-7009-47d2-9f95-575bc011ece9",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Below is one possible implementation of the observation model.",
              "instructor_notes": ""
            },
            {
              "id": 465735,
              "key": "63016127-7174-4126-8fd5-598a864c7326",
              "title": "",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "user_state": {
                "node_key": "63016127-7174-4126-8fd5-598a864c7326",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "instruction": null,
              "question": {
                "title": "",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "6178901198503936",
                "initial_code_files": [
                  {
                    "text": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\n#include \"helpers.h\"\n\nusing std::vector;\n\n// function to get pseudo ranges\nvector<float> pseudo_range_estimator(vector<float> landmark_positions, \n                                     float pseudo_position);\n\n// observation model: calculate likelihood prob term based on landmark proximity\nfloat observation_model(vector<float> landmark_positions, \n                        vector<float> observations, vector<float> pseudo_ranges,\n                        float distance_max, float observation_stdev);\n\nint main() {  \n  // set observation standard deviation:\n  float observation_stdev = 1.0f;\n\n  // number of x positions on map\n  int map_size = 25;\n\n  // set distance max\n  float distance_max = map_size;\n\n  // define landmarks\n  vector<float> landmark_positions {5, 10, 12, 20};\n\n  // define observations\n  vector<float> observations {5.5, 13, 15};\n\n  // step through each pseudo position x (i)\n  for (int i = 0; i < map_size; ++i) {\n    float pseudo_position = float(i);\n\n    // get pseudo ranges\n    vector<float> pseudo_ranges = pseudo_range_estimator(landmark_positions, \n                                                         pseudo_position);\n\n    //get observation probability\n    float observation_prob = observation_model(landmark_positions, observations, \n                                               pseudo_ranges, distance_max, \n                                               observation_stdev);\n    //print to stdout\n    std::cout << observation_prob << std::endl; \n  }      \n\n  return 0;\n}\n\n// TODO: Complete the observation model function\n// calculates likelihood prob term based on landmark proximity\nfloat observation_model(vector<float> landmark_positions, \n                        vector<float> observations, vector<float> pseudo_ranges, \n                        float distance_max, float observation_stdev) {\n  // initialize observation probability\n  float distance_prob = 1.0f;\n\n  // run over current observation vector\n  for (int z=0; z< observations.size(); ++z) {\n    // define min distance\n    float pseudo_range_min;\n        \n    // check, if distance vector exists\n    if (pseudo_ranges.size() > 0) {\n      // set min distance\n      pseudo_range_min = pseudo_ranges[0];\n      // remove this entry from pseudo_ranges-vector\n      pseudo_ranges.erase(pseudo_ranges.begin());\n    } else {  // no or negative distances: set min distance to a large number\n        pseudo_range_min = std::numeric_limits<const float>::infinity();\n    }\n\n    // estimate the probability for observation model, this is our likelihood \n    distance_prob *= Helpers::normpdf(observations[z], pseudo_range_min,\n                                      observation_stdev);\n  }\n\n  return distance_prob;\n}\n\nvector<float> pseudo_range_estimator(vector<float> landmark_positions, \n                                     float pseudo_position) {\n  // define pseudo observation vector\n  vector<float> pseudo_ranges;\n            \n  // loop over number of landmarks and estimate pseudo ranges\n  for (int l=0; l< landmark_positions.size(); ++l) {\n    // estimate pseudo range for each single landmark \n    // and the current state position pose_i:\n    float range_l = landmark_positions[l] - pseudo_position;\n\n    // check if distances are positive: \n    if (range_l > 0.0f) {\n      pseudo_ranges.push_back(range_l);\n    }\n  }\n\n  // sort pseudo range vector\n  sort(pseudo_ranges.begin(), pseudo_ranges.end());\n\n  return pseudo_ranges;\n}",
                    "name": "main.cpp"
                  },
                  {
                    "text": "#ifndef HELP_FUNCTIONS_H\r\n#define HELP_FUNCTIONS_H\r\n\r\n#include <math.h>\r\n\r\nclass Helpers {\r\n public:\r\n  // definition of one over square root of 2*pi:\r\n  constexpr static float STATIC_ONE_OVER_SQRT_2PI = 1/sqrt(2*M_PI);\r\n\r\n  /**\r\n   * normpdf(X,mu,sigma) computes the probability function at values x using the\r\n   * normal distribution with mean mu and standard deviation std. x, mu and \r\n   * sigma must be scalar! The parameter std must be positive. \r\n   * The normal pdf is y=f(x,mu,std)= 1/(std*sqrt(2pi)) e[ -(x−mu)^2 / 2*std^2 ]\r\n   */\r\n  static float normpdf(float x, float mu, float std) {\r\n    return (STATIC_ONE_OVER_SQRT_2PI/std)*exp(-0.5*pow((x-mu)/std,2));\r\n  }\r\n};\r\n\r\n#endif  // HELP_FUNCTIONS_H\r\n",
                    "name": "helpers.h"
                  }
                ]
              },
              "answer": null
            }
          ]
        },
        {
          "id": 467266,
          "key": "a79a04da-88f4-46cf-b1b0-5e70b41886d0",
          "title": "Coding the Full Filter",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "a79a04da-88f4-46cf-b1b0-5e70b41886d0",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 467320,
              "key": "3f6d84a6-1996-4011-802a-cfbe51fbdc7b",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "In previous lessons we learned the basis of our filter, tried some example calculations by hand, and implemented critical steps and models for a single time step and vector of sensor observations.  In this final coding exercise we will implement the entire filter using the pieces we have already developed for multiple time steps and sensor observations.  \n\nSensor observations are provided in a 2D vector where each inner vector represents the sensor observations, in meters, at a time step.\n\n```\n{{1,7,12,21}, {0,6,11,20}, {5,10,19}, {4,9,18}, {3,8,17}, {2,7,16}, \n{1,6,15}, {0,5,14}, {4,13}, {3,12},{2,11},{1,10},{0,9},{8},{7},{6},{5},\n{4},{3},{2},{1},{0}, {}, {}, {}};\n```\n\nImplement the Bayes' localization filter by first initializing priors, then doing the following within each time step:\n\n- extract sensor observations\n    - for each pseudo-position:\n        + get the motion model probability\n        + determine pseudo ranges\n        + get the observation model probability\n        + use the motion and observation model probabilities to calculate the posterior probability\n\n - normalize posteriors (see helpers.h for a normalization function)\n - update priors (priors --> posteriors)\n\n\n**All tasks are within the main function and are labeled as ```TODO```.**\n\n    \n\n\n**Troubleshooting:**\n\nTo help troubleshoot print statements have been placed throughout the code below and commented out.  Uncommenting these statements will help to follow each step of the filter.\n",
              "instructor_notes": ""
            },
            {
              "id": 467287,
              "key": "526ffa60-b173-4c69-ab9f-243bbdb5ecca",
              "title": "",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "user_state": {
                "node_key": "526ffa60-b173-4c69-ab9f-243bbdb5ecca",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "instruction": null,
              "question": {
                "title": "",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "5563084962398208",
                "initial_code_files": [
                  {
                    "text": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\n#include \"helpers.h\"\n\nusing std::vector;\nusing std::cout;\nusing std::endl;\n\n\nvector<float> initialize_priors(int map_size, vector<float> landmark_positions,\n                                float position_stdev);\n\nfloat motion_model(float pseudo_position, float movement, vector<float> priors,\n                   int map_size, int control_stdev);\n\n// function to get pseudo ranges\nvector<float> pseudo_range_estimator(vector<float> landmark_positions, \n                                     float pseudo_position);\n\n// observation model: calculate likelihood prob term based on landmark proximity\nfloat observation_model(vector<float> landmark_positions, \n                        vector<float> observations, vector<float> pseudo_ranges,\n                        float distance_max, float observation_stdev);\n\n\nint main() {  \n  // set standard deviation of control\n  float control_stdev = 1.0f;\n\n  // set standard deviation of position\n  float position_stdev = 1.0f;\n\n  // meters vehicle moves per time step\n  float movement_per_timestep = 1.0f;\n\n  // set observation standard deviation\n  float observation_stdev = 1.0f;\n\n  // number of x positions on map\n  int map_size = 25;\n\n  // set distance max\n  float distance_max = map_size;\n\n  // define landmarks\n  vector<float> landmark_positions {3, 9, 14, 23};\n\n  // define observations vector, each inner vector represents a set \n  //   of observations for a time step\n  vector<vector<float> > sensor_obs {{1,7,12,21}, {0,6,11,20}, {5,10,19},\n                                     {4,9,18}, {3,8,17}, {2,7,16}, {1,6,15}, \n                                     {0,5,14}, {4,13}, {3,12}, {2,11}, {1,10},\n                                     {0,9}, {8}, {7}, {6}, {5}, {4}, {3}, {2},\n                                     {1}, {0}, {}, {}, {}};\n\n  /**\n   * TODO: initialize priors\n   */\n  \n\n  // UNCOMMENT TO SEE THIS STEP OF THE FILTER\n  //cout << \"-----------PRIORS INIT--------------\" << endl;\n  //for (int p = 0; p < priors.size(); ++p){\n  //  cout << priors[p] << endl;\n  //}  \n    \n  // initialize posteriors\n  vector<float> posteriors(map_size, 0.0);\n\n  // specify time steps\n  int time_steps = sensor_obs.size();\n    \n  // declare observations vector\n  vector<float> observations;\n    \n  // cycle through time steps\n  for (int t = 0; t < time_steps; ++t) {\n    // UNCOMMENT TO SEE THIS STEP OF THE FILTER\n    //cout << \"---------------TIME STEP---------------\" << endl;\n    //cout << \"t = \" << t << endl;\n    //cout << \"-----Motion----------OBS----------------PRODUCT--\" << endl;\n\n    if (!sensor_obs[t].empty()) {\n      observations = sensor_obs[t]; \n    } else {\n      observations = {float(distance_max)};\n    }\n\n    // step through each pseudo position x (i)\n    for (unsigned int i = 0; i < map_size; ++i) {\n      float pseudo_position = float(i);\n\n      /**\n       * TODO: get the motion model probability for each x position\n       */\n\n\n      /**\n       * TODO: get pseudo ranges\n       */\n\n\n      /**\n       * TODO: get observation probability\n       */\n\n\n      /**\n       * TODO: calculate the ith posterior and pass to posteriors vector\n       */\n      \n\n      // UNCOMMENT TO SEE THIS STEP OF THE FILTER\n      //cout << motion_prob << \"\\t\" << observation_prob << \"\\t\" \n      //     << \"\\t\"  << motion_prob * observation_prob << endl;   \n    } \n        \n    // UNCOMMENT TO SEE THIS STEP OF THE FILTER\n    //cout << \"----------RAW---------------\" << endl;\n    //for (int p = 0; p < posteriors.size(); ++p) {\n    //  cout << posteriors[p] << endl;\n    //}\n\n    /**\n     * TODO: normalize posteriors (see helpers.h for a helper function)\n     */\n    \n\n    // print to stdout\n    //cout << posteriors[t] <<  \"\\t\" << priors[t] << endl;\n\n    // UNCOMMENT TO SEE THIS STEP OF THE FILTER\n    //cout << \"----------NORMALIZED---------------\" << endl;\n\n    /**\n     * TODO: update priors\n     */\n    \n\n    // UNCOMMENT TO SEE THIS STEP OF THE FILTER\n    //for (int p = 0; p < posteriors.size(); ++p) {\n    //  cout << posteriors[p] << endl;\n    //}\n\n    // print posteriors vectors to stdout\n    for (int p = 0; p < posteriors.size(); ++p) {\n            cout << posteriors[p] << endl;  \n    } \n  }\n\n  return 0;\n}\n\n// observation model: calculate likelihood prob term based on landmark proximity\nfloat observation_model(vector<float> landmark_positions, \n                        vector<float> observations, vector<float> pseudo_ranges, \n                        float distance_max, float observation_stdev) {\n  // initialize observation probability\n  float distance_prob = 1.0f;\n\n  // run over current observation vector\n  for (int z=0; z< observations.size(); ++z) {\n    // define min distance\n    float pseudo_range_min;\n        \n    // check, if distance vector exists\n    if (pseudo_ranges.size() > 0) {\n      // set min distance\n      pseudo_range_min = pseudo_ranges[0];\n      // remove this entry from pseudo_ranges-vector\n      pseudo_ranges.erase(pseudo_ranges.begin());\n    } else {  // no or negative distances: set min distance to a large number\n        pseudo_range_min = std::numeric_limits<const float>::infinity();\n    }\n\n    // estimate the probability for observation model, this is our likelihood \n    distance_prob *= Helpers::normpdf(observations[z], pseudo_range_min,\n                                      observation_stdev);\n  }\n\n  return distance_prob;\n}\n\nvector<float> pseudo_range_estimator(vector<float> landmark_positions, \n                                     float pseudo_position) {\n  // define pseudo observation vector\n  vector<float> pseudo_ranges;\n            \n  // loop over number of landmarks and estimate pseudo ranges\n  for (int l=0; l< landmark_positions.size(); ++l) {\n    // estimate pseudo range for each single landmark \n    // and the current state position pose_i:\n    float range_l = landmark_positions[l] - pseudo_position;\n\n    // check if distances are positive: \n    if (range_l > 0.0f) {\n      pseudo_ranges.push_back(range_l);\n    }\n  }\n\n  // sort pseudo range vector\n  sort(pseudo_ranges.begin(), pseudo_ranges.end());\n\n  return pseudo_ranges;\n}\n\n// motion model: calculates prob of being at an estimated position at time t\nfloat motion_model(float pseudo_position, float movement, vector<float> priors,\n                   int map_size, int control_stdev) {\n  // initialize probability\n  float position_prob = 0.0f;\n\n  // loop over state space for all possible positions x (convolution):\n  for (float j=0; j< map_size; ++j) {\n    float next_pseudo_position = j;\n    // distance from i to j\n    float distance_ij = pseudo_position-next_pseudo_position;\n\n    // transition probabilities:\n    float transition_prob = Helpers::normpdf(distance_ij, movement, \n                                             control_stdev);\n    // estimate probability for the motion model, this is our prior\n    position_prob += transition_prob*priors[j];\n  }\n\n  return position_prob;\n}\n\n// initialize priors assuming vehicle at landmark +/- 1.0 meters position stdev\nvector<float> initialize_priors(int map_size, vector<float> landmark_positions,\n                                     float position_stdev) {\n  // set all priors to 0.0\n  vector<float> priors(map_size, 0.0);\n\n  // set each landmark positon +/-1 to 1.0/9.0 (9 possible postions)\n  float norm_term = landmark_positions.size() * (position_stdev * 2 + 1);\n  for (int i=0; i < landmark_positions.size(); ++i) {\n    for (float j=1; j <= position_stdev; ++j) {\n      priors.at(int(j+landmark_positions[i]+map_size)%map_size) += 1.0/norm_term;\n      priors.at(int(-j+landmark_positions[i]+map_size)%map_size) += 1.0/norm_term;\n    }\n    priors.at(landmark_positions[i]) += 1.0/norm_term;\n  }\n\n  return priors;\n}",
                    "name": "main.cpp"
                  },
                  {
                    "text": "//=================================================================================\r\n// Name        : help_functions.h\r\n// Version     : 2.0.0\r\n// Copyright   : Udacity\r\n//=================================================================================\r\n\r\n#ifndef HELP_FUNCTIONS_H_\r\n#define HELP_FUNCTIONS_H_\r\n\r\n#include <math.h>\r\n#include <iostream>\r\n#include <vector>\r\n#include <fstream>\r\n#include <sstream>\r\n#include <iomanip>\r\n\r\nusing namespace std;\r\n\r\nclass Helpers {\r\npublic:\r\n\r\n\t//definition of one over square root of 2*pi:\r\n\tconstexpr static float STATIC_ONE_OVER_SQRT_2PI = 1/sqrt(2*M_PI) ;\r\n\tfloat ONE_OVER_SQRT_2PI = 1/sqrt(2*M_PI) ;\r\n\r\n\t/*****************************************************************************\r\n\t * normpdf(X,mu,sigma) computes the probability function at values x using the\r\n\t * normal distribution with mean mu and standard deviation std. x, mue and \r\n\t * sigma must be scalar! The parameter std must be positive. \r\n\t * The normal pdf is y=f(x;mu,std)= 1/(std*sqrt(2pi)) e[ -(x−mu)^2 / 2*std^2 ]\r\n\t*****************************************************************************/\r\n\tstatic float normpdf(float x, float mu, float std) {\r\n\t    return (STATIC_ONE_OVER_SQRT_2PI/std)*exp(-0.5*pow((x-mu)/std,2));\r\n\t}\r\n\r\n\t//static function to normalize a vector:\r\n\tstatic std::vector<float> normalize_vector(std::vector<float> inputVector){\r\n\r\n\t\t//declare sum:\r\n\t\tfloat sum = 0.0f;\r\n\r\n\t\t//declare and resize output vector:\r\n\t\tstd::vector<float> outputVector ;\r\n\t\toutputVector.resize(inputVector.size());\r\n\r\n\t\t//estimate the sum:\r\n\t\tfor (unsigned int i = 0; i < inputVector.size(); ++i) {\r\n\t\t\tsum += inputVector[i];\r\n\t\t}\r\n\r\n\t\t//normalize with sum:\r\n\t\tfor (unsigned int i = 0; i < inputVector.size(); ++i) {\r\n\t\t\toutputVector[i] = inputVector[i]/sum;\r\n\t\t}\r\n\r\n\t\t//return normalized vector:\r\n\t\treturn outputVector;\r\n\t}\r\n\t\r\n};\r\n\r\n#endif /* HELP_FUNCTIONS_H_ */\r\n",
                    "name": "helpers.h"
                  }
                ]
              },
              "answer": null
            }
          ]
        },
        {
          "id": 467268,
          "key": "a35956aa-f046-4c76-bc8a-8894ec01936c",
          "title": "Solution: Coding the Full Filter",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "a35956aa-f046-4c76-bc8a-8894ec01936c",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 806420,
              "key": "98039e3a-b59b-4dcc-8886-522b71215f68",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Below is one possible implementation of the full filter.",
              "instructor_notes": ""
            },
            {
              "id": 467289,
              "key": "1d2752cf-822c-4882-81f7-985a989de7d4",
              "title": "",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "user_state": {
                "node_key": "1d2752cf-822c-4882-81f7-985a989de7d4",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "instruction": null,
              "question": {
                "title": "",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "6444489024077824",
                "initial_code_files": [
                  {
                    "text": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\n#include \"helpers.h\"\n\nusing std::vector;\nusing std::cout;\nusing std::endl;\n\n\nvector<float> initialize_priors(int map_size, vector<float> landmark_positions,\n                                float position_stdev);\n\nfloat motion_model(float pseudo_position, float movement, vector<float> priors,\n                   int map_size, int control_stdev);\n\n// function to get pseudo ranges\nvector<float> pseudo_range_estimator(vector<float> landmark_positions, \n                                     float pseudo_position);\n\n// observation model: calculate likelihood prob term based on landmark proximity\nfloat observation_model(vector<float> landmark_positions, \n                        vector<float> observations, vector<float> pseudo_ranges,\n                        float distance_max, float observation_stdev);\n\n\nint main() {  \n  // set standard deviation of control\n  float control_stdev = 1.0f;\n\n  // set standard deviation of position\n  float position_stdev = 1.0f;\n\n  // meters vehicle moves per time step\n  float movement_per_timestep = 1.0f;\n\n  // set observation standard deviation\n  float observation_stdev = 1.0f;\n\n  // number of x positions on map\n  int map_size = 25;\n\n  // set distance max\n  float distance_max = map_size;\n\n  // define landmarks\n  vector<float> landmark_positions {3, 9, 14, 23};\n\n  // define observations vector, each inner vector represents a set \n  //   of observations for a time step\n  vector<vector<float> > sensor_obs {{1,7,12,21}, {0,6,11,20}, {5,10,19},\n                                     {4,9,18}, {3,8,17}, {2,7,16}, {1,6,15}, \n                                     {0,5,14}, {4,13}, {3,12}, {2,11}, {1,10},\n                                     {0,9}, {8}, {7}, {6}, {5}, {4}, {3}, {2},\n                                     {1}, {0}, {}, {}, {}};\n\n  // initialize priors\n  vector<float> priors = initialize_priors(map_size, landmark_positions,\n                                           position_stdev);\n  // UNCOMMENT TO SEE THIS STEP OF THE FILTER\n  //cout << \"-----------PRIORS INIT--------------\" << endl;\n  //for (int p = 0; p < priors.size(); ++p){\n  //  cout << priors[p] << endl;\n  //}  \n    \n  /**\n   * TODO: initialize posteriors\n   */\n  vector<float> posteriors(map_size, 0.0);\n\n  // specify time steps\n  int time_steps = sensor_obs.size();\n    \n  // declare observations vector\n  vector<float> observations;\n    \n  // cycle through time steps\n  for (int t = 0; t < time_steps; ++t) {\n    // UNCOMMENT TO SEE THIS STEP OF THE FILTER\n    //cout << \"---------------TIME STEP---------------\" << endl;\n    //cout << \"t = \" << t << endl;\n    //cout << \"-----Motion----------OBS----------------PRODUCT--\" << endl;\n\n    if (!sensor_obs[t].empty()) {\n      observations = sensor_obs[t]; \n    } else {\n      observations = {float(distance_max)};\n    }\n\n    // step through each pseudo position x (i)\n    for (unsigned int i = 0; i < map_size; ++i) {\n      float pseudo_position = float(i);\n\n      /**\n       * TODO: get the motion model probability for each x position\n       */\n      float motion_prob = motion_model(pseudo_position, movement_per_timestep,\n                                       priors, map_size, control_stdev);\n      /**\n       * TODO: get pseudo ranges\n       */\n      vector<float> pseudo_ranges = pseudo_range_estimator(landmark_positions, \n                                                           pseudo_position);\n\n      /**\n       * TODO: get observation probability\n       */\n      float observation_prob = observation_model(landmark_positions, observations, \n                                                 pseudo_ranges, distance_max, \n                                                 observation_stdev);\n\n      /**\n       * TODO: calculate the ith posterior\n       */\n      posteriors[i] = motion_prob * observation_prob;\n\n      // UNCOMMENT TO SEE THIS STEP OF THE FILTER\n      //cout << motion_prob << \"\\t\" << observation_prob << \"\\t\" \n      //     << \"\\t\"  << motion_prob * observation_prob << endl;   \n    } \n        \n    // UNCOMMENT TO SEE THIS STEP OF THE FILTER\n    //cout << \"----------RAW---------------\" << endl;\n    //for (int p = 0; p < posteriors.size(); ++p) {\n    //  cout << posteriors[p] << endl;\n    //}\n\n    /**\n     * TODO: normalize\n     */\n    posteriors = Helpers::normalize_vector(posteriors);\n\n    // print to stdout\n    //cout << posteriors[t] <<  \"\\t\" << priors[t] << endl;\n\n    // UNCOMMENT TO SEE THIS STEP OF THE FILTER\n    //cout << \"----------NORMALIZED---------------\" << endl;\n\n    /**\n     * TODO: update\n     */\n    priors = posteriors;\n\n    // UNCOMMENT TO SEE THIS STEP OF THE FILTER\n    //for (int p = 0; p < posteriors.size(); ++p) {\n    //  cout << posteriors[p] << endl;\n    //}\n\n    // print posteriors vectors to stdout\n    for (int p = 0; p < posteriors.size(); ++p) {\n            cout << posteriors[p] << endl;  \n    } \n  }\n\n  return 0;\n}\n\n// observation model: calculate likelihood prob term based on landmark proximity\nfloat observation_model(vector<float> landmark_positions, \n                        vector<float> observations, vector<float> pseudo_ranges, \n                        float distance_max, float observation_stdev) {\n  // initialize observation probability\n  float distance_prob = 1.0f;\n\n  // run over current observation vector\n  for (int z=0; z< observations.size(); ++z) {\n    // define min distance\n    float pseudo_range_min;\n        \n    // check, if distance vector exists\n    if (pseudo_ranges.size() > 0) {\n      // set min distance\n      pseudo_range_min = pseudo_ranges[0];\n      // remove this entry from pseudo_ranges-vector\n      pseudo_ranges.erase(pseudo_ranges.begin());\n    } else {  // no or negative distances: set min distance to a large number\n        pseudo_range_min = std::numeric_limits<const float>::infinity();\n    }\n\n    // estimate the probability for observation model, this is our likelihood \n    distance_prob *= Helpers::normpdf(observations[z], pseudo_range_min,\n                                      observation_stdev);\n  }\n\n  return distance_prob;\n}\n\nvector<float> pseudo_range_estimator(vector<float> landmark_positions, \n                                     float pseudo_position) {\n  // define pseudo observation vector\n  vector<float> pseudo_ranges;\n            \n  // loop over number of landmarks and estimate pseudo ranges\n  for (int l=0; l< landmark_positions.size(); ++l) {\n    // estimate pseudo range for each single landmark \n    // and the current state position pose_i:\n    float range_l = landmark_positions[l] - pseudo_position;\n\n    // check if distances are positive: \n    if (range_l > 0.0f) {\n      pseudo_ranges.push_back(range_l);\n    }\n  }\n\n  // sort pseudo range vector\n  sort(pseudo_ranges.begin(), pseudo_ranges.end());\n\n  return pseudo_ranges;\n}\n\n// motion model: calculates prob of being at an estimated position at time t\nfloat motion_model(float pseudo_position, float movement, vector<float> priors,\n                   int map_size, int control_stdev) {\n  // initialize probability\n  float position_prob = 0.0f;\n\n  // loop over state space for all possible positions x (convolution):\n  for (float j=0; j< map_size; ++j) {\n    float next_pseudo_position = j;\n    // distance from i to j\n    float distance_ij = pseudo_position-next_pseudo_position;\n\n    // transition probabilities:\n    float transition_prob = Helpers::normpdf(distance_ij, movement, \n                                             control_stdev);\n    // estimate probability for the motion model, this is our prior\n    position_prob += transition_prob*priors[j];\n  }\n\n  return position_prob;\n}\n\n// initialize priors assuming vehicle at landmark +/- 1.0 meters position stdev\nvector<float> initialize_priors(int map_size, vector<float> landmark_positions,\n                                     float position_stdev) {\n  // set all priors to 0.0\n  vector<float> priors(map_size, 0.0);\n\n  // set each landmark positon +/-1 to 1.0/9.0 (9 possible postions)\n  float norm_term = landmark_positions.size() * (position_stdev * 2 + 1);\n  for (int i=0; i < landmark_positions.size(); ++i) {\n    for (float j=1; j <= position_stdev; ++j) {\n      priors.at(int(j+landmark_positions[i]+map_size)%map_size) += 1.0/norm_term;\n      priors.at(int(-j+landmark_positions[i]+map_size)%map_size) += 1.0/norm_term;\n    }\n    priors.at(landmark_positions[i]) += 1.0/norm_term;\n  }\n\n  return priors;\n}",
                    "name": "main.cpp"
                  },
                  {
                    "text": "#ifndef HELP_FUNCTIONS_H\n#define HELP_FUNCTIONS_H\n\n#include <math.h>\n#include <vector>\n\nclass Helpers {\n public:\n  // definition of one over square root of 2*pi:\n  constexpr static float STATIC_ONE_OVER_SQRT_2PI = 1/sqrt(2*M_PI);\n\n  /**\n   * normpdf(X,mu,sigma) computes the probability function at values x using the\n   * normal distribution with mean mu and standard deviation std. x, mu and \n   * sigma must be scalar! The parameter std must be positive. \n   * The normal pdf is y=f(x,mu,std)= 1/(std*sqrt(2pi)) e[ -(x−mu)^2 / 2*std^2 ]\n   */\n  static float normpdf(float x, float mu, float std) {\n    return (STATIC_ONE_OVER_SQRT_2PI/std)*exp(-0.5*pow((x-mu)/std,2));\n  }\n\n  // static function to normalize a vector\n  static std::vector<float> normalize_vector(std::vector<float> inputVector) {\n\n    // declare sum \n    float sum = 0.0f;\n\n    // declare and resize output vector\n    std::vector<float> outputVector;\n    outputVector.resize(inputVector.size());\n\n    // estimate the sum\n    for (int i = 0; i < inputVector.size(); ++i) {\n      sum += inputVector[i];\n    }\n\n    // normalize with sum\n    for (int i = 0; i < inputVector.size(); ++i) {\n      outputVector[i] = inputVector[i]/sum;\n    }\n\n    // return normalized vector:\n    return outputVector;\n  }\n};\n\n#endif  // HELP_FUNCTIONS_H",
                    "name": "helpers.h"
                  }
                ]
              },
              "answer": null
            }
          ]
        },
        {
          "id": 279174,
          "key": "63033748-58e5-4117-9693-6ea1b98d4bf8",
          "title": "Conclusion",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "63033748-58e5-4117-9693-6ea1b98d4bf8",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 286330,
              "key": "3e890df1-e6b7-4ded-a251-0147a297d56d",
              "title": "Conclusion",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "3npZxfdrOpY",
                "china_cdn_id": "3npZxfdrOpY.mp4"
              }
            }
          ]
        }
      ]
    }
  },
  "_deprecated": [
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    }
  ]
}