WEBVTT
Kind: captions
Language: zh-CN

00:00:00.530 --> 00:00:04.240
我们来聊聊卷积神经网络或 CovNet

00:00:04.240 --> 00:00:08.220
CovNet 是一种空间上共享参数的神经网络

00:00:09.740 --> 00:00:11.540
想象你有一张图片

00:00:11.539 --> 00:00:13.359
它可以表示为一张薄饼

00:00:14.380 --> 00:00:18.769
它有宽度和高度 且由于通常存在红绿蓝

00:00:18.769 --> 00:00:22.030
三色通道 因此它还具有深度

00:00:22.030 --> 00:00:24.660
在这个实例中 深度为 3

00:00:24.660 --> 00:00:25.239
这是你的输入

00:00:26.359 --> 00:00:29.210
现在假设拿出图片的一小块

00:00:29.210 --> 00:00:33.380
运行一个具有 K 个输出的小神经网络

00:00:33.380 --> 00:00:38.030
像这样把输出表示为垂直的一小列

00:00:38.030 --> 00:00:41.000
在不改变权重的情况下 把这个小神经网络滑过

00:00:41.000 --> 00:00:42.799
整个图片

00:00:42.799 --> 00:00:46.019
就像我们拿着刷子刷墙一样水平垂直地滑动

00:00:47.090 --> 00:00:49.970
在输出端 我们画出一幅新图片

00:00:49.969 --> 00:00:52.829
它的宽度和高度与输入的图片不同

00:00:52.829 --> 00:00:55.559
更重要的是 它的深度跟之前不同

00:00:55.560 --> 00:00:57.780
现在它不只是红绿蓝

00:00:57.780 --> 00:01:01.450
而是得到了 K 个颜色通道

00:01:01.450 --> 00:01:03.920
这种操作叫做卷积

00:01:03.920 --> 00:01:07.350
如果你的块 (patch) 和整张图片一样大

00:01:07.349 --> 00:01:11.159
那它就跟普通的神经网络没有区别

00:01:11.159 --> 00:01:15.799
正由于我们使用了小块 我们在整个空间

00:01:15.799 --> 00:01:17.200
共享较少的权重

00:01:18.390 --> 00:01:22.730
卷积网络基本上是一个深度网络 但我们

00:01:22.730 --> 00:01:27.790
用共享权重的“卷积层”替代了一般的“全连接层”

00:01:29.120 --> 00:01:32.457
总的想法是让它们形成金字塔状

00:01:32.457 --> 00:01:37.739
金字塔底部是一个非常大而浅的图片 仅包括红绿蓝三通道

00:01:38.954 --> 00:01:42.849
通过卷积操作逐渐挤压空间的维度

00:01:42.849 --> 00:01:47.339
同时不断增加深度 使深度信息

00:01:47.340 --> 00:01:50.393
大体上可表示出复杂的语义

00:01:51.650 --> 00:01:54.280
在金字塔顶端 你可以放一个分类器

00:01:54.280 --> 00:01:57.159
所有空间信息都被压缩成一个表示

00:01:57.159 --> 00:02:01.379
仅映射到图片内容的参数被保留

00:02:02.500 --> 00:02:04.228
这就是总体的思想

00:02:04.228 --> 00:02:08.360
如果你想实现它 必须正确实现很多细节

00:02:08.360 --> 00:02:10.285
还要习惯一些神经网络语言

00:02:10.284 --> 00:02:14.009
你已经接触到了块 (Patch) 和深度 (Depth) 的概念

00:02:14.009 --> 00:02:16.879
块有时也叫做核 (Kernel)

00:02:16.879 --> 00:02:20.799
堆栈中的每个薄饼都叫作特征图

00:02:20.800 --> 00:02:25.320
这里 你将三维特征图映射到 K 维特征图

00:02:25.319 --> 00:02:27.849
你需要知道的另一个术语叫步幅 (stride)

00:02:27.849 --> 00:02:29.350
它是当你移动过滤器时平移的

00:02:29.350 --> 00:02:32.020
像素的数量

00:02:32.020 --> 00:02:36.939
步幅为 1 时输出的尺寸和输入大体相同

00:02:36.939 --> 00:02:39.409
步幅为 2 时尺寸为一半

00:02:40.639 --> 00:02:44.786
我说大体 是因为它取决于你在图像边界上

00:02:44.787 --> 00:02:45.280
怎么处理

00:02:45.280 --> 00:02:47.977
要么你从不超过边界

00:02:47.977 --> 00:02:51.370
它通常简称为有效填充 (valid padding)

00:02:51.370 --> 00:02:55.800
要么你在边界外使用 0 填充 这样你会得到和输入图

00:02:55.800 --> 00:03:00.450
相同大小的输出图

00:03:00.449 --> 00:03:03.034
这通常简称为相同填充 (same padding)

