{
  "data": {
    "lesson": {
      "id": 96323,
      "key": "7114284829",
      "title": "Graphs",
      "semantic_type": "Lesson",
      "is_public": true,
      "version": "1.0.0",
      "locale": "en-us",
      "summary": "Examine the theoretical concept of a graph and understand common graph terms, coded representations, properties, traversals, and paths. ",
      "lesson_type": "Classroom",
      "display_workspace_project_only": null,
      "resources": {
        "files": [
          {
            "name": "Videos Zip File",
            "uri": "http://d2uz2655q5g6b2.cloudfront.net/7114284829/96323/1517077474732/Graphs%20Videos.zip"
          },
          {
            "name": "Transcripts Zip File",
            "uri": "http://d2uz2655q5g6b2.cloudfront.net/7114284829/96323/1517077455183/Graphs%20Subtitles.zip"
          }
        ],
        "google_plus_link": null,
        "career_resource_center_link": null,
        "coaching_appointments_link": null,
        "office_hours_link": null,
        "aws_provisioning_link": null
      },
      "project": null,
      "lab": null,
      "concepts": [
        {
          "id": 44981,
          "key": "71226151140923",
          "title": "Graph Introduction",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "71226151140923",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 137819,
              "key": "7122615114",
              "title": "Graph Introduction",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": null,
              "video": {
                "youtube_id": "DFR8F2Q9lgo",
                "china_cdn_id": "DFR8F2Q9lgo.mp4"
              }
            }
          ]
        },
        {
          "id": 60317,
          "key": "77114803260923",
          "title": "What Is a Graph?",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "77114803260923",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 137828,
              "key": "7711480326",
              "title": "What Is a Graph?",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": null,
              "video": {
                "youtube_id": "p-_DFOyEMV8",
                "china_cdn_id": "p-_DFOyEMV8.mp4"
              }
            }
          ]
        },
        {
          "id": 21237,
          "key": "77114803270923",
          "title": "Directions and Cycles",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "77114803270923",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 72758,
              "key": "7711480327",
              "title": "Directions and Cycles",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": null,
              "video": {
                "youtube_id": "lF0vUktQDPo",
                "china_cdn_id": "lF0vUktQDPo.mp4"
              }
            }
          ]
        },
        {
          "id": 62380,
          "key": "77077504350923",
          "title": "Connectivity",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "77077504350923",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 38103,
              "key": "7707750435",
              "title": "Connectivity",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": null,
              "video": {
                "youtube_id": "4x6u2KtNDg4",
                "china_cdn_id": "4x6u2KtNDg4.mp4"
              }
            }
          ]
        },
        {
          "id": 115076,
          "key": "79096072120923",
          "title": "Graph Practice",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "79096072120923",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 69567,
              "key": "7909607212",
              "title": "Graph Practice",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "user_state": {
                "node_key": "7909607212",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "instruction": {
                "video": {
                  "youtube_id": "",
                  "china_cdn_id": ".mp4"
                },
                "text": "Let's discuss a few more definitions that extend on the topics from the last few videos.\n\nTalking about connectivity in a directed graph is a bit more complicated than in an undirected graph. Let's look at some more definitions:\n\n### Disconnected\n\nDisconnected graphs are very similar whether the graph's directed or undirected—there is some vertex or group of vertices that have no connection with the rest of the graph.\n\n### Weakly Connected\n\nA directed graph is weakly connected when only replacing all of the directed edges with undirected edges can cause it to be connected. Imagine that your graph has several vertices with one outbound edge, meaning an edge that points from it to some other vertex in the graph. There's no way to reach all of those vertices from any other vertex in the graph, but if those edges were changed to be undirected all vertices would be easily accessible. \n\n### Connected\n\nHere we only use \"connected graph\" to refer to undirected graphs. In a connected graph, there is some path between one vertex and every other vertex.\n\n### Strongly Connected\n\nStrongly connected directed graphs must have a path from every node and every other node. So, there must be a path from A to B **AND** B to A."
              },
              "question": {
                "title": "Graph Quiz",
                "alt_text": null,
                "background_image": "//lh3.googleusercontent.com/Vyu9xMheuMD83KdyggGOVqCAs95HCZ3HDU2odJ6sd21LTbL-OL2-odieL1GUXD_Zrqk45kmdZ4eqZjcCuqY=s0#w=1920&h=1080",
                "non_google_background_image": "https://s3.cn-north-1.amazonaws.com.cn/u-img/7909607212",
                "semantic_type": "ImageFormQuestion",
                "evaluation_id": "7919804788",
                "widgets": [
                  {
                    "group": null,
                    "initial_value": "",
                    "label": null,
                    "marker": "text1",
                    "model": "TextInputWidget",
                    "is_text_area": false,
                    "tabindex": null,
                    "placement": {
                      "height": 0.07095343680709534,
                      "width": 0.45261845386533667,
                      "x": 0.5070137157107232,
                      "y": 0.42807649667405767
                    }
                  },
                  {
                    "group": null,
                    "initial_value": "",
                    "label": null,
                    "marker": "text2",
                    "model": "TextInputWidget",
                    "is_text_area": false,
                    "tabindex": null,
                    "placement": {
                      "height": 0.07095343680709534,
                      "width": 0.45261845386533667,
                      "x": 0.5031366895261845,
                      "y": 0.7734894678492239
                    }
                  }
                ]
              },
              "answer": {
                "text": "Let's take a look at that image again:\n\n![Graph Quiz Image](https://lh3.googleusercontent.com/5gl2J73khhHQAERWImk7Y-GBP8onqRMMF5wIztkfj_8l8iT70qfBNIgUuaqS6Zoz1qUreJZA6PIMadm5ACc=s0#w=1920&h=1080)\n\nFirst, let's count the cycles:\n\n* G->R->A->P->H->G\n* R->A->P->R\n* R->A->P->S->R\n\nNow, let's talk connectivity. There's one vertex, U, that has only inbound edges—meaning only edges that point to it. Thus, the graph can't be strongly connected. Even if every vertex has a path to U, it doesn't have a path to any of them. \n\nHowever, if you converted every edge to an undirected edge, it would be connected. Therefore we can label this graph \"weakly connected\".",
                "video": {
                  "youtube_id": "",
                  "china_cdn_id": ".mp4"
                }
              }
            }
          ]
        },
        {
          "id": 54096,
          "key": "77360595570923",
          "title": "Graph Representations",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "77360595570923",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 137809,
              "key": "7736059557",
              "title": "Graph Representations",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": null,
              "video": {
                "youtube_id": "uw9u6dtl0WA",
                "china_cdn_id": "uw9u6dtl0WA.mp4"
              }
            }
          ]
        },
        {
          "id": 67962,
          "key": "77052105280923",
          "title": "Adjacency Matrices",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "77052105280923",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 123990,
              "key": "7705210528",
              "title": "Adjacency Matrices",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": null,
              "video": {
                "youtube_id": "FsFhoTALA1c",
                "china_cdn_id": "FsFhoTALA1c.mp4"
              }
            }
          ]
        },
        {
          "id": 31480,
          "key": "79348548570923",
          "title": "Graph Representation Practice",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "79348548570923",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 61430,
              "key": "7934854857",
              "title": "Graph Representation Practice",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "user_state": {
                "node_key": "7934854857",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "instruction": {
                "video": null,
                "text": "You should become comfortable with various graph representations—graphs crop up often in interviews and in computer science in general, and you could need to represent it in any of it's forms. <br>\n\nIn this exercise you'll need to add functions to a `Graph` class to return various representations of the same graph. Your graph will have two different components: `Nodes` and `Edges`. <br>\n\n    class Node(object):\n        def __init__(self, value):\n            self.value = value\n            self.edges = []\n\nNodes are pretty much the same as they were in trees. Instead of having a set number of children, each node has a list of `Edges`. <br>\n\n    class Edge(object):\n        def __init__(self, value, node_from, node_to):\n            self.value = value\n            self.node_from = node_from\n            self.node_to = node_to\n        \nHere, we assume that edges have both a value and a direction. An edge points from one node to another—the node it starts at is the `node_from` and the node it ends at is the `node_to`. You can envision it as `node_from -> node_to`. <br>\n\nThe base of the `Graph` class looks something like this:\n\n    class Graph(object):\n        def __init__(self, nodes=[], edges=[]):\n            self.nodes = nodes\n            self.edges = edges\n        \nA `Graph` class contains a list of nodes and edges. You can sometimes get by with just a list of edges, since edges contain references to the nodes they connect to, or vice versa. However, our `Graph` class is built with both for the following reasons: <br>\n\n* If you're storing a disconnected graph, not every node will be tied to an edge, so you should store a list of nodes.\n* We could probably leave it there, but storing an edge list will make our lives much easier when we're trying to print out different types of graph representations.\n <br>\nUnfortunately, having both makes insertion a bit complicated. We can assume that each value is unique, but we need to be careful about keeping both `nodes` and `edges` updated when either is inserted. You'll also be given these insertion functions to help you out:\n\n        def insert_node(self, new_node_val):\n            new_node = Node(new_node_val)\n            self.nodes.append(new_node)\n\n        def insert_edge(self, new_edge_val, node_from_val, node_to_val):\n            from_found = None\n            to_found = None\n            for node in self.nodes:\n                if node_from_val == node.value:\n                    from_found = node\n                if node_to_val == node.value:\n                    to_found = node\n            if from_found == None:\n                from_found = Node(node_from_val)\n                self.nodes.append(from_found)\n            if to_found == None:\n                to_found = Node(node_to_val)\n                self.nodes.append(to_found)\n            new_edge = Edge(new_edge_val, from_found, to_found)\n            from_found.edges.append(new_edge)\n            to_found.edges.append(new_edge)\n            self.edges.append(new_edge)\n        \nAlright, time to code the rest!"
              },
              "question": {
                "title": "Graph Representation Quiz",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "7943368884",
                "initial_code_files": [
                  {
                    "text": "class Node(object):\n    def __init__(self, value):\n        self.value = value\n        self.edges = []\n\nclass Edge(object):\n    def __init__(self, value, node_from, node_to):\n        self.value = value\n        self.node_from = node_from\n        self.node_to = node_to\n\nclass Graph(object):\n    def __init__(self, nodes=[], edges=[]):\n        self.nodes = nodes\n        self.edges = edges\n\n    def insert_node(self, new_node_val):\n        new_node = Node(new_node_val)\n        self.nodes.append(new_node)\n        \n    def insert_edge(self, new_edge_val, node_from_val, node_to_val):\n        from_found = None\n        to_found = None\n        for node in self.nodes:\n            if node_from_val == node.value:\n                from_found = node\n            if node_to_val == node.value:\n                to_found = node\n        if from_found == None:\n            from_found = Node(node_from_val)\n            self.nodes.append(from_found)\n        if to_found == None:\n            to_found = Node(node_to_val)\n            self.nodes.append(to_found)\n        new_edge = Edge(new_edge_val, from_found, to_found)\n        from_found.edges.append(new_edge)\n        to_found.edges.append(new_edge)\n        self.edges.append(new_edge)\n\n    def get_edge_list(self):\n        \"\"\"Don't return a list of edge objects!\n        Return a list of triples that looks like this:\n        (Edge Value, From Node Value, To Node Value)\"\"\"\n        return []\n\n    def get_adjacency_list(self):\n        \"\"\"Don't return any Node or Edge objects!\n        You'll return a list of lists.\n        The indecies of the outer list represent\n        \"from\" nodes.\n        Each section in the list will store a list\n        of tuples that looks like this:\n        (To Node, Edge Value)\"\"\"\n        return []\n    \n    def get_adjacency_matrix(self):\n        \"\"\"Return a matrix, or 2D list.\n        Row numbers represent from nodes,\n        column numbers represent to nodes.\n        Store the edge values in each spot,\n        and a 0 if no edge exists.\"\"\"\n        return []\n\ngraph = Graph()\ngraph.insert_edge(100, 1, 2)\ngraph.insert_edge(101, 1, 3)\ngraph.insert_edge(102, 1, 4)\ngraph.insert_edge(103, 3, 4)\n# Should be [(100, 1, 2), (101, 1, 3), (102, 1, 4), (103, 3, 4)]\nprint graph.get_edge_list()\n# Should be [None, [(2, 100), (3, 101), (4, 102)], None, [(4, 103)], None]\nprint graph.get_adjacency_list()\n# Should be [[0, 0, 0, 0, 0], [0, 0, 100, 101, 102], [0, 0, 0, 0, 0], [0, 0, 0, 0, 103], [0, 0, 0, 0, 0]]\nprint graph.get_adjacency_matrix()",
                    "name": "graph_representation.py"
                  }
                ]
              },
              "answer": {
                "text": "Here's the solution:\n\n    def get_edge_list(self):\n        edge_list = []\n        for edge_object in self.edges:\n            edge = (edge_object.value, edge_object.node_from.value, edge_object.node_to.value)\n            edge_list.append(edge)\n        return edge_list\n\n    def get_adjacency_list(self):\n        max_index = self.find_max_index()\n        adjacency_list = [None] * (max_index + 1)\n        for edge_object in self.edges:\n            if adjacency_list[edge_object.node_from.value]:\n                adjacency_list[edge_object.node_from.value].append((edge_object.node_to.value, edge_object.value))\n            else:\n                adjacency_list[edge_object.node_from.value] = [(edge_object.node_to.value, edge_object.value)]\n        return adjacency_list\n\n    def get_adjacency_matrix(self):\n        max_index = self.find_max_index()\n        adjacency_matrix = [[0 for i in range(max_index + 1)] for j in range(max_index + 1)]\n        for edge_object in self.edges:\n            adjacency_matrix[edge_object.node_from.value][edge_object.node_to.value] = edge_object.value\n        return adjacency_matrix\n\n    def find_max_index(self):\n        max_index = -1\n        if len(self.nodes):\n            for node in self.nodes:\n                if node.value > max_index:\n                    max_index = node.value\n        return max_index",
                "video": null
              }
            }
          ]
        },
        {
          "id": 115091,
          "key": "77073603670923",
          "title": "Graph Traversal",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "77073603670923",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 21775,
              "key": "7707360367",
              "title": "Graph Traversal",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": null,
              "video": {
                "youtube_id": "Dkt-XxHZaZE",
                "china_cdn_id": "Dkt-XxHZaZE.mp4"
              }
            }
          ]
        },
        {
          "id": 59057,
          "key": "77366995150923",
          "title": "DFS",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "77366995150923",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 21780,
              "key": "7736699515",
              "title": "DFS",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": null,
              "video": {
                "youtube_id": "BC8jEidd2EQ",
                "china_cdn_id": "BC8jEidd2EQ.mp4"
              }
            }
          ]
        },
        {
          "id": 13207,
          "key": "77058503840923",
          "title": "BFS",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "77058503840923",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 137801,
              "key": "7705850384",
              "title": "BFS",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": null,
              "video": {
                "youtube_id": "pol4kGNlvJA",
                "china_cdn_id": "pol4kGNlvJA.mp4"
              }
            }
          ]
        },
        {
          "id": 123714,
          "key": "93630ecc-7369-4ffa-8db7-e988dd290927",
          "title": "Graph Traversal Practice",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "93630ecc-7369-4ffa-8db7-e988dd290927",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 122263,
              "key": "7966803467",
              "title": "Graph Traversal Practice",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "user_state": {
                "node_key": "7966803467",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "instruction": {
                "video": {
                  "youtube_id": "",
                  "china_cdn_id": ".mp4"
                },
                "text": "The basic graph traversals show up a lot, particularly in more complicated graph-based algorithms. It's important to make sure you have a mastery before moving on!\n\nStart out by playing with [this DFS](https://www.cs.usfca.edu/~galles/visualization/DFS.html) and [this BFS](https://www.cs.usfca.edu/~galles/visualization/BFS.html) visualization until the search algorithms feel intuitive to you.\n\nNext, you'll practice writing code to do these searches in Python. We'll have the same base that we started with in the last quiz, with one exception—the Node class now has a visited flag that we can use during the traversals. Write a recursive solution for DFS and an iterative solution for BFS."
              },
              "question": {
                "title": "Graph Traversal Quiz",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "7961361490",
                "initial_code_files": [
                  {
                    "text": "class Node(object):\n    def __init__(self, value):\n        self.value = value\n        self.edges = []\n        self.visited = False\n\nclass Edge(object):\n    def __init__(self, value, node_from, node_to):\n        self.value = value\n        self.node_from = node_from\n        self.node_to = node_to\n\n# You only need to change code with docs strings that have TODO.\n# Specifically: Graph.dfs_helper and Graph.bfs\n# New methods have been added to associate node numbers with names\n# Specifically: Graph.set_node_names\n# and the methods ending in \"_names\" which will print names instead\n# of node numbers\n\nclass Graph(object):\n    def __init__(self, nodes=None, edges=None):\n        self.nodes = nodes or []\n        self.edges = edges or []\n        self.node_names = []\n        self._node_map = {}\n\n    def set_node_names(self, names):\n        \"\"\"The Nth name in names should correspond to node number N.\n        Node numbers are 0 based (starting at 0).\n        \"\"\"\n        self.node_names = list(names)\n\n    def insert_node(self, new_node_val):\n        \"Insert a new node with value new_node_val\"\n        new_node = Node(new_node_val)\n        self.nodes.append(new_node)\n        self._node_map[new_node_val] = new_node\n        return new_node\n\n    def insert_edge(self, new_edge_val, node_from_val, node_to_val):\n        \"Insert a new edge, creating new nodes if necessary\"\n        nodes = {node_from_val: None, node_to_val: None}\n        for node in self.nodes:\n            if node.value in nodes:\n                nodes[node.value] = node\n                if all(nodes.values()):\n                    break\n        for node_val in nodes:\n            nodes[node_val] = nodes[node_val] or self.insert_node(node_val)\n        node_from = nodes[node_from_val]\n        node_to = nodes[node_to_val]\n        new_edge = Edge(new_edge_val, node_from, node_to)\n        node_from.edges.append(new_edge)\n        node_to.edges.append(new_edge)\n        self.edges.append(new_edge)\n\n    def get_edge_list(self):\n        \"\"\"Return a list of triples that looks like this:\n        (Edge Value, From Node, To Node)\"\"\"\n        return [(e.value, e.node_from.value, e.node_to.value)\n                for e in self.edges]\n\n    def get_edge_list_names(self):\n        \"\"\"Return a list of triples that looks like this:\n        (Edge Value, From Node Name, To Node Name)\"\"\"\n        return [(edge.value,\n                 self.node_names[edge.node_from.value],\n                 self.node_names[edge.node_to.value])\n                for edge in self.edges]\n\n    def get_adjacency_list(self):\n        \"\"\"Return a list of lists.\n        The indecies of the outer list represent \"from\" nodes.\n        Each section in the list will store a list\n        of tuples that looks like this:\n        (To Node, Edge Value)\"\"\"\n        max_index = self.find_max_index()\n        adjacency_list = [[] for _ in range(max_index)]\n        for edg in self.edges:\n            from_value, to_value = edg.node_from.value, edg.node_to.value\n            adjacency_list[from_value].append((to_value, edg.value))\n        return [a or None for a in adjacency_list] # replace []'s with None\n\n    def get_adjacency_list_names(self):\n        \"\"\"Each section in the list will store a list\n        of tuples that looks like this:\n        (To Node Name, Edge Value).\n        Node names should come from the names set\n        with set_node_names.\"\"\"\n        adjacency_list = self.get_adjacency_list()\n        def convert_to_names(pair, graph=self):\n            node_number, value = pair\n            return (graph.node_names[node_number], value)\n        def map_conversion(adjacency_list_for_node):\n            if adjacency_list_for_node is None:\n                return None\n            return map(convert_to_names, adjacency_list_for_node)\n        return [map_conversion(adjacency_list_for_node)\n                for adjacency_list_for_node in adjacency_list]\n\n    def get_adjacency_matrix(self):\n        \"\"\"Return a matrix, or 2D list.\n        Row numbers represent from nodes,\n        column numbers represent to nodes.\n        Store the edge values in each spot,\n        and a 0 if no edge exists.\"\"\"\n        max_index = self.find_max_index()\n        adjacency_matrix = [[0] * (max_index) for _ in range(max_index)]\n        for edg in self.edges:\n            from_index, to_index = edg.node_from.value, edg.node_to.value\n            adjacency_matrix[from_index][to_index] = edg.value\n        return adjacency_matrix\n\n    def find_max_index(self):\n        \"\"\"Return the highest found node number\n        Or the length of the node names if set with set_node_names().\"\"\"\n        if len(self.node_names) > 0:\n            return len(self.node_names)\n        max_index = -1\n        if len(self.nodes):\n            for node in self.nodes:\n                if node.value > max_index:\n                    max_index = node.value\n        return max_index\n\n    def find_node(self, node_number):\n        \"Return the node with value node_number or None\"\n        return self._node_map.get(node_number)\n    \n    def _clear_visited(self):\n        for node in self.nodes:\n            node.visited = False\n\n    def dfs_helper(self, start_node):\n        \"\"\"TODO: Write the helper function for a recursive implementation\n        of Depth First Search iterating through a node's edges. The\n        output should be a list of numbers corresponding to the\n        values of the traversed nodes.\n        ARGUMENTS: start_node is the starting Node\n        MODIFIES: the value of the visited property of nodes in self.nodes \n        RETURN: a list of the traversed node values (integers).\n        \"\"\"\n        ret_list = [start_node.value]\n        # Your code here\n        return ret_list\n\n    def dfs(self, start_node_num):\n        \"\"\"Outputs a list of numbers corresponding to the traversed nodes\n        in a Depth First Search.\n        ARGUMENTS: start_node_num is the starting node number (integer)\n        MODIFIES: the value of the visited property of nodes in self.nodes\n        RETURN: a list of the node values (integers).\"\"\"\n        self._clear_visited()\n        start_node = self.find_node(start_node_num)\n        return self.dfs_helper(start_node)\n\n    def dfs_names(self, start_node_num):\n        \"\"\"Return the results of dfs with numbers converted to names.\"\"\"\n        return [self.node_names[num] for num in self.dfs(start_node_num)]\n\n    def bfs(self, start_node_num):\n        \"\"\"TODO: Create an iterative implementation of Breadth First Search\n        iterating through a node's edges. The output should be a list of\n        numbers corresponding to the traversed nodes.\n        ARGUMENTS: start_node_num is the node number (integer)\n        MODIFIES: the value of the visited property of nodes in self.nodes\n        RETURN: a list of the node values (integers).\"\"\"\n        node = self.find_node(start_node_num)\n        self._clear_visited()\n        ret_list = [node.value]\n        # Your code here\n        return ret_list\n\n    def bfs_names(self, start_node_num):\n        \"\"\"Return the results of bfs with numbers converted to names.\"\"\"\n        return [self.node_names[num] for num in self.bfs(start_node_num)]\n\ngraph = Graph()\n\n# You do not need to change anything below this line.\n# You only need to implement Graph.dfs_helper and Graph.bfs\n\ngraph.set_node_names(('Mountain View',   # 0\n                      'San Francisco',   # 1\n                      'London',          # 2\n                      'Shanghai',        # 3\n                      'Berlin',          # 4\n                      'Sao Paolo',       # 5\n                      'Bangalore'))      # 6 \n\ngraph.insert_edge(51, 0, 1)     # MV <-> SF\ngraph.insert_edge(51, 1, 0)     # SF <-> MV\ngraph.insert_edge(9950, 0, 3)   # MV <-> Shanghai\ngraph.insert_edge(9950, 3, 0)   # Shanghai <-> MV\ngraph.insert_edge(10375, 0, 5)  # MV <-> Sao Paolo\ngraph.insert_edge(10375, 5, 0)  # Sao Paolo <-> MV\ngraph.insert_edge(9900, 1, 3)   # SF <-> Shanghai\ngraph.insert_edge(9900, 3, 1)   # Shanghai <-> SF\ngraph.insert_edge(9130, 1, 4)   # SF <-> Berlin\ngraph.insert_edge(9130, 4, 1)   # Berlin <-> SF\ngraph.insert_edge(9217, 2, 3)   # London <-> Shanghai\ngraph.insert_edge(9217, 3, 2)   # Shanghai <-> London\ngraph.insert_edge(932, 2, 4)    # London <-> Berlin\ngraph.insert_edge(932, 4, 2)    # Berlin <-> London\ngraph.insert_edge(9471, 2, 5)   # London <-> Sao Paolo\ngraph.insert_edge(9471, 5, 2)   # Sao Paolo <-> London\n# (6) 'Bangalore' is intentionally disconnected (no edges)\n# for this problem and should produce None in the\n# Adjacency List, etc.\n\nimport pprint\npp = pprint.PrettyPrinter(indent=2)\n\nprint \"Edge List\"\npp.pprint(graph.get_edge_list_names())\n\nprint \"\\nAdjacency List\"\npp.pprint(graph.get_adjacency_list_names())\n\nprint \"\\nAdjacency Matrix\"\npp.pprint(graph.get_adjacency_matrix())\n\nprint \"\\nDepth First Search\"\npp.pprint(graph.dfs_names(2))\n\n# Should print:\n# Depth First Search\n# ['London', 'Shanghai', 'Mountain View', 'San Francisco', 'Berlin', 'Sao Paolo']\n\nprint \"\\nBreadth First Search\"\npp.pprint(graph.bfs_names(2))\n# test error reporting\n# pp.pprint(['Sao Paolo', 'Mountain View', 'San Francisco', 'London', 'Shanghai', 'Berlin'])\n\n# Should print:\n# Breadth First Search\n# ['London', 'Shanghai', 'Berlin', 'Sao Paolo', 'Mountain View', 'San Francisco']",
                    "name": "graph_traversal.py"
                  }
                ]
              },
              "answer": {
                "text": "Here is the answer code:\n\n    class Graph(object):\n\n        def dfs_helper(self, start_node):\n            \"\"\"The helper function for a recursive implementation\n            of Depth First Search iterating through a node's edges. The\n            output should be a list of numbers corresponding to the\n            values of the traversed nodes.\n            ARGUMENTS: start_node is the starting Node\n            REQUIRES: self._clear_visited() to be called before\n            MODIFIES: the value of the visited property of nodes in self.nodes \n            RETURN: a list of the traversed node values (integers).\n            \"\"\"\n            ret_list = [start_node.value]\n            start_node.visited = True\n            edges_out = [e for e in start_node.edges\n                         if e.node_to.value != start_node.value]\n            for edge in edges_out:\n                if not edge.node_to.visited:\n                    ret_list.extend(self.dfs_helper(edge.node_to))\n            return ret_list\n\n        def bfs(self, start_node_num):\n            \"\"\"An iterative implementation of Breadth First Search\n            iterating through a node's edges. The output should be a list of\n            numbers corresponding to the traversed nodes.\n            ARGUMENTS: start_node_num is the node number (integer)\n            MODIFIES: the value of the visited property of nodes in self.nodes\n            RETURN: a list of the node values (integers).\"\"\"\n            node = self.find_node(start_node_num)\n            self._clear_visited()\n            ret_list = []\n            # Your code here\n            queue = [node]\n            node.visited = True\n            def enqueue(n, q=queue):\n                n.visited = True\n                q.append(n)\n            def unvisited_outgoing_edge(n, e):\n                return ((e.node_from.value == n.value) and\n                        (not e.node_to.visited))\n            while queue:\n                node = queue.pop(0)\n                ret_list.append(node.value)\n                for e in node.edges:\n                    if unvisited_outgoing_edge(node, e):\n                        enqueue(e.node_to)\n            return ret_list",
                "video": {
                  "youtube_id": "",
                  "china_cdn_id": ".mp4"
                }
              }
            }
          ]
        },
        {
          "id": 72875,
          "key": "77117407800923",
          "title": "Eulerian Path",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "77117407800923",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 137786,
              "key": "7711740780",
              "title": "Eulerian Path",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": null,
              "video": {
                "youtube_id": "zS34kHSo7fs",
                "china_cdn_id": "zS34kHSo7fs.mp4"
              }
            }
          ]
        }
      ]
    }
  },
  "_deprecated": [
    {
      "name": "non_google_background_image",
      "reason": "(2016/8/18) Not sure, ask i18n team for alternative"
    }
  ]
}