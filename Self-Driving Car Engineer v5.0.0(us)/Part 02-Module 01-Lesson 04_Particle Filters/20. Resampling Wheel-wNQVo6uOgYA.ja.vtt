WEBVTT
Kind: captions
Language: ja

00:00:00.000 --> 00:00:03.000
これが効率的にするアイデアの1つで

00:00:03.000 --> 00:00:06.000
よりよいサンプルを
実験的に与えてくれることも分かります

00:00:06.000 --> 00:00:10.450
すべての粒子と重要度重みを
大きな輪で表しましょう

00:00:11.040 --> 00:00:16.309
各粒子がその重要度重みに相当する
1つのスペースを占めます

00:00:18.000 --> 00:00:24.000
W5のような重さが大きい粒子は
より多くのスペースを占めます

00:00:24.000 --> 00:00:29.000
一方で重みが小さい粒子は
さらに小さなスペースを占めます

00:00:29.000 --> 00:00:33.530
まず最初にすべてのインデックスから均等に

00:00:33.530 --> 00:00:35.360
粒子のインデックスを推測します

00:00:35.360 --> 00:00:38.370
1からNの個々の選択肢から

00:00:38.370 --> 00:00:43.170
Uの均一なサンプルであることに気づきました

00:00:43.170 --> 00:00:47.680
Pythonでは0からN－1であることに注意します

00:00:49.000 --> 00:00:52.000
W6を選ぶとします

00:00:52.000 --> 00:00:55.000
これで関数を上手に構築できるようになるでしょう

00:00:55.000 --> 00:01:01.000
そして0を初期化して粒子を構築する時に

00:01:01.000 --> 00:01:08.000
この0と2×最大重みWの間に位置する
均一に抽出された連続値を加えます

00:01:08.000 --> 00:01:12.670
重要度の集合において重さが一番大きいものです

00:01:13.800 --> 00:01:15.800
W5は最も大きいので

00:01:15.800 --> 00:01:21.000
W5の2倍の乱数を加えます

00:01:21.000 --> 00:01:26.000
加えた値はこの位置まで導いてくれます

00:01:26.000 --> 00:01:29.000
これが実際に抽出した値で

00:01:29.000 --> 00:01:33.000
初期化を示す6番目の粒子から観測されます

00:01:33.000 --> 00:01:36.000
そして次のループを繰り返します

00:01:36.000 --> 00:01:39.790
この粒子の重要度重みが

00:01:39.790 --> 00:01:43.000
βに到達するのに足りないとします

00:01:43.000 --> 00:01:47.200
インデックスWがβほど大きくない場合は

00:01:47.200 --> 00:01:51.040
βからこのWの値を引いて

00:01:51.040 --> 00:01:55.000
1だけ増加させます

00:01:55.000 --> 00:01:59.000
これでインデックスをここに動かしました

00:01:59.000 --> 00:02:01.820
βのこの部分を取り除いたので

00:02:01.820 --> 00:02:04.820
位置は前と同じままです

00:02:05.890 --> 00:02:10.000
これでβがインデックスWよりも
小さくなる位置に到達しました

00:02:10.000 --> 00:02:12.000
次の状況における場合でインデックス＝７です

00:02:12.760 --> 00:02:19.900
インデックスは再サンプリングステップで選んだ
粒子のものです

00:02:20.000 --> 00:02:26.210
粒子インデックスを選んだら
別の均一な値をβに加えます

00:02:26.210 --> 00:02:30.000
ここでβの前回の値を加えます

00:02:30.000 --> 00:02:34.000
同じ繰り返しによってインデックスが増え

00:02:34.000 --> 00:02:40.000
W7のこの部分すべてにおいてβが減ります

00:02:40.000 --> 00:02:44.000
そしてジャンプして粒子1が選ばれるのです

00:02:44.000 --> 00:02:46.530
均一の値がとても小さいので

00:02:47.000 --> 00:02:52.000
同じ粒子が
2度選ばれるということがよく起こります

00:02:52.000 --> 00:02:56.000
各粒子は全外周に比例して選ばれ

00:02:56.000 --> 00:02:59.000
この粒子の輪の中まで及びます

00:02:59.000 --> 00:03:04.000
これが再サンプリングステップの基本的な実装です

00:03:04.000 --> 00:03:10.020
もし可能ならPythonで
特定の再サンプリングを実装してみてください

