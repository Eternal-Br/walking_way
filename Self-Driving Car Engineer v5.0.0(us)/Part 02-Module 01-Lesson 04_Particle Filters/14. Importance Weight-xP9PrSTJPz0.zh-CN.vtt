WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:04.000
我来解释后半部分是什么原理

00:00:04.000 --> 00:00:06.000
假设这里有一个真的机器人

00:00:06.000 --> 00:00:10.000
它测量了距离这边的几个地标的准确距离

00:00:10.000 --> 00:00:13.000
很显然 存在一些测量噪

00:00:13.000 --> 00:00:16.000
大概呈高斯分布 均值为 0

00:00:16.000 --> 00:00:20.000
这表示 测量的距离可能会稍长或稍短一些

00:00:20.000 --> 00:00:23.000
这个概率受高斯分布影响

00:00:23.000 --> 00:00:26.000
因此 这个过程可以得到一个测量向量 包括 4 个值

00:00:26.000 --> 00:00:30.000
即距离地标 L1 到 L4 的 4 个距离

00:00:30.000 --> 00:00:33.000
现在 我们看一个粒子 假设机器人坐标

00:00:33.000 --> 00:00:39.000
在这里 不在这里 同时假设移动方向不同

00:00:39.000 --> 00:00:44.000
我们可以取测量向量 将其应用到这个粒子

00:00:44.000 --> 00:00:46.000
很显然 对于这里的这个特定粒子

00:00:46.000 --> 00:00:49.000
这个测量向量很差

00:00:49.000 --> 00:00:54.000
注意 我们所期待的测量向量应该是这样的

00:00:54.000 --> 00:00:57.000
因此 这个特定位置的确定性很低

00:00:57.000 --> 00:01:01.000
实际上 粒子距离正确位置越近

00:01:01.000 --> 00:01:06.000
在该位置的测量值组的确定性就更高

00:01:06.000 --> 00:01:09.000
接下来是粒子滤波器的重要部分：

00:01:09.000 --> 00:01:13.000
实际测量值和预测测量值之间的不匹配

00:01:13.000 --> 00:01:17.000
会产生重要性权重

00:01:17.000 --> 00:01:22.000
该权重告诉我们某个特定粒子的重要性

00:01:22.000 --> 00:01:25.000
权重越大 重要性越高

00:01:25.000 --> 00:01:29.000
现在 我们有很多不同粒子 以及一个特定的测量值

00:01:29.000 --> 00:01:32.000
每个粒子权重都不同

00:01:32.000 --> 00:01:36.000
有些看起来可能性很高 其他可能看起来可能性很低

00:01:36.000 --> 00:01:39.000
根据这里的圆圈大小可以看出来

00:01:39.000 --> 00:01:43.000
现在 我们随机让这些粒子存活

00:01:43.000 --> 00:01:48.000
但存活概率和它们的权重成正比

00:01:48.000 --> 00:01:51.000
如果某个粒子权重很大 比如这里这个

00:01:51.000 --> 00:01:53.000
那么它存活的概率会超出

00:01:53.000 --> 00:01:56.000
权重很小的粒子 比如这里这个

00:01:56.000 --> 00:01:59.000
这意味着 在重采样之后

00:01:59.000 --> 00:02:04.000
重采样是个技术术语 是指从旧粒子中随机

00:02:04.000 --> 00:02:08.000
抽取 N 个新粒子 同时根据重要性权重

00:02:08.000 --> 00:02:11.000
进行替换

00:02:11.000 --> 00:02:13.000
重采样环节后

00:02:13.000 --> 00:02:17.000
这里的粒子很可能会继续存活 几率会高很多很多倍

00:02:17.000 --> 00:02:20.000
而这里的粒子 很可能会被淘汰

00:02:20.000 --> 00:02:24.000
在刚开始的电影里 我们在看走廊环境中的定位时

00:02:24.000 --> 00:02:27.000
所发生的就是这种情况

00:02:27.000 --> 00:02:30.000
和传感器测量非常一致的粒子

00:02:30.000 --> 00:02:34.000
存活率更高 而重要性权重较低的粒子

00:02:34.000 --> 00:02:36.000
一般会被淘汰

00:02:36.000 --> 00:02:39.000
这样 我们就知道了 粒子聚集在

00:02:39.000 --> 00:02:42.000
后验概率比较高的区域附近

00:02:42.000 --> 00:02:45.000
这非常酷 我们只需要

00:02:45.000 --> 00:02:48.000
实现一个方法 设置重要性权重即可

00:02:48.000 --> 00:02:51.000
当然 这个权重是和测量值的可能性相关的

00:02:51.000 --> 00:02:54.000
而且我们必须实现重采样方法

00:02:54.000 --> 00:02:58.000
根据权重的高低抓取这些粒子

00:02:58.000 --> 00:03:01.000
我们试试看

00:03:01.000 --> 00:03:04.000
我把机器人代码加回来

00:03:04.000 --> 00:03:07.000
我们构建一个机器人 让他运动

00:03:07.000 --> 00:03:13.000
现在 我们使用感应函数得到了这个机器人的传感器测量数据

00:03:13.000 --> 00:03:15.000
我们把它打印出来

00:03:15.000 --> 00:03:20.000
这些是距离 4 个地标的距离

00:03:20.000 --> 00:03:23.000
添加 print myrobot 语句后

00:03:23.000 --> 00:03:27.000
你还能计算出权重重要性为 33、48、0.5

00:03:27.000 --> 00:03:30.000
很显然 这是随机输出

00:03:30.000 --> 00:03:34.000
因为机器人位置是随机初始化的

00:03:34.000 --> 00:03:38.000
你现在需要做的是 通过编程 实现一种方法 为这里

00:03:38.000 --> 00:03:40.000
每个粒子分配重要性权重

00:03:40.000 --> 00:03:44.000
你需要制作一个包括 1000 个元素的列表

00:03:44.000 --> 00:03:48.000
里面每个元素都包括一个数字

00:03:48.000 --> 00:03:54.000
这个数字和粒子的重要性成正比

00:03:54.000 --> 00:04:00.000
为简便起见 我在 robot 类里替你编写了一个函数

00:04:00.000 --> 00:04:02.000
叫做 measurement_prob 测量值概率

00:04:02.000 --> 00:04:06.000
这个函数只接受一个参数 测量向量

00:04:06.000 --> 00:04:11.000
定义的 Z 边 计算并输出

00:04:11.000 --> 00:04:16.000
这个测量值的可能性 它还有效地利用高斯分布

00:04:16.000 --> 00:04:19.000
测量预测的测量值和

00:04:19.000 --> 00:04:22.000
实际测量值之间的偏差

00:04:22.000 --> 00:04:25.000
你可以仔细研究这段代码 了解其原理

00:04:25.000 --> 00:04:28.000
要让这段代码运行 我们还要做最后的修改

00:04:28.000 --> 00:04:31.000
我们必须假设存在测量噪

00:04:31.000 --> 00:04:36.000
如果没有测量噪这个函数的除数将会是 0

00:04:36.000 --> 00:04:41.000
现在 我们输入一个语句 声明我们相信的测量噪值

00:04:41.000 --> 00:04:44.000
我来添加噪不加到机器人上

00:04:44.000 --> 00:04:46.000
加到粒子上

00:04:46.000 --> 00:04:51.000
在这里的这行代码中 我们第一次创建了粒子

00:04:51.000 --> 00:04:54.000
我刚刚初始化 这些位置还是数字

00:04:54.000 --> 00:04:58.000
再假设每个粒子都存在一定的噪

00:04:58.000 --> 00:05:02.000
例如平移噪0.05 径向噪0.05

00:05:02.000 --> 00:05:06.000
测量噪5.0

00:05:06.000 --> 00:05:09.000
这里这个是关键数字

00:05:09.000 --> 00:05:11.000
回到你的任务上

00:05:11.000 --> 00:05:15.000
你需要在 W 中制作一个包括 1000 个元素的列表

00:05:15.000 --> 00:05:24.000
让这个向量中的每个数字都反映

00:05:24.000 --> 00:05:27.000
measurement_prob 这个函数应用到测量值 Z 的输出

00:05:27.000 --> 00:05:33.000
Z 是我们从机器人收到的值 这样 我点击 print W 时

00:05:33.000 --> 99:59:59.999
就会得到一个包括 1000 个重要性权重的列表

