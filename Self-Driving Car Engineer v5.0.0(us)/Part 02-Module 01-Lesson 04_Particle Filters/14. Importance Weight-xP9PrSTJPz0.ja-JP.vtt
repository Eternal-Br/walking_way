WEBVTT
Kind: captions
Language: ja-JP

00:00:00.000 --> 00:00:04.000
これから後半について説明します

00:00:04.000 --> 00:00:06.000
ここに実際のロボットがいるとします

00:00:06.000 --> 00:00:10.000
そしてロボットはランドマークまでの正確な距離を測定します

00:00:10.000 --> 00:00:13.000
明らかに測定ノイズもありますが

00:00:13.000 --> 00:00:16.000
モデルを追加されたゼロ平均のガウス分布として渡します

00:00:16.000 --> 00:00:20.000
つまり観測の距離が短すぎるか長すぎてしまう可能性があり

00:00:20.000 --> 00:00:23.000
その確率はガウス分布によって左右されます

00:00:23.000 --> 00:00:26.000
このプロセスでは ランドマーク L1 から L4 までの

00:00:26.000 --> 00:00:30.000
4 つの距離の 4 つの値の測定ベクトルを得ます

00:00:30.000 --> 00:00:33.000
ではロボットは中央ではなく右側にいて右ではなく右上に移動する

00:00:33.000 --> 00:00:39.000
と仮定した時のパーティクルを考えてみましょう

00:00:39.000 --> 00:00:44.000
測定ベクトルを取得でき、それをこのパーティクルに適用できます

00:00:44.000 --> 00:00:46.000
明らかにこれは ここの特定のパーティクルには

00:00:46.000 --> 00:00:49.000
不十分な測定ベクトルになります

00:00:49.000 --> 00:00:54.000
特に測定ベクトルは緑線のようになると予想したでしょう

00:00:54.000 --> 00:00:57.000
その場合この場所ではないという可能性が高くなります

00:00:57.000 --> 00:01:01.000
実際パーティクルが正しい位置に近づくほど

00:01:01.000 --> 00:01:06.000
測定の集合はその位置を得られる可能性が高くなります

00:01:06.000 --> 00:01:09.000
ここにパーティクルフィルターの大きなトリックがあります

00:01:09.000 --> 00:01:13.000
実際の測定と予想された測定の食い違いは

00:01:13.000 --> 00:01:17.000
いわゆる重要性の重みにつながります

00:01:17.000 --> 00:01:22.000
これは特定のパーティクルの重要度を示します

00:01:22.000 --> 00:01:25.000
重みが大きくなればなるほど重要性も高くなります

00:01:25.000 --> 00:01:29.000
今度は 非常に多くの異なったパーティクルと特定の測定ベクトルがあるとします

00:01:29.000 --> 00:01:32.000
各パーティクルはそれぞれ異なる重みを持ちます

00:01:32.000 --> 00:01:36.000
可能性が非常に高く見えるものや 非常に低く見えるものがあります

00:01:36.000 --> 00:01:39.000
これは丸の大きさで示されています

00:01:39.000 --> 00:01:43.000
これらのパーティクルをランダムに残しますが

00:01:43.000 --> 00:01:48.000
残る確率はそれらの重みに比例します

00:01:48.000 --> 00:01:51.000
このようにとても大きい重みのあるものは このように重みが

00:01:51.000 --> 00:01:53.000
とても小さいものよりも高い確率で生き残ります

00:01:53.000 --> 00:01:56.000
つまり いわゆる再サンプリング後のことです

00:01:56.000 --> 00:01:59.000
再サンプリングとは技術用語で

00:01:59.000 --> 00:02:04.000
ランダムに N 個の新しいパーティクルを描いて

00:02:04.000 --> 00:02:08.000
重要性の重みに比例して

00:02:08.000 --> 00:02:11.000
古いものと置き換えていくことです

00:02:11.000 --> 00:02:13.000
再サンプリングフェーズの後

00:02:13.000 --> 00:02:17.000
これらは何度も生き残る可能性が高いと言えます

00:02:17.000 --> 00:02:20.000
一方でこれらの小さいものは消えてしまう可能性があります

00:02:20.000 --> 00:02:24.000
これがまさに最初に動画で見た

00:02:24.000 --> 00:02:27.000
廊下でのローカライゼーションで起きたことです

00:02:27.000 --> 00:02:30.000
センサー測定と一致しているパーティクルは

00:02:30.000 --> 00:02:34.000
高い確率で生き残り 重要性の重みが低いものは

00:02:34.000 --> 00:02:36.000
消える傾向がありました

00:02:36.000 --> 00:02:39.000
それによりパーティクルは 高い事後確率の

00:02:39.000 --> 00:02:42.000
区域の周りに集まるということがわかります

00:02:42.000 --> 00:02:45.000
すごいことです 私たちは重要性の重みを設定する方法を

00:02:45.000 --> 00:02:48.000
実装するだけでよいのです これはもちろん

00:02:48.000 --> 00:02:51.000
後でわかるように測定の尤度に関係していて

00:02:51.000 --> 00:02:54.000
これらの重みに比例してパーティクルを捕らえる

00:02:54.000 --> 00:02:58.000
再サンプリングの方法を実装しなければなりません

00:02:58.000 --> 00:03:01.000
早速やってみましょう

00:03:01.000 --> 00:03:04.000
ロボットのコードに戻って追加します

00:03:04.000 --> 00:03:07.000
ロボットを作って ロボットを動かします

00:03:07.000 --> 00:03:13.000
今度は sense 関数を使ってこの特定のロボットにセンサー測定を与えます

00:03:13.000 --> 00:03:15.000
これを出力しましょう

00:03:15.000 --> 00:03:20.000
これは 4 つのランドマークへの範囲または距離です

00:03:20.000 --> 00:03:23.000
そして print myrobot ステートメントを追加すると

00:03:23.000 --> 00:03:27.000
重みの重要性が 33 48 0.5 であることがわかります

00:03:27.000 --> 00:03:30.000
これは明らかにランダムなアウトプットです

00:03:30.000 --> 00:03:34.000
ロボットの位置をランダムに初期化しているからです

00:03:34.000 --> 00:03:38.000
ここで 皆さんにはこれらの各パーティクルに重要性の重みを

00:03:38.000 --> 00:03:40.000
割り当てる方法をプログラムしてもらいます

00:03:40.000 --> 00:03:44.000
1000 個の要素を持つリストを作ってください

00:03:44.000 --> 00:03:48.000
リストの各要素は数字を 1 つ含みます

00:03:48.000 --> 00:03:54.000
この数字は各パーティクルの重要度に比例します

00:03:54.000 --> 00:04:00.000
簡単になるように 皆さんのために measurement_prob

00:04:00.000 --> 00:04:02.000
という関数をクラス Robot にコーディングしておきました

00:04:02.000 --> 00:04:06.000
この関数は単独のパラメーターである 測定した

00:04:06.000 --> 00:04:11.000
ベクターを受け取ります 私は、これを"Z"と定義しました

00:04:11.000 --> 00:04:16.000
出力として測定の尤度を計算します そして ガウス分布を

00:04:16.000 --> 00:04:19.000
効果的に使い 実際の測定と予測した測定が

00:04:19.000 --> 00:04:22.000
どのくらい離れているかを計ります

00:04:22.000 --> 00:04:25.000
このプログラムをよく見ればどうなっているかわかるでしょう

00:04:25.000 --> 00:04:28.000
このプログラムを動かすには もう 1 つ変更しなければなりません

00:04:28.000 --> 00:04:31.000
実際に測定ノイズがあると仮定しなければなりません

00:04:31.000 --> 00:04:36.000
もし測定ノイズがゼロならこの関数はゼロで割ることになります

00:04:36.000 --> 00:04:41.000
では実際の測定ノイズを指定するプログラムを追加しましょう

00:04:41.000 --> 00:04:44.000
これはロボットに対してはなく

00:04:44.000 --> 00:04:46.000
パーティクルに対して行います

00:04:46.000 --> 00:04:51.000
最初にパーティクルを作るこのコードの行で

00:04:51.000 --> 00:04:54.000
これらの位置を数字を残して初期化するだけでなく

00:04:54.000 --> 00:04:58.000
各パーティクルに伴う特定量のノイズを仮定します

00:04:58.000 --> 00:05:02.000
平行運動のノイズは 0.05 回転ノイズも 0.05

00:05:02.000 --> 00:05:06.000
そして測定ノイズは 5.0 とします

00:05:06.000 --> 00:05:09.000
これは極めて重要な数字です

00:05:09.000 --> 00:05:11.000
皆さんにやってもらうことに戻りますが

00:05:11.000 --> 00:05:15.000
1000 個の要素を持つリスト W を作り

00:05:15.000 --> 00:05:24.000
このベクトルの各数字が

00:05:24.000 --> 00:05:27.000
実際のロボットから受け取った測定値 Z を引数とした measurement_prob 関数

00:05:27.000 --> 00:05:33.000
の出力を反映します そして print W とすると

00:05:33.000 --> 99:59:59.999
実際に 1000 個の重要性の重み付けのリストが得られます

