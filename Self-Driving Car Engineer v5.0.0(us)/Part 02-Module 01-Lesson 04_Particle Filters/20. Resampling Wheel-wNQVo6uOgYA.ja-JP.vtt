WEBVTT
Kind: captions
Language: ja-JP

00:00:00.000 --> 00:00:03.000
[ナレーター] これをもっと効率的にするアイデアがあります

00:00:03.000 --> 00:00:06.000
これによって優れたサンプルが得られることが経験的にわかります

00:00:06.000 --> 00:00:11.000
すべてのパーティクルと重要性の重みを大きな輪で表してみましょう

00:00:11.000 --> 00:00:18.000
重要性の重みに対応した各パーティクルがスライスに分けられています

00:00:18.000 --> 00:00:24.000
W5 のように重みの大きいパーティクルはスペースを多く占めます

00:00:24.000 --> 00:00:29.000
それに対して 重みの小さいパーティクルは少ないスペースを占めます

00:00:29.000 --> 00:00:36.000
最初に すべてのインデックスのセットからパーティクルインデックスを一様に解いていきましょう

00:00:36.000 --> 00:00:38.000
これをインデックス 1 から N までの離散的選択による

00:00:38.000 --> 00:00:43.000
一様サンプル U として表記しました Python の注意として

00:00:43.000 --> 00:00:49.000
これはもちろん 0 から N-1 までいきます

00:00:49.000 --> 00:00:52.000
W6 を選ぶとしましょう

00:00:52.000 --> 00:00:55.000
そしてこれが手法ですが ベータ関数を作ります

00:00:55.000 --> 00:01:01.000
そして 0 初期化し これらのパーティクルを構築するときに

00:01:01.000 --> 00:01:08.000
この 0 と  2 × Wmax 最大重みの間に位置する 均一に抽出された連続値を加えます

00:01:08.000 --> 00:01:14.000
重要度の集合において重さが一番大きなものです

00:01:14.000 --> 00:01:21.000
W5 が最大なので W5 の 2 倍の大きさになり得るランダム値を追加します

00:01:21.000 --> 00:01:26.000
値を追加するとここに来るとします

00:01:26.000 --> 00:01:29.000
これが 実際に引き出した値で 6 番目のパーティクルの始め

00:01:29.000 --> 00:01:33.000
つまり初期化を示すところから測定された値です

00:01:33.000 --> 00:01:36.000
ここで次のループ繰り返します

00:01:36.000 --> 00:01:41.000
現在のパーティクルの重要性の重みが

00:01:41.000 --> 00:01:43.000
β に到達するまでに十分でない場合

00:01:43.000 --> 00:01:51.000
つまり W index が β ほど大きくない場合 β からまさにこの値 W index

00:01:51.000 --> 00:01:55.000
を引いて index を 1 増やします

00:01:55.000 --> 00:01:59.000
何をしたかというと インデックスをここに移動し

00:01:59.000 --> 00:02:06.000
β のこの部分を削除しました ここのポイントはまだ前と同じです

00:02:06.000 --> 00:02:10.000
ここで β が W index よりも小さくなるポイント

00:02:10.000 --> 00:02:12.000
つまり次の状況のケースになります

00:02:12.000 --> 00:02:14.000
こんどは index=7 で

00:02:14.000 --> 00:02:20.000
インデックスは 再サンプリングプロセスで選ぶパーティクルのインデックスです

00:02:20.000 --> 00:02:25.000
パーティクルインデックスを選びました こんどは繰り返しで β に別の一様の値を足します

00:02:25.000 --> 00:02:27.000
これを追加するとします

00:02:27.000 --> 00:02:30.000
これが追加する値で これが前にあった値 β です

00:02:30.000 --> 00:02:34.000
同じ繰り返しによって index が増え

00:02:34.000 --> 00:02:40.000
このスライスすべて つまり W7 の分の β が減ります

00:02:40.000 --> 00:02:44.000
そしてここにジャンプし パーティクル 1 が選ばれます

00:02:44.000 --> 00:02:47.000
一様の値がとても小さいので

00:02:47.000 --> 00:02:52.000
同じパーティクルが 2 回 選ばれることがよくあります

00:02:52.000 --> 00:02:56.000
各パーティクルが このパーティクルの輪にわたり

00:02:56.000 --> 00:02:59.000
全外周に比例して選ばれることがわかります

00:02:59.000 --> 00:03:04.000
これが再サンプリングステップの本質的な実装になります

00:03:04.000 --> 99:59:59.999
この特有のリサンプラーを できるれば Python で実装してもらいたいのです

