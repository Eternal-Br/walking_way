WEBVTT
Kind: captions
Language: ja

00:00:00.000 --> 00:00:04.000
これから残りの半分がどのように動くか説明します

00:00:04.000 --> 00:00:06.000
ここにロボットがいるとします

00:00:06.000 --> 00:00:10.000
そしてロボットはランドマークまでの
正確な距離を観測します

00:00:10.000 --> 00:00:13.000
観測ノイズも生じますが

00:00:13.000 --> 00:00:16.000
これは追加されたガウス分布で平均値がゼロです

00:00:16.000 --> 00:00:20.000
つまり観測の距離が短すぎるか
長すぎてしまう可能性があり

00:00:20.000 --> 00:00:23.000
その確率はガウス分布によって左右されます

00:00:23.000 --> 00:00:30.000
このプロセスでロボットは観測ベクトルとして
L1からL4までの4つの値を得ます

00:00:30.000 --> 00:00:33.000
ではロボットは中央ではなく右側にいて

00:00:33.000 --> 00:00:39.000
右ではなく右上に移動すると
仮定した時の粒子を考えてみましょう

00:00:39.000 --> 00:00:44.000
黒線の観測ベクトルを
この粒子に適用します

00:00:44.000 --> 00:00:49.000
この粒子にとっては
明らかに不十分な観測ベクトルになります

00:00:49.000 --> 00:00:54.000
特に観測ベクトルは
緑線のようになると予想したでしょう

00:00:54.000 --> 00:00:57.000
その場合この場所ではないという可能性が
高くなります

00:00:57.000 --> 00:01:01.000
実際粒子が正しい位置に近づくほど

00:01:01.000 --> 00:01:06.000
観測の集合はその位置を得られる可能性が
高くなります

00:01:06.000 --> 00:01:09.000
次に粒子フィルタの
仕組みについて話します

00:01:09.000 --> 00:01:13.000
実際の観測と予想された観測の食い違いは

00:01:13.000 --> 00:01:17.000
重要度重みにつながります

00:01:17.000 --> 00:01:22.000
そして特定の粒子の重要性を
教えてくれます

00:01:22.000 --> 00:01:25.000
重みが大きくなるほど重要性も上がります

00:01:25.000 --> 00:01:29.000
非常に多くの異なる粒子と
ある観測ベクトルがあるとします

00:01:29.000 --> 00:01:32.000
各粒子は
それぞれ異なる重みを持ちます

00:01:32.000 --> 00:01:36.000
妥当に見えるものもあれば
大きな円で表示されるように

00:01:36.000 --> 00:01:39.000
とても怪しく見えるものもあります

00:01:39.000 --> 00:01:43.000
これらの粒子をランダムで残しますが

00:01:43.000 --> 00:01:48.000
残存確率はそれらの重みに比例します

00:01:48.000 --> 00:01:53.000
この粒子のようにとても大きな重みを
持っていたら高い確率で生き残りますが

00:01:53.000 --> 00:01:56.000
とても小さな重みを持つものは消えてしまいます

00:01:56.000 --> 00:01:59.000
いわゆる再サンプリングとは

00:01:59.000 --> 00:02:04.000
ランダムに新粒子を描画することです

00:02:04.000 --> 00:02:08.000
新粒子は重要度重みに応じて

00:02:08.000 --> 00:02:11.000
元の粒子を再配置したものです

00:02:11.000 --> 00:02:13.000
再サンプリング後は

00:02:13.000 --> 00:02:17.000
これら大きな3つは
何度も生き残る可能性が高いと言えます

00:02:17.000 --> 00:02:20.000
一方 小さなものは消えてしまう可能性があります

00:02:20.000 --> 00:02:27.000
これがまさに最初に見た廊下での
位置推定の映像で起きたことです

00:02:27.000 --> 00:02:31.000
センサ観測と一致している粒子は
高い確率で生き残ります

00:02:31.000 --> 00:02:36.000
また低い重要度重みを持つものは
消える傾向がありました

00:02:36.000 --> 00:02:42.000
それにより粒子は高い事後確率の
区域の周りに集まるということが分かりました

00:02:42.000 --> 00:02:48.000
私たちがすべきことは
重要度重みを決める方法を実装することです

00:02:48.000 --> 00:02:51.000
これは観測の尤度に関係していて

00:02:51.000 --> 00:02:58.000
これらの重みに比例して粒子を捕まえる
再サンプリングの方法を実装しなければなりません

00:02:58.000 --> 00:03:01.000
早速やってみましょう

00:03:01.000 --> 00:03:04.000
ロボットのコードに戻ります

00:03:04.000 --> 00:03:07.000
ロボットを作って動かしましょう

00:03:07.000 --> 00:03:13.000
sense関数を使って
ロボットのセンサ観測値を得ます

00:03:13.000 --> 00:03:15.000
表示させてみます

00:03:15.000 --> 00:03:20.000
これらは4つのランドマークまでの
範囲または距離です

00:03:20.000 --> 00:03:23.000
myrobotのプリント文を追加することで

00:03:23.000 --> 00:03:27.000
重要度重みは33、48、0．5であることが分かります

00:03:27.000 --> 00:03:30.000
明らかにこれはランダムな値です

00:03:30.000 --> 00:03:34.000
ロボットの位置を
ランダムに初期化したからです

00:03:34.000 --> 00:03:40.000
これらの各粒子に重要度重みを
割り当てる方法をプログラムしてください

00:03:40.000 --> 00:03:44.000
1，000の要素を持つリストを作り

00:03:44.000 --> 00:03:48.000
それぞれの要素に数字を持たせてください

00:03:48.000 --> 00:03:54.000
数字は各粒子の重要度に
比例しています

00:03:54.000 --> 00:04:00.000
また より簡単にするために
観測確率というクラスrobotの関数を

00:04:00.000 --> 00:04:02.000
皆さんのためにプログラムしました

00:04:02.000 --> 00:04:06.000
この関数は1つのパラメータまたは
定義済みの観測ベクトルZを引数とし

00:04:06.000 --> 00:04:11.000
観測がどのくらい確実かを計算します

00:04:11.000 --> 00:04:16.000
次に実際の観測と予測した観測が

00:04:16.000 --> 00:04:22.000
どのくらい離れているかを計算し
ガウス分布を効果的に使います

00:04:22.000 --> 00:04:25.000
このプログラムをよく見れば理解できるでしょう

00:04:25.000 --> 00:04:31.000
しかし実行するためには
観測ノイズがあると仮定しなければなりません

00:04:31.000 --> 00:04:36.000
もし観測ノイズがゼロなら
この関数はゼロで割ることになります

00:04:36.000 --> 00:04:41.000
では実際の観測ノイズを明記する文を加えます

00:04:41.000 --> 00:04:46.000
これはロボットのためではなく
粒子のためにやります

00:04:46.000 --> 00:04:51.000
このプログラムの行で初めて粒子を作り出します

00:04:51.000 --> 00:04:54.000
数字を残してこれらの位置を初期化しました

00:04:54.000 --> 00:04:58.000
また各粒子に
ある程度のノイズがあると想定します

00:04:58.000 --> 00:05:02.000
これらの領域において
平行運動のノイズは0．05で回転ノイズも0．05

00:05:02.000 --> 00:05:06.000
そして観測ノイズは5．0とします

00:05:06.000 --> 00:05:09.000
これは極めて重要な数字です

00:05:09.000 --> 00:05:15.000
皆さんには1，000の要素を持つリストWを
作ってもらいたいのです

00:05:15.000 --> 00:05:22.000
このベクトルの各数字は後ろの
ロボットから受け取った観測値Zを引数とした

00:05:22.000 --> 00:05:27.000
measurement_prob関数の出力を反映します

00:05:27.000 --> 00:05:33.000
そしてWを表示するプリント文を追加し

00:05:33.000 --> 00:05:37.000
1，000の重要度重みのリストを表示します

