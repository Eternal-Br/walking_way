WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:02.000
接下来

00:00:02.000 --> 00:00:04.000
你还有一个编程任务

00:00:04.000 --> 00:00:07.000
这个任务里 你不需要打印出粒子

00:00:07.000 --> 00:00:09.000
只需要打印出参考答案

00:00:09.000 --> 00:00:11.000
的总体质量

00:00:11.000 --> 00:00:13.000
为了帮助你 我已经为你编写了一段 eval 代码

00:00:13.000 --> 00:00:15.000
它代入了机器人位置

00:00:15.000 --> 00:00:17.000
和一个粒子组

00:00:17.000 --> 00:00:19.000
然后计算每个粒子

00:00:19.000 --> 00:00:21.000
相对于计算机在 x 和 y

00:00:21.000 --> 00:00:24.000
的平均误差 不是在方向上的误差

00:00:24.000 --> 00:00:26.000
它的实现方式是 对比

00:00:26.000 --> 00:00:29.000
粒子的 x 值和机器人的 x 值

00:00:29.000 --> 00:00:32.000
计算出这些差的欧几里德距离

00:00:32.000 --> 00:00:35.000
然后求所有的平均值

00:00:35.000 --> 00:00:37.000
把所有这些相加

00:00:37.000 --> 00:00:39.000
然后求平均值 根据这里

00:00:39.000 --> 00:00:42.000
的粒子数量计算 也就是大写的 M

00:00:42.000 --> 00:00:44.000
这里有一些有趣的东西

00:00:44.000 --> 00:00:47.000
原因在于 这个世界是循环的

00:00:47.000 --> 00:00:51.000
因此 如果机器人的位置是 0.0 或者 99.9 时

00:00:51.000 --> 00:00:53.000
值大概相同

00:00:53.000 --> 00:00:55.000
但根据这里的计算 值是不一样的

00:00:55.000 --> 00:00:58.000
因此 尽管这里进行了归一化

00:00:58.000 --> 00:01:01.000
我可以肯定 这个世界的循环性

00:01:01.000 --> 00:01:03.000
不会真正影响我在边界处

00:01:03.000 --> 00:01:05.000
包括的估算误差

00:01:05.000 --> 00:01:07.000
你可以这么解析

00:01:07.000 --> 00:01:10.000
我在计算机模型运算

00:01:10.000 --> 00:01:12.000
中添加了 world_size 然后

00:01:12.000 --> 00:01:14.000
在这里减去同样的内容 这里看不到

00:01:14.000 --> 00:01:16.000
因为这一行太长了

00:01:16.000 --> 00:01:18.000
不论如何 我希望你能利用这个函数 eval

00:01:18.000 --> 00:01:23.000
并进行一系列的性能评估

00:01:23.000 --> 00:01:25.000
如果我们点击运行按钮

00:01:25.000 --> 00:01:27.000
你应该能生成类似这里的结果：

00:01:27.000 --> 00:01:32.000
4.9, 3.6, 2.9, 2.8, 3.1

00:01:32.000 --> 00:01:34.000
这叫残差

00:01:34.000 --> 00:01:36.000
记住 这是一个 100 乘 100 的世界

00:01:36.000 --> 00:01:38.000
因此 考虑到世界的面积

00:01:38.000 --> 00:01:40.000
这个误差实际上不算大

00:01:40.000 --> 00:01:42.000
下面 请进行编程 保证每次迭代时

00:01:42.000 --> 99:59:59.999
都能得到这个程序所生成的误差数字

