WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:02.194
那么 我们融合了什么？

00:00:02.194 --> 00:00:04.859
正在融合图形操作

00:00:04.860 --> 00:00:07.485
这种融合减少了操作次数

00:00:07.485 --> 00:00:11.070
并加速数据通过图表

00:00:11.070 --> 00:00:13.410
考虑三个流程： 批量标准化

00:00:13.410 --> 00:00:15.554
输入一个值

00:00:15.554 --> 00:00:17.795
输入一个卷积

00:00:17.795 --> 00:00:21.835
这种实现需要每个流程存储临时张量

00:00:21.835 --> 00:00:27.130
我们可以将所有三种操作融合在一起 避免存储所有这些额外的张量

00:00:27.129 --> 00:00:32.865
更好的是 融合操作只在 GPU 上执行一个内核而不是三个

00:00:32.865 --> 00:00:35.655
每次调用内核时 都会有日用开支

00:00:35.655 --> 00:00:41.265
因此 对内核进行融合限制了开销 所以整体应用运行速度更快

00:00:41.265 --> 00:00:44.204
融合可以节省内存和时间

00:00:44.204 --> 00:00:48.269
当然 融合可能对训练和推理都有好处

00:00:48.270 --> 00:00:51.900
折衷是融合降低了网络的灵活性

00:00:51.899 --> 00:00:56.219
在训练期间 我们可能希望保留模型的灵活性

00:00:56.219 --> 00:01:00.629
我们想要添加或删除图层 或传输部分网络

00:01:00.630 --> 00:01:02.330
当我们推论时

00:01:02.329 --> 00:01:04.670
我们不再改变网络架构

00:01:04.670 --> 00:01:08.189
所以我们可以更积极地融合操作

00:01:08.189 --> 00:01:11.189
可以通过编码一个执行三个融合操作的单个内核

00:01:11.189 --> 00:01:15.450
手动完成这一点很重要

00:01:15.450 --> 00:01:18.700
然而 编译器能够自己完成这个工作

00:01:18.700 --> 00:01:23.430
使我们能够编写可理解的代码 并仍享有性能优势

00:01:23.430 --> 00:01:28.740
我们可以使用优化器来自动执行此过程 从而将常见层融合在一起

00:01:28.739 --> 00:01:32.129
这使我们可以更容易地理解代码并执行操作

00:01:32.129 --> 00:01:34.914
而优化后的最终版本

00:01:34.915 --> 00:01:40.000
我们将通过自动应用融合等技巧 来获得所有性能优势

