WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.955
Temporal interference refers to one element

00:00:02.955 --> 00:00:06.750
blocking the execution of another element over time.

00:00:06.750 --> 00:00:10.199
For example, if two software elements share data,

00:00:10.199 --> 00:00:14.219
a higher priority thread could continuously get access to

00:00:14.220 --> 00:00:18.414
the data and the low priority thread would always be waiting.

00:00:18.414 --> 00:00:20.859
This is called blocking of execution.

00:00:20.859 --> 00:00:23.730
There are many other cases of temporal interference,

00:00:23.730 --> 00:00:26.300
and we will discuss a few couple of months.

00:00:26.300 --> 00:00:30.855
Deadlocks occur when two executed threads need each others resources;

00:00:30.855 --> 00:00:33.285
though thread one needs resource B,

00:00:33.284 --> 00:00:37.924
but has to resource A. Thread two needs resource A,

00:00:37.924 --> 00:00:39.584
but has resource B.

00:00:39.585 --> 00:00:43.219
A similar interference is called Livelocks.

00:00:43.219 --> 00:00:46.369
Where two threads wants the same resource.

00:00:46.369 --> 00:00:51.089
In this case both threads have the courtesy to let the other thread go first,

00:00:51.090 --> 00:00:56.180
but they keep stepping aside and then trying to grab the resource simultaneously.

00:00:56.179 --> 00:00:58.424
Another example of temporal interference

00:00:58.424 --> 00:01:01.649
is incorrect synchronization between software elements.

00:01:01.649 --> 00:01:04.859
For example, consider an autonomous vehicle that has

00:01:04.859 --> 00:01:10.224
both a radar system and camera system for vehicle detection.

00:01:10.224 --> 00:01:12.890
Each system will have its own issue.

00:01:12.890 --> 00:01:17.295
But what if the clocks on the issues are not synchronized properly,

00:01:17.295 --> 00:01:20.265
then sensor fusion could not be done

00:01:20.265 --> 00:01:24.060
since there would be no way to compress signals over time.

00:01:24.060 --> 00:01:25.930
Hence, clocks need to be synchronized or

00:01:25.930 --> 00:01:29.620
all software elements need to use the same master clock.

00:01:29.620 --> 00:01:33.045
When any time or executioner related fault occurs,

00:01:33.045 --> 00:01:35.784
safety mechanisms need to take action.

00:01:35.784 --> 00:01:38.394
This can be a degraded functionality and

00:01:38.394 --> 00:01:43.000
eventual transition to a safe state to avoid safety goal violations.

