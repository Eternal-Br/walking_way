WEBVTT
Kind: captions
Language: ja-JP

00:00:00.280 --> 00:00:04.630
実は、クイックソートの効率は
非常に複雑です

00:00:04.630 --> 00:00:07.250
まずは最悪のケースを
考えてみましょう

00:00:07.250 --> 00:00:08.950
どんな風になるでしょうか

00:00:08.950 --> 00:00:11.860
このアルゴリズムは

00:00:11.860 --> 00:00:13.459
ほぼ毎回配列を半分に分割することで

00:00:13.460 --> 00:00:16.410
実行する必要のある比較の回数を減らすという
不思議な力をもっています

00:00:16.410 --> 00:00:20.710
つまり最悪のケースは
配列を半分に分割できず

00:00:20.710 --> 00:00:23.620
毎回すべての比較を
行わなければならない場合です

00:00:23.620 --> 00:00:27.310
ピボットがすでに
正しい場所にあれば

00:00:27.310 --> 00:00:29.100
結局はすべての比較を行うことになります

00:00:29.100 --> 00:00:31.800
13 はすでに一番大きい要素なので

00:00:31.800 --> 00:00:35.100
その他すべてを
1 回で比較します

00:00:35.100 --> 00:00:37.500
すると移動させる必要が
ないことがわかります

00:00:37.500 --> 00:00:40.540
1 度にするには比較する
回数が多いですが

00:00:40.540 --> 00:00:44.600
本当の問題は次の値も
最も大きい場合です

00:00:44.600 --> 00:00:47.520
同じように、結局はこれより
小さいものすべてと比較するため

00:00:47.520 --> 00:00:49.360
ステップは変わりません

00:00:49.360 --> 00:00:52.910
この比較回数を見てバブルソートを
思い出された方もいるのではないでしょうか

00:00:52.910 --> 00:00:55.629
バブルソートでは
各要素を次の要素と比較する作業を

00:00:55.630 --> 00:00:59.400
何度も繰り返します

00:01:00.400 --> 00:01:02.629
最終的には、最後にある要素は
除外します

00:01:02.630 --> 00:01:04.890
正しい場所にあることが
わかっているからです

00:01:04.890 --> 00:01:09.200
クイックソートの最悪のケースも
まったく同じです

00:01:09.200 --> 00:01:13.600
つまりクイックソートの最悪のケースは
実は O(n2) なのです

00:01:13.600 --> 00:01:17.539
クイックソートにとって
これは本当にひどい効率です

00:01:17.540 --> 00:01:20.600
ただし、クイックソートは主に 2 つの理由から
有用だといえます

00:01:21.280 --> 00:01:26.660
まず、平均計算量および最良計算量は
nlogin です

00:01:26.660 --> 00:01:29.570
適切なケースの場合、ピボットが
下から中央に移動し

00:01:29.570 --> 00:01:32.669
配列を毎回半分に
分割することができます

00:01:32.670 --> 00:01:36.580
ピボットが中央にあれば
配列のもう半分を確認して

00:01:36.580 --> 00:01:39.100
そのピボットも中央に移動させることができます

00:01:39.100 --> 00:01:43.410
これらのピボットがソートされているということは
他もすべてソートされているため

00:01:43.410 --> 00:01:45.700
実にすばやく行えます

00:01:45.700 --> 00:01:48.340
ここでは配列を毎回半分に分割しているため

00:01:48.340 --> 00:01:50.670
最終的にはマージソートのように
見えます

00:01:50.670 --> 00:01:53.970
繰り返しになりますが
効率が log n になるのはこのためです

00:01:53.970 --> 00:01:57.300
平均的なケースは
これによく似ています

00:01:57.300 --> 00:02:01.550
乱数を選んで中央に近づける
その繰り返しです

00:02:01.550 --> 00:02:05.289
ただし、近似ソートされた
配列を得ることがわかっている場合

00:02:05.290 --> 00:02:07.900
クイックソートは適していません

00:02:07.900 --> 00:02:10.350
必ず最悪のケースになるからです

00:02:10.350 --> 00:02:13.489
2 つ目は
クイックソートで最適化すれば

00:02:13.490 --> 00:02:15.520
より高速に実行できる点です

00:02:15.520 --> 00:02:18.330
たとえば配列を分割する場合

00:02:18.330 --> 00:02:22.630
半分を両方同時に実行するよう
プログラムを構成できます

00:02:22.630 --> 00:02:25.200
結果的に使用する
計算能力量は同じですが

00:02:25.200 --> 00:02:26.950
時間は少なくてすみます

00:02:26.950 --> 00:02:30.490
また一番最後の要素をピボットとして
選択するのではなく

00:02:30.500 --> 00:02:32.300
最後のいくつかの要素から
その中央値を

00:02:32.300 --> 00:02:34.350
ピボットして選択することができます

00:02:34.350 --> 00:02:37.700
中央値を選択すれば
全体の中央にある要素を

00:02:37.700 --> 00:02:38.760
より深く理解することができ

00:02:38.760 --> 00:02:42.179
ひいては要素を中央に移動させて
最良のシナリオを

00:02:42.180 --> 00:02:44.520
得られる可能性が高まります

00:02:44.520 --> 00:02:47.260
このバージョンのクイックソートは
in-place であるため

00:02:47.260 --> 00:02:49.690
余分な空間を一切使用しません

00:02:49.690 --> 00:02:51.530
空間計算量は定数です

