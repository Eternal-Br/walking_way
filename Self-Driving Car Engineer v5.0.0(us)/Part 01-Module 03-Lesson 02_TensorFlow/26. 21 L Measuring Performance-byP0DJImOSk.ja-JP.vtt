WEBVTT
Kind: captions
Language: ja-JP

00:00:00.470 --> 00:00:01.970
最初のモデルの
トレーニングが終了したこの時点で

00:00:01.970 --> 00:00:04.799
議論すべき
重要な事項があります

00:00:04.799 --> 00:00:08.129
課題で見たかもしれませんが
トレーニングセットの他に

00:00:08.130 --> 00:00:11.530
評価セットと
テストセットもありました

00:00:11.529 --> 00:00:13.299
これらはいったい何でしょうか?

00:00:13.300 --> 00:00:14.380
必ず確認してください

00:00:14.380 --> 00:00:17.109
処理の適切さの
測定に関係し

00:00:17.109 --> 00:00:19.559
失敗を防ぐのに
役立ちます

00:00:19.559 --> 00:00:22.299
第一印象より
はるかに微妙です

00:00:22.300 --> 00:00:25.500
また 後で説明しますが
問題に対するパフォーマンスを測定する方法がわかれば

00:00:25.500 --> 00:00:28.519
すでに半分は
解決したことになるため

00:00:28.519 --> 00:00:30.789
その点からも非常に重要です

00:00:30.789 --> 00:00:33.560
パフォーマンスの測定が微妙なことである
理由を説明します

00:00:33.560 --> 00:00:35.870
分類タスクに
戻りましょう

00:00:35.869 --> 00:00:38.459
ラベルについて
多くのイメージが手に入りました

00:00:38.460 --> 00:00:42.560
そこで これらのイメージに対して
クラシファイ（識別器）を実行し

00:00:42.560 --> 00:00:44.170
どの程度正しく得られたかを確認したいと考えるでしょう

00:00:44.170 --> 00:00:45.560
これは誤差測定です

00:00:45.560 --> 00:00:48.800
次に
これまで見たことのない新しいイメージに対して

00:00:48.799 --> 00:00:51.199
クラシファイを使ってみます
どれくらい正しい結果が得られるかを

00:00:51.200 --> 00:00:54.810
測定すると
パフォーマンスは低下し

00:00:54.810 --> 00:00:56.929
クラシファイはうまく動作しません

00:00:56.929 --> 00:00:57.554
何が起きているのでしょうか?

00:00:57.554 --> 00:01:02.369
作成したクラシファイは
新しいイメージをトレーニングセットにすでにある

00:01:02.369 --> 00:01:06.829
他のイメージと単純に比較し
ラベルを返すだけであると

00:01:06.829 --> 00:01:08.530
考えてください

00:01:08.530 --> 00:01:11.500
前に定義した測定では
優れたクラシファイです

00:01:11.500 --> 00:01:14.689
トレーニングセットでは
100%の精度を得られます

00:01:14.689 --> 00:01:17.950
しかし 新しいイメージの場合は
どうすればよいか

00:01:17.950 --> 00:01:19.829
わからなくなります

00:01:19.829 --> 00:01:21.579
優れたクラシファイではありません

00:01:21.579 --> 00:01:25.409
問題は このクラシファイは
トレーニングセットを記憶しているだけで

00:01:25.409 --> 00:01:28.079
新しい例に一般化できていないことです

00:01:28.079 --> 00:01:30.280
単なる理論上の問題ではありません

00:01:30.280 --> 00:01:33.390
作成されるすべてのクラシファイは
トレーニングセットを記憶しようとする傾向が

00:01:33.390 --> 00:01:35.250
あります

00:01:35.250 --> 00:01:37.750
通常
それは非常にうまく行われます

00:01:37.750 --> 00:01:42.280
しかし ここで必要なのは
新しいデータの一般化を助けることです

00:01:42.280 --> 00:01:45.560
それではクラシファイによるデータの記憶力を
測定するのではなく

00:01:45.560 --> 00:01:48.590
一般化の能力を測定するには
どうすればよいのでしょう?

00:01:48.590 --> 00:01:52.620
最も簡単な方法は
トレーニングセットの一部を

00:01:52.620 --> 00:01:56.090
トレーニングに使用せずに
そのテストデータの誤差を測定することです

00:01:57.170 --> 00:01:59.989
問題は解決しました
このクラシファイはテストデータを見ないため

00:01:59.989 --> 00:02:03.717
それを記憶できず
カンニングできないのです

00:02:03.718 --> 00:02:04.859
しかしクラシファイのトレーニングは通常は

00:02:04.859 --> 00:02:08.949
試行錯誤のプロセスなので
まだ問題があります

00:02:08.949 --> 00:02:12.190
あなたはクラシファイを試し
パフォーマンスを測定してから

00:02:12.189 --> 00:02:14.859
別のクラシファイを試して
再び測定します

00:02:14.860 --> 00:02:19.500
さらに別のクラシファイを試して測定し
モデルを微調整し

00:02:19.500 --> 00:02:23.759
パラメーターを調べ 測定し
最終的に完璧なクラシファイと考えられるものができあがります

00:02:24.800 --> 00:02:28.500
トレーニングデータから
テストデータを分離して

00:02:28.500 --> 00:02:32.610
テストデータだけで
パフォーマンスを測定した後

00:02:32.610 --> 00:02:35.530
システムを実際の
運用環境に展開します

00:02:35.530 --> 00:02:39.520
さらにデータを取得し
新しいデータでパフォーマンスを評価すると

00:02:39.520 --> 00:02:42.010
それほどよくありません

00:02:42.009 --> 00:02:43.979
何が起きているのでしょうか?

00:02:43.979 --> 00:02:48.579
実は このクラシファイは
あなた自身の目を通して

00:02:48.580 --> 00:02:49.910
間接的にテストデータを見ていたのです

00:02:49.909 --> 00:02:54.009
使用するクラシファイや
調整するパラメーターを決定するたびに

00:02:54.009 --> 00:02:59.090
実際はテストセットについての情報を
クラシファイに与えていたのです

00:02:59.090 --> 00:03:01.610
1つ1つは小さなことでも それが蓄積されます。

00:03:01.610 --> 00:03:03.560
時間が経ち実行する実験が増えるほど

00:03:03.560 --> 00:03:07.629
テストデータは
トレーニングデータに流出していきます

00:03:07.629 --> 00:03:09.150
どうすればよいのでしょう?

00:03:09.150 --> 00:03:11.120
これに対処するには多くの方法があります

00:03:11.120 --> 00:03:12.610
ここでは最も簡単な方法を示します

00:03:12.610 --> 00:03:16.340
トレーニングセットから別の塊を取り出し
それを岩の下に隠します

00:03:16.340 --> 00:03:19.340
最終的な決定を下すまで
それを見てはいけません

00:03:19.340 --> 00:03:23.460
評価セットを使って
実際の誤差を測定でき

00:03:23.460 --> 00:03:26.870
おそらく評価セットは
トレーニングセットに流れ出します

00:03:26.870 --> 00:03:29.870
しかし 問題ありません
現実のパフォーマンスを

00:03:29.870 --> 00:03:32.509
実際に測定するために利用できるこのテストセットが
常にあるからです

