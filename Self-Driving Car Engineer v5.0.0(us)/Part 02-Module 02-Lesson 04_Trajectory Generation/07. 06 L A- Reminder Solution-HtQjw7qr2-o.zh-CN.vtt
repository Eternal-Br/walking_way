WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.140
对于第一个问题 答案是 “否”

00:00:03.140 --> 00:00:06.089
在运行 A* 前的第一步是定义一个离散的状态集合

00:00:06.089 --> 00:00:09.949
该集合代表了我们想要规划的世界

00:00:09.949 --> 00:00:13.114
在我们说 A* 是一个离散的方法之前

00:00:13.115 --> 00:00:15.855
我们先来回答第二个问题 答案是 “是”

00:00:15.855 --> 00:00:17.089
要成为一种有效的算法

00:00:17.089 --> 00:00:20.109
A* 启发式搜索不得不保持乐观性

00:00:20.109 --> 00:00:25.679
这意味着它会低估从单元格到目标的实际成本

00:00:25.679 --> 00:00:29.210
A* 总是可以发现一个存在的解决方案

00:00:29.210 --> 00:00:33.895
这显示出 A* 规划算法具有完备性 正如我们以前提到的

00:00:33.895 --> 00:00:37.560
这样的话 我们下面的一些说法将会有些自相矛盾

00:00:37.560 --> 00:00:42.225
因为该算法依赖于使用的搜索空间以及该空间指代的事物

00:00:42.225 --> 00:00:45.149
如果搜索空间仅仅代表位置 x 和 y

00:00:45.149 --> 00:00:47.869
正如大家在前面例子中所见

00:00:47.869 --> 00:00:49.634
然后我们试图移动一辆车

00:00:49.634 --> 00:00:55.409
这里并不能保证 一系列由 A* 生成的位置是可行驶的

00:00:55.409 --> 00:00:58.299
因此 此问题答案是 “否”

00:00:58.299 --> 00:01:03.044
然而 我们讲过 A* 是图搜索算法

00:01:03.045 --> 00:01:06.989
我们能定义一个更复杂的搜索空间

00:01:06.989 --> 00:01:10.859
比如 可以把朝向加进去 并限制单元格之间的连接

00:01:10.859 --> 00:01:15.004
这样 我们关闭添加到顶部的单元格

00:01:15.004 --> 00:01:19.964
并设置只有在关闭的单元格和新单元格之间可以进行连接

00:01:19.965 --> 00:01:24.460
如果我们那样做了 结果路径将同样可推导出

00:01:24.459 --> 00:01:27.729
这相当于在这些字母上运行 A*

00:01:27.730 --> 00:01:29.895
现在 我们来回答最后一个问题

00:01:29.894 --> 00:01:33.719
确实 A* 解决方案的结果总是最优的

00:01:33.719 --> 00:01:39.364
前提是用作输入的环境是离散化的

00:01:39.364 --> 00:01:41.384
离散化越严重

00:01:41.385 --> 00:01:43.090
得出的解越好

00:01:43.090 --> 00:01:45.350
我们把它叫做解优化

