WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:01.879
在有关混合 A* 的第一个视频中

00:00:01.879 --> 00:00:05.339
我们使用了一个更新方程

00:00:05.339 --> 00:00:09.434
这个方程对于绝大部分具有 X Y 域的配置空间是通用的

00:00:09.435 --> 00:00:13.210
特别是 我们没有标明 Omega 代表什么

00:00:13.210 --> 00:00:15.990
Omega 是有关变化的首要比率

00:00:15.990 --> 00:00:17.760
对一些机器人而言

00:00:17.760 --> 00:00:22.355
我们可以将 Omega 指定为独立的与其状态无关的值

00:00:22.355 --> 00:00:27.734
但是那将意味着 机器人可以无限制地绕着它的 Z 轴转动

00:00:27.734 --> 00:00:30.945
对于汽车 这并不现实

00:00:30.945 --> 00:00:34.055
我们或许应该使用自行车模型

00:00:34.055 --> 00:00:38.489
这给了我们一个和 Omega 等价的东西

00:00:38.490 --> 00:00:42.289
这里 L 是前后轴之间的距离 

00:00:42.289 --> 00:00:47.325
δ 是转向角 ? 是值为正的恒定速度

00:00:47.325 --> 00:00:49.080
现在 对于我们的混合 A* 算法

00:00:49.079 --> 00:00:54.469
我们需要决定 从我们当前处理的节点可以到达哪个配置

00:00:54.469 --> 00:00:57.769
并把它加入开放集合

00:00:57.770 --> 00:01:00.900
实践中 我们可能会使用一些转向角的值

00:01:00.899 --> 00:01:05.909
这些值位于最大左右转向角之间

00:01:05.909 --> 00:01:10.890
但是 我们添加的 Delta 越多 我们的算法计算的时间越长 

00:01:10.890 --> 00:01:12.465
因此 在这个例子中

00:01:12.465 --> 00:01:15.885
我们的 delat 只会从3个角度值中选择

00:01:15.885 --> 00:01:18.150
最大左转向角

00:01:18.150 --> 00:01:22.230
0转向角 以及最大右转向角

00:01:22.230 --> 00:01:27.130
如果一辆车的转向角最大值为35度

00:01:27.129 --> 00:01:32.515
这3个值将是 -35 0 35

00:01:32.515 --> 00:01:36.689
这使我们可以用3种新的基本运动来扩展搜索树

00:01:36.689 --> 00:01:41.364
直行 左转 右转

00:01:41.364 --> 00:01:44.349
我们来看一下 在一个机器人迷宫中 搜索是如何展开的

00:01:44.349 --> 00:01:46.390
假设我们的迷宫是这样的

00:01:46.390 --> 00:01:50.689
红色方块是目标 这里是开始点

00:01:50.689 --> 00:01:54.530
我们第一步要做的是把这个格子加入 open 列表

00:01:54.530 --> 00:01:57.359
我用灰色来标示它

00:01:57.359 --> 00:01:59.730
接下来 我们会生成3条轨迹

00:01:59.730 --> 00:02:01.410
第一条是直行

00:02:01.409 --> 00:02:03.504
第二条是右转

00:02:03.504 --> 00:02:05.324
第三条是左转

00:02:05.325 --> 00:02:10.824
这里 我们可以丢弃那些指向地图之外的轨迹 以及会产生碰撞的轨迹

00:02:10.824 --> 00:02:14.414
这样我们只剩一个新的单元格子 我们继续处理它

00:02:14.414 --> 00:02:20.185
然后 我们把第一个单元格标记为关闭状态 用这个符号标记一下

00:02:20.185 --> 00:02:25.074
现在 图上只有一个打开的单元格 我们接着扩展它

00:02:25.074 --> 00:02:28.274
我们再次为它生成3条轨迹

00:02:28.275 --> 00:02:29.825
这一条轨迹行不通

00:02:29.824 --> 00:02:31.959
我们可以忽略它

00:02:31.960 --> 00:02:34.935
这样我们只面对两个新的单元格

00:02:34.935 --> 00:02:37.275
现在我关闭刚才的单元格

00:02:37.275 --> 00:02:40.254
现在我们面临选择 用哪一个单元格去做扩展

00:02:40.254 --> 00:02:43.930
假定我已经有一些启发值 这些值告诉我哪个格子更靠近目标

00:02:43.930 --> 00:02:45.960
然后我选择右边的格子

00:02:45.960 --> 00:02:49.885
接着我继续为这个新的单元格生成轨迹

00:02:49.884 --> 00:02:51.734
大家注意一下 在上面过程中

00:02:51.735 --> 00:02:53.340
我不仅仅跟踪

00:02:53.340 --> 00:02:55.020
当前所在的单元格

00:02:55.020 --> 00:03:00.750
而且还会跟踪自身的位置 以及朝向

00:03:00.750 --> 00:03:05.875
实践中 我们同样会使用三维的状态空间 其中包括朝向

00:03:05.875 --> 00:03:09.849
如果不这么做 我们很可能会过早关闭单元格

00:03:09.849 --> 00:03:12.299
这个例子中我并没有使用三维状态空间

00:03:12.300 --> 00:03:14.980
主要是因为它很难可视化显示出来

00:03:14.979 --> 00:03:19.144
我们继续 现在我面临着三个新的单元格

00:03:19.145 --> 00:03:21.540
我先得关闭之前的一个

00:03:21.539 --> 00:03:25.319
然后从新单元格中找出一个最佳选择 然后继续上述过程

00:03:25.319 --> 00:03:29.219
再一次 我又有了3个新单元格要添加到 open 列表

00:03:29.219 --> 00:03:30.859
这意味着我现在可以关闭先前的单元格

00:03:30.860 --> 00:03:34.695
事情到这里变得有趣起来

00:03:34.694 --> 00:03:37.379
启发函数可能会建议我扩展到右下方单元格

00:03:37.379 --> 00:03:41.079
再从哪里继续生成轨迹

00:03:41.080 --> 00:03:43.990
但是 如果这样选择 我们就走入了死胡同

00:03:43.990 --> 00:03:48.300
因此 我不需要给开放列表添加新的单元格

00:03:48.300 --> 00:03:52.897
现在 因为我从这个单元格做的扩展 我不得不关闭它

00:03:52.896 --> 00:03:56.159
然后 我可以查看我剩余的打开的单元格

00:03:56.159 --> 00:03:57.914
和以前一样

00:03:57.914 --> 00:03:59.429
我会选择离目标更近的格子

00:03:59.430 --> 00:04:01.405
然后生成轨迹 这些轨迹会产生碰撞

00:04:01.405 --> 00:04:04.390
然后我会关闭那个单元格

00:04:04.389 --> 00:04:06.731
的对于剩下的打开单元格

00:04:06.731 --> 00:04:12.275
右上方这个是离目标最近的 或者说它的启发值最小

00:04:12.275 --> 00:04:14.159
因此 我继续处理它

00:04:14.159 --> 00:04:19.259
就这样 直到我们到达目标

00:04:19.259 --> 00:04:22.050
现在 把这些东西擦掉

00:04:22.050 --> 00:04:25.775
让我们来看一下 最终轨迹是什么样的

00:04:25.774 --> 00:04:28.729
我们得到的是一条连续的路径

00:04:28.730 --> 00:04:33.360
对于我们的规划问题 它可能不是一条最平滑的解

00:04:33.360 --> 00:04:36.270
确实 我们很容易构造出这样的环境

00:04:36.269 --> 00:04:39.089
在那里 算法生成的路径

00:04:39.089 --> 00:04:42.685
无法与人工选择的路径相媲美

00:04:42.685 --> 00:04:44.584
而且 算法的问题不止这一条

00:04:44.584 --> 00:04:49.889
有时候 一些小东西就会让算法找不出存在的解

00:04:49.889 --> 00:04:52.800
举个例子 我们回到刚才的地方

00:04:52.800 --> 00:04:58.454
考虑一下 如果我们把地图稍作调整 会发生什么

00:04:58.454 --> 00:05:03.699
这种情况下 我们开始的决策和刚才一样 直到我们到达这个位置

00:05:03.699 --> 00:05:06.305
现在 我们的选择是 关闭这个非常关键的单元格

00:05:06.305 --> 00:05:09.959
显然 这个格子有一条通向目标的路径

00:05:09.959 --> 00:05:11.859
但是 在这个例子中

00:05:11.860 --> 00:05:13.925
混合 A* 并没有找出来这条路

00:05:13.925 --> 00:05:17.960
为了降低这种问题发生的几率 我们可以为我们的地图添加更多解

00:05:17.959 --> 00:05:22.949
或者给我们的搜索空间添加第三维 也就是朝向

00:05:22.949 --> 00:05:27.564
实际上 后者可以使我们在某些朝向下不会去关闭图上这个位置

00:05:27.564 --> 00:05:32.540
只会在特定情况下才会关闭格子 那样我们就可以在这张图上找到解了

