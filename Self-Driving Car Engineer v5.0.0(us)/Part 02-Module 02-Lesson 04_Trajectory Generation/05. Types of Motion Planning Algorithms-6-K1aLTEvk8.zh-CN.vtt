WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.450
运动规划算法有很多类

00:00:03.450 --> 00:00:06.190
今天 我们重点讲解其中之一

00:00:06.190 --> 00:00:08.570
但是其他的算法也值得一提

00:00:08.570 --> 00:00:13.995
组合法通常会将自由空间分成小块

00:00:13.994 --> 00:00:18.600
然后通过将这些原子元素连起来 来解决运动规划问题

00:00:18.600 --> 00:00:22.380
这种方法中 有多种与我们直觉相符的方式 去发现最初的近似解

00:00:22.379 --> 00:00:25.899
但是当环境规模扩大后 这种方法表现不佳

00:00:25.899 --> 00:00:28.844
另一种是位势场算法 这是一些反馈算法

00:00:28.844 --> 00:00:33.394
每个障碍物会产生一种反重力场

00:00:33.395 --> 00:00:36.655
这会使车辆不会去靠近它们

00:00:36.655 --> 00:00:40.079
比如 你可以将这种方法用在行人和自行车上

00:00:40.079 --> 00:00:45.989
然后算法规划出的轨迹就会绕过它们

00:00:45.990 --> 00:00:48.630
位势场算法的主要问题在于

00:00:48.630 --> 00:00:50.850
有时候它会把我们带入局部极小值中

00:00:50.850 --> 00:00:54.300
这让我们难以找出一个解来

00:00:54.299 --> 00:00:58.589
最优控制法也是用来解决运动规划问题的算法

00:00:58.590 --> 00:01:01.485
它通过算法来生成控制 PoD

00:01:01.484 --> 00:01:05.099
它使用动态模型 为车辆 最初配置和最终配置建模

00:01:05.099 --> 00:01:09.449
该算法需要我们生成一系列的输入

00:01:09.450 --> 00:01:12.269
比如 转向目标和减速

00:01:12.269 --> 00:01:16.239
这些输入会把我们从开始配置带到最终配置

00:01:16.239 --> 00:01:20.280
在此过程中 算法会优化与控制输入相关的成本函数

00:01:20.280 --> 00:01:25.594
比如最小汽油消耗 算法也会优化与车辆配置相关的成本函数

00:01:25.594 --> 00:01:28.510
比如 与其他车辆保持一定距离

00:01:28.510 --> 00:01:31.255
这种算法有多种不错的实现方式

00:01:31.254 --> 00:01:34.609
大部分都基于数值优化法

00:01:34.609 --> 00:01:37.439
但是 要把所有与其他车辆相关的限制都很好地纳入考量

00:01:37.439 --> 00:01:41.405
还要使算法很快地得出结果

00:01:41.405 --> 00:01:44.234
是相当困难的

00:01:44.234 --> 00:01:49.819
最后一种算法是基于抽样的算法 也是我们今天讲解的重点

00:01:49.819 --> 00:01:52.709
这些算法非常流行 因为为它们定义要计算的自由空间

00:01:52.709 --> 00:01:57.074
是相对容易的

00:01:57.075 --> 00:02:00.615
基于抽样算法使用一个碰撞检测模块

00:02:00.614 --> 00:02:05.459
该模块探测自由空间 测试是否一个配置在其中会发生碰撞

00:02:05.459 --> 00:02:10.965
不同于组合法和最优控制法 这两种方法均需要分析整个环境

00:02:10.965 --> 00:02:15.950
抽样法不需要检测所有自由空间 便可以发现一条路径

00:02:15.949 --> 00:02:20.189
搜索过的部分存储在一个图结构中

00:02:20.189 --> 00:02:24.050
然后我们可以使用图搜索算法 例如 D* 或者 A* 来进行搜索

00:02:24.050 --> 00:02:28.245
有两类方法可以认定是基于抽样的

00:02:28.245 --> 00:02:33.115
一种是离散法 它依赖于构造良好的辅助集合或者输入

00:02:33.115 --> 00:02:38.340
比如 覆盖在我们配置空间上的一张格子图

00:02:38.340 --> 00:02:41.729
另一种是概率统计法

00:02:41.729 --> 00:02:45.929
它依赖连续配置空间的概率样本

00:02:45.930 --> 00:02:48.765
待探索的可能配置或者状态集

00:02:48.764 --> 00:02:51.959
可能是无穷多的

00:02:51.960 --> 00:02:54.390
这让此类算法具有一种不错的性质

00:02:54.389 --> 00:02:57.284
那就是 他们是概率完整的

00:02:57.284 --> 00:03:00.389
并且 有时候 概率性的优化

00:03:00.389 --> 00:03:03.569
意味着它们最终会找出一个解来

00:03:03.569 --> 00:03:06.194
前提是 给它们足够的计算时间

00:03:06.194 --> 00:03:08.504
上面我们大略过了一遍

00:03:08.504 --> 00:03:11.859
当前存在的各种不同的规划算法

00:03:11.860 --> 00:03:15.005
算法很多 我不可能列出详细清单来

00:03:15.004 --> 00:03:17.099
但是 我强烈建议大家关注一下其中的一些算法

00:03:17.099 --> 00:03:20.329
并学习一下 看它们是如何工作的

00:03:20.330 --> 00:03:24.600
接下来 我会向大家的展示一下混合 A* 算法

00:03:24.599 --> 00:03:27.944
但是开始之前 我想请大家看一下之前看过的有关 A* 的视频

00:03:27.944 --> 00:03:32.500
并回答与 A* 性质相关的几个问题

