WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:04.000
我将向大家展示的下一个算法称为 混合 A* 算法

00:00:04.000 --> 00:00:06.455
为了介绍此算法

00:00:06.455 --> 00:00:10.245
我先和大家分享一个视频 这是 Sebastian 为另一个课程录制的

00:00:10.244 --> 00:00:13.439
然后 我会问大家一些问题

00:00:13.439 --> 00:00:16.699
这些问题和前面有关 A* 算法的问题相同

00:00:16.699 --> 00:00:20.265
那么 现在我们就开始讨论有关机器人路径规划或者机器人运动规划的问题

00:00:20.265 --> 00:00:23.050
这个领域涉及内容甚广

00:00:23.050 --> 00:00:26.355
我不可能讲到所有内容

00:00:26.355 --> 00:00:29.455
但是 与前面我们讲规划的时候不同

00:00:29.454 --> 00:00:33.539
现在 我们强调的一个关键词是 连续性

00:00:33.539 --> 00:00:36.939
例如 在我们讲解 A* 时 我们是将世界离散化的

00:00:36.939 --> 00:00:38.655
那里也许有一个目标位置 一些障碍物

00:00:38.655 --> 00:00:41.534
然后通过运行 A*

00:00:41.534 --> 00:00:45.019
会生成一个有效的动作序列 看起来类似这样

00:00:45.020 --> 00:00:48.345
尽管这是一个规划问题的有效解

00:00:48.344 --> 00:00:51.475
实际上 一辆车是不可能沿着这些离散路径行进的

00:00:51.475 --> 00:00:54.329
因为 这里有一些特别急的转弯

00:00:54.329 --> 00:00:58.125
对于一辆车而言 这种动作是不可行的

00:00:58.125 --> 00:01:00.840
所以这里的根本问题是

00:01:00.840 --> 00:01:04.182
A* 是离散的 而机器人世界需要连续性

00:01:04.182 --> 00:01:05.439
这就产生一个问题

00:01:05.439 --> 00:01:08.745
是否有某种 A* 算法可以解决连续性问题

00:01:08.745 --> 00:01:12.770
并有可能给出实际可行的路径？

00:01:12.769 --> 00:01:16.045
在机器人运动规划领域 这是一个极其重要的问题

00:01:16.045 --> 00:01:19.320
我会通过这个例子来讨论一下上述问题

00:01:19.319 --> 00:01:23.069
并给大家展示一下我们是如何通过一个达夫探查来解决此问题的

00:01:23.069 --> 00:01:28.704
使用 A* 解决此问题的关键在于利用一个状态转换函数

00:01:28.704 --> 00:01:31.950
假设我们在这样的一个单元格内

00:01:31.950 --> 00:01:36.555
然后大家使用我们先前的连续性数学算法运行一些列小步进模拟

00:01:36.555 --> 00:01:39.240
然后 这里的一个状态或许会发现

00:01:39.239 --> 00:01:43.679
它自己在下一个离散状态的角落里

00:01:43.680 --> 00:01:46.230
混合 A*算法不会把这些值赋予单元格

00:01:46.230 --> 00:01:51.165
它会记忆 X’ Y’ 以及 theta' 

00:01:51.165 --> 00:01:53.730
当首次扩展到这个单元格时

00:01:53.730 --> 00:01:56.835
它会把这些值和这个单元格关联起来

00:01:56.834 --> 00:01:58.974
然后 当从这个单元格扩展时

00:01:58.974 --> 00:02:03.594
它使用一个这里特定的开始点来算出下一个单元格也许是什么

00:02:03.594 --> 00:02:06.900
现在 很可能发生的事情是 在 A* 算法中 从这里出发 

00:02:06.900 --> 00:02:11.175
经过的同一单元格可能会算出不同的连续性聚合值 X Y 以及 theta

00:02:11.175 --> 00:02:14.280
但是因为在 A* 里 我们倾向于沿着最短路径扩展单元格

00:02:14.280 --> 00:02:17.914
然后我们才会选择更长点的路径

00:02:17.914 --> 00:02:22.060
我们不但会把这个排除 并且永远不会考虑回到这里

00:02:22.060 --> 00:02:25.920
现在 这导致了完整性损失

00:02:25.919 --> 00:02:28.109
意味着这里或许有解

00:02:28.110 --> 00:02:30.740
但是本算法并没有去处理

00:02:30.740 --> 00:02:33.159
但是算法为我们保证了 合理性

00:02:33.159 --> 00:02:35.444
所以 只要我们的运行方程是正确的

00:02:35.444 --> 00:02:37.864
结果路径便是可行驶的

00:02:37.865 --> 00:02:39.600
这里 有个警告

00:02:39.599 --> 00:02:41.969
这是一个近似值

00:02:41.969 --> 00:02:44.844
只在判断这些运动方程正确或者不正确时有效

00:02:44.844 --> 00:02:48.389
但是无论如何 所有得出的路径都是相当不错的

00:02:48.389 --> 00:02:50.309
相当平滑 没有急转弯

00:02:50.310 --> 00:02:52.650
然后每次我们扩展单元格

00:02:52.650 --> 00:02:56.069
我们会明确保留

00:02:56.069 --> 00:02:58.289
与此单元格相关的 X’ Y’ 以及 theta 的连续值

