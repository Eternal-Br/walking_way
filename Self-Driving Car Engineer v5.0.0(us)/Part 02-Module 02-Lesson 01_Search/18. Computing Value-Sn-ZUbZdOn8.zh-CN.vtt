WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:04.000
我们来看一下一段简单的代码 这段代码实现了规划算法

00:00:04.000 --> 00:00:09.000
这是先前我们用过的、用0和1填充的表格 大家已经很熟悉了

00:00:09.000 --> 00:00:13.000
开始点位于左上角 目标点在右下角

00:00:13.000 --> 00:00:19.000
我们可以设置任意障碍 比如这里的一堵墙 这里也是一堵墙

00:00:19.000 --> 00:00:23.000
这样会迫使机器人绕着拐角做一个 S 型的的转弯

00:00:23.000 --> 00:00:29.000
如果我用这个表格来运行代码 我会得到这样的一个表格作为输出

00:00:29.000 --> 00:00:33.000
表格里有一些状态 墙的位置没有状态

00:00:33.000 --> 00:00:35.000
这个表格可以告诉我们如何去优化路径

00:00:35.000 --> 00:00:40.000
在这里 表格显示向下 在这里显示向右 这里显示向上

00:00:40.000 --> 00:00:43.000
这里显示继续向右 然后向下

00:00:43.000 --> 00:00:46.000
大家注意这些相等的状态 这些地方我们很可能不会经过

00:00:46.000 --> 00:00:49.000
类似于这里 以及这里 它们都附带着优化策略以及伴随动作

00:00:49.000 --> 00:00:53.000
这是因为 在这里并不存在一个开始状态

00:00:53.000 --> 00:00:55.000
只是在这里有一个目标状态

00:00:55.000 --> 00:01:00.000
指定最初状态并不会改变这个结果

00:01:00.000 --> 00:01:04.000
我们如何高效地计算出这样的结果？

00:01:04.000 --> 00:01:09.000
我来举个简单例子 我们有个这样的世界 这里有个障碍物

00:01:09.000 --> 00:01:12.000
假设目标在这里的角上

00:01:12.000 --> 00:01:15.000
这里我不会告诉大家如何计算出最优策略

00:01:15.000 --> 00:01:18.000
最优策略会给每个单元格赋予一个动作

00:01:18.000 --> 00:01:20.000
但是我会告诉大家什么是 “价值”

00:01:20.000 --> 00:01:28.000
价值函数会给每个单元格赋予一个值 等于单元格到目标的最短距离

00:01:28.000 --> 00:01:31.000
对于目标单元格 很显然 这个值为0

00:01:31.000 --> 00:01:34.000
然后 和目标相邻的单元格值为1 这很好理解

00:01:34.000 --> 00:01:44.000
这里的单元格 值分别为 2 3 4 5 6 7

00:01:44.000 --> 00:01:51.000
这是一种递归运算 把相邻单元格的值作为输入 包括 x’ 以及 y’

00:01:51.000 --> 00:01:56.000
考虑它的值 并加上到达它们的成本值

00:01:56.000 --> 00:01:59.000
在我们的例子中成本是1

00:01:59.000 --> 00:02:02.000
通过递归使用这个方程式

00:02:02.000 --> 00:02:04.000
我们可以实现这里的价值函数

00:02:04.000 --> 00:02:08.000
一旦我们有了价值函数 我们会发现

00:02:08.000 --> 00:02:15.000
优化的控制动作通过最小化价值来获得 这是有关动作的一种爬山算法 

00:02:15.000 --> 00:02:18.000
这里有个小测验

00:02:18.000 --> 00:02:22.000
在这张图上 目标点在这里

00:02:22.000 --> 99:59:59.999
我想问大家 右下角单元格的价值是多少

