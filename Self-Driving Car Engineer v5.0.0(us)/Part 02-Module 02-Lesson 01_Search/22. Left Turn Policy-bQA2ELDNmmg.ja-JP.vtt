WEBVTT
Kind: captions
Language: ja-JP

00:00:00.000 --> 00:00:05.000
それではこれを実際の車の課題に応用してみましょう

00:00:05.000 --> 00:00:10.000
使用するものはいつものように少し簡略化されていますが

00:00:10.000 --> 00:00:15.000
現実的なパスプランニングに関連していて Google マップなどでも応用されています

00:00:15.000 --> 00:00:17.000
ここに車があるとします

00:00:17.000 --> 00:00:23.000
この車の状態は x と y 方向は θ です

00:00:23.000 --> 00:00:34.000
わかりやすくするために方向は 4 方向 上 下 左 右から選択します

00:00:34.000 --> 00:00:39.000
冒頭でのクイズと同じように この場所に左を向いて到達したいと思います

00:00:39.000 --> 00:00:46.000
ローカライゼーションの例と同様 今回の状態空間も三次元になります

00:00:46.000 --> 00:00:50.000
では動的プログラミングプランナーを実装し

00:00:50.000 --> 00:00:53.000
ここからここまでの最適な経路を見つけます

00:00:53.000 --> 00:00:55.000
そしてコスト関数について色々試してみましょう

00:00:55.000 --> 00:00:58.000
原理動作は 3 つあります

00:00:58.000 --> 00:01:05.000
1 つ目は車が現在の方向に向かってグリッドセル 1 つ前進する動作です

00:01:05.000 --> 00:01:10.000
直進のみの動作です迷路のどの場所でもどの方向にも応用できます

00:01:10.000 --> 00:01:14.000
2 つ目は車が左折して前進する動作です

00:01:14.000 --> 00:01:20.000
車がこのセルの位置にいる場合

00:01:20.000 --> 00:01:23.000
左折することができ このセルに移動します

00:01:23.000 --> 00:01:26.000
最後の 3 つ目は右折して前進する動作です

00:01:26.000 --> 00:01:29.000
その場合 車はこのセルから右折し

00:01:29.000 --> 00:01:31.000
このセルに移動します

00:01:31.000 --> 00:01:33.000
私たちの世界をもう一度見てみましょう

00:01:33.000 --> 00:01:36.000
ここに通行できる道があり横の道も通行できます

00:01:36.000 --> 00:01:39.000
右側はループになっています

00:01:39.000 --> 00:01:43.000
この状態空間は二次元ではなく三次元だということを思い出してください

00:01:43.000 --> 00:01:47.000
私たちのゴールはセル [2, 0] に移動することです ここですね

00:01:47.000 --> 00:01:50.000
初期状態はここです

00:01:50.000 --> 00:01:54.000
初期状態は [4. 3] という位置だけではなく 0 という方向も持っています

00:01:54.000 --> 00:01:57.000
つまり三次元の状態です

00:01:57.000 --> 00:02:02.000
ここにあるのが方向です 0 1 2 3 です

00:02:02.000 --> 00:02:05.000
1 番目はロボットが上へ進みます 2 番目は左へ進みます

00:02:05.000 --> 00:02:08.000
3 番目は下へ進みます 4 番目は右へ進みます

00:02:08.000 --> 00:02:11.000
これは関連付けられている名前です up left down right

00:02:11.000 --> 00:02:13.000
ちょっと面白いことを説明します

00:02:13.000 --> 00:02:16.000
私たちには 3 つの動作があります

00:02:16.000 --> 00:02:20.000
指数方位の -1 0 1 を追加します

00:02:20.000 --> 00:02:24.000
-1 を追加した場合 ここの巡回配列で 1 つ上に行きます

00:02:24.000 --> 00:02:27.000
右折を行うのと同じことになります

00:02:27.000 --> 00:02:34.000
たとえば go left から go up に進むと 右折したことと同じになります

00:02:34.000 --> 00:02:38.000
+1 を加えると左折と同じことになります

00:02:38.000 --> 00:02:41.000
方向を変更せずに直進する場合は

00:02:41.000 --> 00:02:46.000
ここにある # 記号で示されます

00:02:46.000 --> 00:02:48.000
これらの動作には異なるコストがかかります

00:02:48.000 --> 00:02:51.000
左折のコストは 2 で直進のコストは 1 です

00:02:51.000 --> 00:02:54.000
そして右折のコストも 1 です 皆さんもお分かりのとおり

00:02:54.000 --> 00:02:58.000
ここでは左折が優先される解決策になります

00:02:58.000 --> 00:03:04.000
実際にこれを実行すると車がここで左折してゴール位置に向かうのがわかります

00:03:04.000 --> 00:03:10.000
もし私が左折のコストを 20 に増やしたとしたら解決策が変わります

00:03:10.000 --> 00:03:13.000
車はここまで直進し ここで右折して

00:03:13.000 --> 00:03:18.000
ここで右折 また右折してゴール位置まで直進します

00:03:18.000 --> 00:03:21.000
これが皆さんに実装してほしいソフトウェアですヒントがもう 1 つあります

00:03:21.000 --> 00:03:27.000
価値関数自体は三次元で これが私が使用しているコードです

00:03:27.000 --> 00:03:33.000
効率的ではありませんが この関数にはグリッドサイズに関する同一の配列が 4 つ

00:03:33.000 --> 00:03:37.000
あり 巨大なグリッドに連結されています

00:03:37.000 --> 00:03:41.000
また 非常に大きな値 999 ですべて初期化されています

00:03:41.000 --> 00:03:47.000
皆さんはこれに似た関数が必要であり コードの記述が難しくなっています

00:03:47.000 --> 00:03:50.000
この講義の最後のクイズになります

00:03:50.000 --> 00:03:53.000
この最後の課題は多少時間がかかるかもしれません

00:03:53.000 --> 99:59:59.999
私自身もプログラミングして この出力を得るまでに少し時間がかかりました

