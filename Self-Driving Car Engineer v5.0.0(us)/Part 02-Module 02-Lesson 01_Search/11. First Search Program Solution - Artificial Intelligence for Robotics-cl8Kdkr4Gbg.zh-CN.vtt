WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:04.000
这是我的解决方案 —— 我定义一个函数 " search "  

00:00:04.000 --> 00:00:07.000
这是我在最后运行的唯一函数 它就像是主程序  

00:00:07.000 --> 00:00:12.000
为了避免重复展开单元格  

00:00:12.000 --> 00:00:18.000
我定义一个名为 " closed " 的数组 大小与我的网格相同  

00:00:18.000 --> 00:00:23.000
它有两个值 0 和 1 —— 0 代表它仍然是开放的 1 表示它已被关闭  

00:00:23.000 --> 00:00:25.000
你也可以使用布尔值  

00:00:25.000 --> 00:00:31.000
在这里分配与网格大小一致的数组  

00:00:31.000 --> 00:00:36.000
将起始位置标记为关闭 

00:00:36.000 --> 00:00:42.000
分配好坐标值 x y 和 初始的 g 值 0 

00:00:42.000 --> 00:00:47.000
我初始化的 open 列表只有一个元素 就是我的初始坐标 g 值为 0  

00:00:47.000 --> 00:00:52.000
到目前为止 我已经定义了一个跟网格大小一致的 closed 数组  

00:00:52.000 --> 00:00:55.000
只有左上角的元素做了标记  

00:00:55.000 --> 00:01:01.000
这就是我在 open 列表中的起点 g 值为 0  

00:01:01.000 --> 00:01:04.000
代码里我用了两个标记 —— 一个是 found  

00:01:04.000 --> 00:01:07.000
当目标位置被发现时 它将赋值为 true 一个是 resign  

00:01:07.000 --> 00:01:11.000
当我还找不到目标位置 并且已经没有其他地方可以展开时它将被赋值为 true 

00:01:11.000 --> 00:01:15.000
第二个会发生在我的 open 列表已经被清空的情况下  

00:01:15.000 --> 00:01:19.000
这在我找不到目标路径的情况下真的很重要  

00:01:19.000 --> 00:01:23.000
这些 print 命令是我用来调试的  

00:01:23.000 --> 00:01:26.000
你可以看一下它们 它们仅仅是将 open 列表打印出来  

00:01:26.000 --> 00:01:28.000
下面就是真正的代码  

00:01:28.000 --> 00:01:32.000
我将重复下面的代码块 在我还没有找到一个目标路径  

00:01:32.000 --> 00:01:35.000
并且还没有证明这个问题是无法解决的情况下  

00:01:35.000 --> 00:01:38.000
这时 found 与 resign 均为 false 

00:01:38.000 --> 00:01:45.000
如果我的 open 列表是空的 再也没有可展开的节点 这时将 resign 置为 true 然后打印出 " fail "  

00:01:45.000 --> 00:01:47.000
这是 2 个终止条件的一个  

00:01:47.000 --> 00:01:51.000
你可以说服自己从 S 到 G 没有有效路径 

00:01:51.000 --> 00:01:54.000
你展开障碍左侧的每一个节点 

00:01:54.000 --> 00:01:58.000
直到我们再也没有节点可以展开 

00:01:58.000 --> 00:02:02.000
此时 open 列表是空的 我们的搜索失败了  

00:02:02.000 --> 00:02:06.000
如果 open 列表中仍然还有元素 那么就跳到 else 

00:02:06.000 --> 00:02:13.000
这是我如何删除最小 g 值元素的代码  

00:02:13.000 --> 00:02:18.000
我使用了列表的排序功能 以递增的方式排列元素 

00:02:18.000 --> 00:02:20.000
根据 g 值从小到大排列  

00:02:20.000 --> 00:02:23.000
现在我想弹出值最小的元素  

00:02:23.000 --> 00:02:27.000
然后 pop 方法是从头部弹出的 因此我需要将列表翻转 

00:02:27.000 --> 00:02:32.000
然后弹出该列表中 g 值最小的元素  

00:02:32.000 --> 00:02:35.000
这里有点繁琐 不是很优雅  

00:02:35.000 --> 00:02:38.000
也不是很高效 不过它可以用  

00:02:38.000 --> 00:02:42.000
这就是我得到的最小 g 值的元素  

00:02:42.000 --> 00:02:46.000
有一点很重要就是需要 g 值排在前面  

00:02:46.000 --> 00:02:49.000
这就是为什么我把它放在 x 和 y 前面  

00:02:49.000 --> 00:02:56.000
然后我将 X Y 和 g 赋值 这是我要展开的  

00:02:56.000 --> 00:03:01.000
同样 g 排第一 x y 在第二和第三  

00:03:01.000 --> 00:03:04.000
现在我需要检测自己是否已经到达目标  

00:03:04.000 --> 00:03:08.000
如果 x 等于 goal 0 y 等于 goal 1 那么我完成了 我将 found 赋值为 true  

00:03:08.000 --> 00:03:11.000
我把它们打印出来 就在这里  

00:03:11.000 --> 00:03:15.000
这里的 " print next " 就是我需要找的  

00:03:15.000 --> 00:03:19.000
让你在这里打印出精确的解决方案  

00:03:19.000 --> 00:03:22.000
现在 如果我还没有完成 这就是有趣的情况  

00:03:22.000 --> 00:03:24.000
这就是我代码的核心  

00:03:24.000 --> 00:03:27.000
我历遍了所有可能的动作 在此有 4 个  

00:03:27.000 --> 00:03:29.000
Delta 就是包含这 4 个动作的数组  

00:03:29.000 --> 00:03:33.000
我将 delta 向量上对应的动作加到 x 和 y 上面 

00:03:33.000 --> 00:03:37.000
赋值到 x2 和 y2  

00:03:37.000 --> 00:03:48.000
如果 X2 在网格内 y2 在网格内 并且 [x2, y2] 尚未标记  

00:03:48.000 --> 00:03:51.000
也就是通过检查 " closed " 相应的元素来完成  

00:03:51.000 --> 00:03:55.000
还有就是网格中这个单元可以走 —— 这里没有障碍  

00:03:55.000 --> 00:04:00.000
如果所有这些东西都是正确的 那么我找到了一个展开 然后我把它加到 open 列表中  

00:04:00.000 --> 00:04:07.000
我将花费由 g 递增 1 赋值到 g2 现在花费是 1 

00:04:07.000 --> 00:04:11.000
然后 我把新的 [g2, x2, y2] 添加到我的 open 列表  

00:04:11.000 --> 00:04:15.000
我标记了 [x2, y2] 所以我不会对其进行重复展开  

00:04:15.000 --> 00:04:18.000
这是递归  

00:04:18.000 --> 00:04:23.000
换句话说 例如 当我来到了这个元素这里  

00:04:23.000 --> 00:04:27.000
我看了一下机器人的所有可能移动的方式  

00:04:27.000 --> 00:04:30.000
在我的代码中 这意味着机器人必须留在网格内  

00:04:30.000 --> 00:04:34.000
以及该网格单元没有被占用 就是这里的检查  

00:04:34.000 --> 00:04:37.000
我还检查该单元是否已经被标记  

00:04:37.000 --> 00:04:41.000
就是这里的测试 在这里它总是 true  

00:04:41.000 --> 00:04:45.000
我把新的元素添加到 open 列表 

00:04:45.000 --> 00:04:50.000
其值为增加后的新的 g 值以及新的坐标  

00:04:50.000 --> 00:04:52.000
这正是这里发生的  

00:04:52.000 --> 00:04:56.000
我增加 g 值 然后将它与新坐标一起加上去  

00:04:56.000 --> 00:04:58.000
这就是此搜索算法的核心  

00:04:58.000 --> 00:05:01.000
剩下唯一的事情就是 我所说的搜索程序 

00:05:01.000 --> 99:59:59.999
它在这里把这个东西打印出来  

