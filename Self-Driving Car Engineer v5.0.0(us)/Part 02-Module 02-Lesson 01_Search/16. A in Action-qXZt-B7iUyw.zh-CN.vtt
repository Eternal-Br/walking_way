WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:04.000
这里是一个用在 DARPA 城市挑战赛中的真实算法实现

00:00:04.000 --> 00:00:07.000
试验车 Stanford 试图在迷宫中找到一条路

00:00:07.000 --> 00:00:09.000
大家可以看到 当汽车运行时 迷宫在不断变化

00:00:09.000 --> 00:00:14.000
这显示出汽车正在用传感器探测障碍物

00:00:14.000 --> 00:00:16.000
而障碍物在某些时候会被汽车考虑在内

00:00:16.000 --> 00:00:19.000
因为只有在障碍物足够近时 汽车才会探测到它们

00:00:19.000 --> 00:00:22.000
这是非常值得一提的是

00:00:22.000 --> 00:00:24.000
这辆车可以规划出相当复杂的动作来到达目标

00:00:24.000 --> 00:00:27.000
在任意时间点上 我们都可以看到 汽车做出了最佳决策找到出路并到达目标

00:00:27.000 --> 00:00:32.000
这些橘色的树是 A-star 的搜索树

00:00:32.000 --> 00:00:35.000
它们不是严格的网格树

00:00:35.000 --> 00:00:38.000
该车的运动与基于网格的机器人有所不同

00:00:38.000 --> 00:00:43.000
它可以以不同角度转弯 这里汽车走的每一小步

00:00:43.000 --> 00:00:46.000
都是不同的转向角与不同前进动作结合的结果

00:00:46.000 --> 00:00:49.000
把这些拿掉 我们就得到这些非常不错的树

00:00:49.000 --> 00:00:52.000
它们使用 A-star 来找到通向目标的路径

00:00:52.000 --> 00:00:55.000
这个实现运行得非常快

00:00:55.000 --> 00:01:00.000
它可以在小于10毫秒时间内 从这个迷宫中的任意一点出发计算出这些树来

00:01:00.000 --> 00:01:05.000
据我所知 在参加 DARPA Grand 挑战赛和 DARPA 都市挑战赛的所有团队中

00:01:05.000 --> 00:01:07.000
这个算法是最快的

00:01:07.000 --> 00:01:11.000
每当机器人取消前一个规划时 这个算法便重新生成一个新的规划

00:01:11.000 --> 00:01:14.000
大家可以看到在不同地方它所做的调整

00:01:14.000 --> 00:01:18.000
当大家看完这个视频 大家就会明白

00:01:18.000 --> 00:01:26.000
A-star 是如何使用一个简单的欧几里得距离作为启发值来找出到达目标的路径的

00:01:26.000 --> 00:01:29.000
当大家自己实现这个算法后 大家就会知道

00:01:29.000 --> 00:01:32.000
这个实现和网格实现的巨大区别在于 这是一个不同的运动模型

00:01:32.000 --> 00:01:35.000
要实现它 你必须实现一个能够转向的机器人

00:01:35.000 --> 00:01:38.000
你必须从数学上实现让它转向或者直行的算法

00:01:38.000 --> 00:01:42.000
这个机器人还能重新规划路径 向后倒车操作和前面的操作有巨大区别

00:01:42.000 --> 00:01:46.000
除了这个之外 这个机器人身上的算法和大家实现的基本相同

00:01:46.000 --> 00:01:49.000
因此 如果你想要造一辆无人驾驶汽车出来

00:01:49.000 --> 00:01:54.000
你现在已经能够做到实现一个相当复杂的、但是很有效的路径搜索算法

00:01:54.000 --> 00:02:02.000
这里是 DARPA 上的一个场景 这个场景中有一个完全横在街道上的障碍物 试图困住车辆 

00:02:02.000 --> 00:02:08.000
汽车只有在做出一系列 U 型转弯操作后才能到达目的地

00:02:08.000 --> 00:02:13.000
而它不得不使用 A-star 来计算出这些路径来

00:02:13.000 --> 00:02:18.000
该车在障碍物前停下 意识到前方没有路了

00:02:18.000 --> 00:02:23.000
然后呼叫 A-star 规划器 规划器发出掉头指令

00:02:23.000 --> 00:02:27.000
这个操作看起来很笨拙 而且却相当有效

00:02:27.000 --> 00:02:32.000
在那次竞赛中 这辆使用 A-star 的车能够做到自己掉头

00:02:32.000 --> 00:02:35.000
为掉头找出优化的行动方案 然后继续行进

00:02:35.000 --> 00:02:39.000
否则 它将永远被这个障碍物困在这里

00:02:39.000 --> 00:02:44.000
在最后的视频中 我会向大家展示一个停车场的场景

00:02:44.000 --> 00:02:49.000
这里我们的车必须倒车进入两辆车的夹缝中

00:02:49.000 --> 00:02:55.000
大家能看到障碍物 其他车辆 以及我们的车 Jr 是如何在真正的停车场中运动的

00:02:55.000 --> 00:02:57.000
这次用的算法依然是 A-star

00:02:57.000 --> 00:03:00.000
它找出优化的路径后 独自进入停车点

00:03:00.000 --> 00:03:02.000
然后又独自驶出

00:03:02.000 --> 00:03:06.000
每次动作的规划时间小于10毫秒

00:03:06.000 --> 00:03:09.000
这辆车完全可以做到这些

00:03:09.000 --> 00:03:12.000
尽管在一开始行驶过程中车辆并不知道障碍物位于何处

00:03:12.000 --> 00:03:13.000
停车点在哪里

00:03:13.000 --> 00:03:19.000
上面就是机器人路径规划的 A-star 算法 大家实现的部分就是算法的核心部分

00:03:19.000 --> 00:03:24.000
接下来 如果大家想要把自己的算法完善成一个真正的机器人运动算法

00:03:24.000 --> 00:03:27.000
就必须更改运动模型

00:03:27.000 --> 00:03:30.000
大家可以继续学习我在下一课程中要讲的内容

00:03:30.000 --> 99:59:59.999
到时我会讲连续性模型 并且会告诉大家怎样把当前的路径优化成连续路径

