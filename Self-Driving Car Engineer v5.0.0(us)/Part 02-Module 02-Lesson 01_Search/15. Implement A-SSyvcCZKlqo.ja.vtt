WEBVTT
Kind: captions
Language: ja

00:00:00.000 --> 00:00:05.000
実際に実装するプログラムは
これまで実装したものに比べて

00:00:05.000 --> 00:00:08.000
極めて短いことが分かります

00:00:08.000 --> 00:00:14.000
この変更を加えて実装したA＊は
最も強力な探索アルゴリズムの1つであり

00:00:14.000 --> 00:00:18.000
未整備の環境での自動運転車に
現在使用されています

00:00:18.000 --> 00:00:22.000
まず最初にopenリストの要素を展開し
以前のように

00:00:22.000 --> 00:00:25.000
g値だけ含めるのではなく
f値も含めるようにします

00:00:25.000 --> 00:00:31.000
また私はh値も含めましたが
必ずしもそうする必要はありません

00:00:31.000 --> 00:00:34.000
今回は5つの要素を使用しg値は以前と同じです

00:00:34.000 --> 00:00:39.000
hはセルx、yのヒューリスティック値であり
fはgとhの合計です

00:00:39.000 --> 00:00:43.000
fを左端に記述したのは
ソート処理に必要だからです

00:00:43.000 --> 00:00:47.000
これでリストをソートするときに
fを基準にソートされます

00:00:47.000 --> 00:00:51.000
2つの要素が加えられたことに注目してください

00:00:51.000 --> 00:00:57.000
またfを左端に移動させることで
g値の最小値ではなく

00:00:57.000 --> 00:01:01.000
f値の最小値をもつ要素が
取り出されるようになっています

00:01:01.000 --> 00:01:06.000
さらに下がってこれらの行で
記述されているようにノードを展開します

00:01:06.000 --> 00:01:11.000
次の構造のようにインデックスに
少し変更を加える必要があります

00:01:11.000 --> 00:01:14.000
ここではxが要素番号3になります

00:01:14.000 --> 00:01:18.000
インデックスが0から始まる場合
正確にはリストで4番目の要素となります

00:01:18.000 --> 00:01:21.000
yは4番目でgは1番目の要素です

00:01:21.000 --> 00:01:28.000
fとhはすぐに計算できるので
ここで指定する必要はありません

00:01:28.000 --> 00:01:34.000
さらに下がって
ここでノードをリストから展開します

00:01:34.000 --> 00:01:39.000
そして考えられるすべての動作
および次の状態を計算し

00:01:39.000 --> 00:01:42.000
展開する上で適切な状態であるかテストします

00:01:42.000 --> 00:01:48.000
これまでと同様gはcost関数の分だけ加算しますが
ここに新しいコードが2行あります

00:01:48.000 --> 00:01:52.000
最初の行では新しく展開したノードの
ヒューリスティック関数を計算します

00:01:52.000 --> 00:01:54.000
これは極めて単純なものでh2と呼びます

00:01:54.000 --> 00:02:00.000
それから次のコード行では
g値とh値の新しい合計を計算します

00:02:00.000 --> 00:02:06.000
次の5つの値を使用して
新しいf値、新しいg値、新しいh値

00:02:06.000 --> 00:02:10.000
そして展開ノードのx、y座標を
openリストに付加します

00:02:10.000 --> 00:02:14.000
新しい値として最も重要なのはf値ですが
h値も重要です

00:02:14.000 --> 00:02:18.000
A＊の実装については以上です

00:02:18.000 --> 00:02:21.000
つまりg値の最小値ではなく

00:02:21.000 --> 00:02:26.000
f値の最小値を持つノードが選択されるように
ロジックを変更しただけです

00:02:26.000 --> 00:02:30.000
これがA＊を実装する方法です

00:02:30.000 --> 00:02:32.000
ではこれを実行してみましょう

00:02:32.000 --> 00:02:34.000
これは以前に見た迷路のグリッドです

00:02:34.000 --> 00:02:38.000
最上部を空けるようにして下を壁でふさぎます

00:02:38.000 --> 00:02:41.000
この場合A＊はあまり有効に機能しません

00:02:41.000 --> 00:02:44.000
このエリアにはどちらの道に
進むかという優先度がなく

00:02:44.000 --> 00:02:46.000
A＊はやっとゴールノードを見つけます

00:02:46.000 --> 00:02:50.000
ただしここに大きな障害物を
水平に設置すると状況が変わります

00:02:50.000 --> 00:02:54.000
非常に興味深いことにA＊は水平方向の経路と
垂直方向の経路のどちらが

00:02:54.000 --> 00:02:56.000
最適かを決められないことが分かります

00:02:56.000 --> 00:03:01.000
そのため水平方向と垂直方向のノードを
行ったり来たりします

00:03:01.000 --> 00:03:05.000
端に到達した時点で以前と同じ手法が適用されます

00:03:05.000 --> 00:03:10.000
中央部でノードが展開されなくなりゴール方向に
まっすぐ進んで到達します

00:03:10.000 --> 00:03:12.000
A＊を使用しない場合には起こりません

00:03:12.000 --> 00:03:17.000
古い探索アルゴリズムに戻す方法は空の
ヒューリスティック関数を指定することです

00:03:17.000 --> 00:03:24.000
これがどこでも常にhをゼロに初期化する
ヒューリスティック関数の定義であり

00:03:24.000 --> 00:03:27.000
このヒューリスティック関数の代わりに使用します

00:03:27.000 --> 00:03:30.000
今は使わないのでheuristic＿oldとします

00:03:30.000 --> 00:03:35.000
値がすべて0のヒューリスティック関数を用いて
実行すると元の検索アルゴリズムに戻ります

00:03:35.000 --> 00:03:39.000
ご覧のようにこの探索アルゴリズムでは
内側が少し探索され

00:03:39.000 --> 00:03:42.000
その結果A＊の場合よりも
多くのノードが展開されています

00:03:42.000 --> 00:03:47.000
これはささいなことに見えますが
非常に大規模な環境では大きな違いが出ます

00:03:47.000 --> 00:03:51.000
ゴールに到達できない袋小路がある場合は
特に顕著です

00:03:51.000 --> 00:03:55.000
このようにA＊は単純な探索に比べて
はるかに効率的に機能します

