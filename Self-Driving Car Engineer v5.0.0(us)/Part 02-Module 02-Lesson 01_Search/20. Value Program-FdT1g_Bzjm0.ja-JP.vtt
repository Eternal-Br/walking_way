WEBVTT
Kind: captions
Language: ja-JP

00:00:00.000 --> 00:00:04.000
次のように実装します これはわりと単純です

00:00:04.000 --> 00:00:07.000
この value 関数はあまりに大きすぎるので

00:00:07.000 --> 00:00:10.000
いつも 99 で初期化しています

00:00:10.000 --> 00:00:15.000
これは 実際の値と競合しないくらい大きい数として評価する必要があります

00:00:15.000 --> 00:00:19.000
value 関数を何度か更新します 回数は覚えていませんが

00:00:19.000 --> 00:00:22.000
何かを変更するということなので 更新します

00:00:22.000 --> 00:00:26.000
ここで変数「change」を導入します 最初は True に設定します

00:00:26.000 --> 00:00:30.000
while change は case 文です 更新して change を False に設定します

00:00:30.000 --> 00:00:34.000
これを True に戻す唯一の方法は 何かを変更することです

00:00:34.000 --> 00:00:38.000
決められた順番でグリッドセルを全部見ていきます

00:00:38.000 --> 00:00:42.000
効果的とは言い切れませんが 目的は果たせます

00:00:42.000 --> 00:00:46.000
まずは問題のグリッドセルがゴールかどうかを確認します

00:00:46.000 --> 00:00:49.000
ここは change をチェックする典型的な箇所です

00:00:49.000 --> 00:00:53.000
value が正しく 0 に設定されていれば 何もしません

00:00:53.000 --> 00:00:59.000
0 よりも大きい 99 のような場合は 0 に設定し直します これで何かを変更したことになります

00:00:59.000 --> 00:01:02.000
したがって change フラグを True に戻します

00:01:02.000 --> 00:01:07.000
ゴールのセルではない場合は 完全版の更新関数がこのようになります

00:01:07.000 --> 00:01:10.000
すべてのアクションを見ていきましょう

00:01:10.000 --> 00:01:14.000
対応するデルタを x と y に追加して アクションを実行し

00:01:14.000 --> 00:01:17.000
有効な次の文を予想します

00:01:17.000 --> 00:01:20.000
x2 と y2 が得られます

00:01:20.000 --> 00:01:24.000
x2 と y2 が正当な文かテストします

00:01:24.000 --> 00:01:26.000
それにはグリッド内に存在する必要があります

00:01:26.000 --> 00:01:31.000
数字が 0 より大きいか グリッドの次元より小さいかを確認します

00:01:31.000 --> 00:01:34.000
これは そのアクションが通行可能なグリッドセルである必要があります

00:01:34.000 --> 00:01:38.000
したがって グリッド内の座標が 0 であることを確認します

00:01:38.000 --> 00:01:41.000
0 であれば 値を逆に伝播できます

00:01:41.000 --> 00:01:46.000
来たるべきグリッドセルに cost_step を足した新しい値は

00:01:46.000 --> 00:01:48.000
1 になります

00:01:48.000 --> 00:01:53.000
これが既存の値よりも良い つまりより小さい場合は

00:01:53.000 --> 00:02:01.000
新しい値を元のグリッドセル x と y もちろん cost_step も足して ここに割り当てます

00:02:01.000 --> 00:02:04.000
これで 内容を変更したのは確実です

00:02:04.000 --> 00:02:08.000
したがって change を「True」に設定して プロシージャーを繰り返します

00:02:08.000 --> 00:02:11.000
ここまでやってきた中で 1 つだけ足りないのは

00:02:11.000 --> 00:02:14.000
ここの これらのコマンドを使用して value 関数を出力することです

00:02:14.000 --> 00:02:17.000
効率的なやり方ではないことを忠告しておきます

00:02:17.000 --> 00:02:20.000
そうなってしまう理由は この value が始点から終点まで

00:02:20.000 --> 00:02:23.000
ゆっくりと伝播されるためです

00:02:23.000 --> 00:02:26.000
この心配はさておき 正しい value 関数を計算します

00:02:26.000 --> 00:02:28.000
もっと効率的にする方法もあります

00:02:28.000 --> 00:02:33.000
ゴールへの経路を切り詰めたとき何が起きるか 確認するのも面白いです

00:02:33.000 --> 00:02:37.000
結果の value 関数では ほとんどの state 変数が 99 を持ち続けます

00:02:37.000 --> 99:59:59.999
こうした箇所には ゴールへの有効な経路はありません

