WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:05.000
结果证明 与大家的实现相比

00:00:05.000 --> 00:00:08.000
这里的实现确实是最小化的

00:00:08.000 --> 00:00:10.000
这样修改后 大家就实现了 A-Star

00:00:10.000 --> 00:00:14.000
这是最强大的搜索算法之一 目前已使用在非结构化环境中

00:00:14.000 --> 00:00:18.000
来驱动无人驾驶汽车

00:00:18.000 --> 00:00:22.000
第一步我们做的就是在 open 列表中扩展元素

00:00:22.000 --> 00:00:25.000
在此过程中 我们不但包含前面用过的 g 还包含 f

00:00:25.000 --> 00:00:27.000
在这里我也包含了一个 h

00:00:27.000 --> 00:00:31.000
这并非必要 但我还是添加了

00:00:31.000 --> 00:00:34.000
因此现在 我们有了5个变量 其中 g 和先前定义相同

00:00:34.000 --> 00:00:39.000
h 是单元格 x y 对应的启发值 f 是 g 和 h 的和

00:00:39.000 --> 00:00:43.000
我把 f 放在左边 原因是我接下来要依据 f 来进行排序操作

00:00:43.000 --> 00:00:47.000
这样我可以根据 f 来排序这个列表

00:00:47.000 --> 00:00:51.000
大家注意 现在这个列表的长度已经增长了2个元素

00:00:51.000 --> 00:00:57.000
而且 通过把 f 放在左边 我可以实现依据最低 f 值

00:00:57.000 --> 00:01:01.000
而不是最低 g 值来移除元素

00:01:01.000 --> 00:01:06.000
我们继续向下查看代码 这几行代码用来扩展节点 

00:01:06.000 --> 00:01:11.000
现在我需要稍微调整下一个结构中的索引

00:01:11.000 --> 00:01:16.000
x 指向索引值3 从技术上来讲 

00:01:16.000 --> 00:01:18.000
当我们的索引值从0开始计数 它事实上指向列表的第四个元素

00:01:18.000 --> 00:01:19.000
y 对应索引值4

00:01:19.000 --> 00:01:21.000
g 对应索引值1

00:01:21.000 --> 00:01:27.000
还有 f 和 h 这里我不需要填充 因为很快我就能算出它们

00:01:27.000 --> 00:01:34.000
这样 我们继续向下 这里我从列表中扩展节点

00:01:34.000 --> 00:01:39.000
并计算所有可能动作的下一个状态

00:01:39.000 --> 00:01:42.000
然后测试这些状态的合法性 以决定是否扩展

00:01:42.000 --> 00:01:48.000
现在 就像我以前做的 我使用成本函数来增加 g 的值 这次我在这里添加了两行新代码

00:01:48.000 --> 00:01:52.000
第一行中 我为新的扩展到的节点计算启发函数值

00:01:52.000 --> 00:01:53.000
这很简单直接

00:01:53.000 --> 00:01:54.000
结果存在 h2 中

00:01:54.000 --> 00:02:00.000
接下来的代码行中 我计算 g 和 h 的和

00:02:00.000 --> 00:02:06.000
这里 我把5个变量 新的 f 值、 新的 g 值、 新的 h 值、

00:02:06.000 --> 00:02:10.000
以及扩展节点的 x 和 y 追加到 open 列表后面

00:02:10.000 --> 00:02:14.000
现在对我们来说 f 和 h 值都非常重要

00:02:14.000 --> 00:02:18.000
我们使用它们来实现 A-Star 算法

00:02:18.000 --> 00:02:21.000
为了实现算法 我更改了代码逻辑

00:02:21.000 --> 00:02:26.000
我现在从列表中找出拥有最小 f 值的节点 而不是最小 g 值

00:02:26.000 --> 00:02:30.000
这就是 A-Star 算法的实现

00:02:30.000 --> 00:02:32.000
现在我来运行一下

00:02:32.000 --> 00:02:34.000
应用在我们之前看到的迷宫上

00:02:34.000 --> 00:02:38.000
我把开始点移到顶部 在这里放一堵墙

00:02:38.000 --> 00:02:41.000
结果是 在这种情况下 A-Star 并不十分有效

00:02:41.000 --> 00:02:44.000
它并没有搜索到这个区域

00:02:44.000 --> 00:02:46.000
不过 他最终发现了目标点

00:02:46.000 --> 00:02:50.000
不过 当我把一个大障碍水平地放在这里 事情有点了变化

00:02:50.000 --> 00:02:54.000
这里 非常有趣的是 我们看到

00:02:54.000 --> 00:02:56.000
A-Star 不能决定这条水平路径还是这条垂直路径是最优的

00:02:56.000 --> 00:03:01.000
因此 它从其中任意一个来扩展节点

00:03:01.000 --> 00:03:05.000
当它在这里结束时候 和先前同样的现象发生了

00:03:05.000 --> 00:03:07.000
那就是 它并没有搜索中间区域

00:03:07.000 --> 00:03:10.000
而是直接走向目标 并在这里到达目标

00:03:10.000 --> 00:03:12.000
这就是 A-Star 的魔力

00:03:12.000 --> 00:03:15.000
事实上 如果要让它工作得和以前的算法一样的话

00:03:15.000 --> 00:03:17.000
只需要给它一个空的启发函数值

00:03:17.000 --> 00:03:24.000
这里是一个最初版本的启发函数 h 值始终为0 

00:03:24.000 --> 00:03:27.000
不过我们不会再用它 我们叫它旧版本启发函数

00:03:27.000 --> 00:03:30.000
这里是我们的新版启发函数

00:03:30.000 --> 00:03:35.000
如果我运行老版本启发函数 我就退回到我们先前的搜索算法

00:03:35.000 --> 00:03:39.000
大家可以看到 老算法会搜索中间部分

00:03:39.000 --> 00:03:42.000
比 A-Star 探索更多节点

00:03:42.000 --> 00:03:46.000
在这里这似乎不是问题 但是如果我们在一个很大的环境中

00:03:46.000 --> 00:03:50.000
那结果便大为不同

00:03:50.000 --> 00:03:51.000
特别是 如果环境中有很多死路的话

00:03:51.000 --> 99:59:59.999
A-Star算法会比普通算法的效率高很多

