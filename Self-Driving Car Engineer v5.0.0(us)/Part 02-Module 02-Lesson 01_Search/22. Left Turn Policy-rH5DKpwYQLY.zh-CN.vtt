WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:07.000
这里是我的解答 我用999来初始化这个价值函数

00:00:07.000 --> 00:00:11.000
策略在这里是一个三维的、与上面相似的函数

00:00:11.000 --> 00:00:15.000
然后我还有一个叫做 policy2d 的函数 后面我会把它打印出来

00:00:15.000 --> 00:00:17.000
这是与上面3D版本类似的2D版本函数

00:00:17.000 --> 00:00:23.000
向下拉 这里我的更新函数和前面我们学习动态规划时候完全相同

00:00:23.000 --> 00:00:29.000
这里 change 依然存在 代码遍历所有的单元格以及所有朝向

00:00:29.000 --> 00:00:32.000
这里朝向有4个值 这段代码是个多层嵌套循环

00:00:32.000 --> 00:00:36.000
如果找到目标位置 那么就做更新操作

00:00:36.000 --> 00:00:39.000
如果发生了实际更新 就把 change 设置为 True

00:00:39.000 --> 00:00:42.000
并且把它标记为目标位置

00:00:42.000 --> 00:00:45.000
如果不是目标位置 那么 如果单元格是可通行的

00:00:45.000 --> 00:00:48.000
我们会遍历3种不同的动作 这里是代码中最棘手的部分

00:00:48.000 --> 00:00:52.000
如何让动作可执行 而且还要优雅地执行

00:00:52.000 --> 00:00:54.000
我们接下来遍历这3个不同动作

00:00:54.000 --> 00:00:57.000
当我们处理第 i 个动作时

00:00:57.000 --> 00:01:04.000
我们把对应朝向赋值为原来朝向和4取模的结果

00:01:04.000 --> 00:01:07.000
这是一段循环 所以这里或许或减去1

00:01:07.000 --> 00:01:10.000
这里结果相等 然后朝向会加1 

00:01:10.000 --> 00:01:16.000
接着我们把对应的新运动模式加到 x 和 y 上 得到 x2 和 y2

00:01:16.000 --> 00:01:21.000
这是就是我们生成的车辆的新模式 它先调整方向 然后移动

00:01:21.000 --> 00:01:25.000
继续向下滚动 如果我们遇到一个有效的单元格 并且它仍在网格内

00:01:25.000 --> 00:01:34.000
并且它不是一个障碍物 那么 和前面一样 我们把它的值增加

00:01:34.000 --> 00:01:37.000
新值等于这个单元格原来的值加上对应的动作的成本值

00:01:37.000 --> 00:01:40.000
这个值并不固定 取决于我们选择的动作类型

00:01:40.000 --> 00:01:43.000
如果新值优于原有的值

00:01:43.000 --> 00:01:47.000
那么我们就用新值替换原来的值 并且把 change 置为 True

00:01:47.000 --> 00:01:50.000
和以前做的一样 我们也会把动作名称存起来

00:01:50.000 --> 00:01:53.000
这段代码和我们前面在2D环境中运行动态规划的代码一样

00:01:53.000 --> 00:01:57.000
都具有很高的执行效率

00:01:57.000 --> 00:02:00.000
我们获得了价值函数 以及策略动作

00:02:00.000 --> 00:02:04.000
但是 我在这里打印出的是一张2维表格 而不是3维表格

00:02:04.000 --> 00:02:09.000
要生成这张2维表 我们需要考虑初始状态

00:02:09.000 --> 00:02:12.000
否则 这张表格的结果就会变成未定义状态

00:02:12.000 --> 00:02:17.000
这里我们把初始状态设置到x y 以及 orientation 中

00:02:17.000 --> 00:02:20.000
现在我要做的就是运行这个策略

00:02:20.000 --> 00:02:26.000
使用最开始的状态 我把这个策略从这个3维表拷贝到这个2维表里

00:02:26.000 --> 00:02:29.000
就是这里有 # 号标识的表格

00:02:29.000 --> 00:02:32.000
通过在策略表中检测 * 号的方式来进行判断

00:02:32.000 --> 00:02:35.000
现在我们还没有到达目标状态

00:02:35.000 --> 00:02:38.000
然后我的策略表里有3种值 # R L 

00:02:38.000 --> 00:02:40.000
接下来的逻辑与之前的相同

00:02:40.000 --> 00:02:43.000
如果值是 # 那么我们保持朝向不变

00:02:43.000 --> 00:02:45.000
如果是 R 我们右转 如果是 L 那就左转

00:02:45.000 --> 00:02:48.000
接着我继续前进

00:02:48.000 --> 00:02:52.000
并更新 x 和 y 坐标值

00:02:52.000 --> 00:02:55.000
把它们更新为移动后对应的坐标值

00:02:55.000 --> 00:02:58.000
此外 我还把朝向更新为 o2

00:02:58.000 --> 00:03:05.000
最后 我把3维的策略符号表直接复制到这个2维数组中

00:03:05.000 --> 00:03:07.000
这里 我把它打印出来了

00:03:07.000 --> 00:03:10.000
这里的关键是从3维策略表到2维数组这一步

00:03:10.000 --> 00:03:14.000
这里我已经运行了策略

00:03:14.000 --> 00:03:18.000
你们需要做同样的事情 去得到这里的这张表格

00:03:18.000 --> 00:03:21.000
这一点很重要 我没有着重指出来 不过我希望大家可以最终理解这一点

00:03:21.000 --> 99:59:59.999
然后 其他所有东西 都与大家之前看到的动态规划循环相同

