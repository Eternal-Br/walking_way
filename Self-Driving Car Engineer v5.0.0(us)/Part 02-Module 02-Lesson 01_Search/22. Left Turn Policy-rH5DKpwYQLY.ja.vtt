WEBVTT
Kind: captions
Language: ja

00:00:00.000 --> 00:00:02.000
私の解答をお見せしましょう

00:00:02.000 --> 00:00:07.000
初期化した価値関数を持ち
たくさんの999を保持しています

00:00:07.000 --> 00:00:11.000
policyは三次元の場合と同じ関数です

00:00:11.000 --> 00:00:15.000
それからpolicy2Dという関数があり
あとでこれを出力します

00:00:15.000 --> 00:00:17.000
これは二次元の場合と同じです

00:00:17.000 --> 00:00:23.000
下にスクロールすると更新機能はこれまでの
ダイナミック・プログラミングの場合と同じです

00:00:23.000 --> 00:00:29.000
変更がある間 x、yと
4つのすべての方向について調べ

00:00:29.000 --> 00:00:32.000
ここからさらに深いループに入ります

00:00:32.000 --> 00:00:36.000
ゴール位置が見つかったら価値を更新し

00:00:36.000 --> 00:00:39.000
更新したらchangeをTrueに設定します

00:00:39.000 --> 00:00:42.000
そしてそれをゴール位置としてマークします

00:00:42.000 --> 00:00:48.000
それ以外の場合グリッドセルが移動可能なら
3種類の動作を調べてみましょう

00:00:48.000 --> 00:00:52.000
ここからはややこしい部分ですが
うまく動作してくれます

00:00:52.000 --> 00:00:57.000
3種類の動作にi番目の動作というタグをつけて

00:00:57.000 --> 00:01:03.000
該当する方向の変更を
私たちの方向に足して4の剰余を求めます

00:01:03.000 --> 00:01:07.000
これはサイクリックバッファなので
1を引くことになるかもしれません

00:01:07.000 --> 00:01:10.000
同じ状態を維持する場合
方向に1を足すことになります

00:01:10.000 --> 00:01:16.000
次に該当する新しい動作モデルをxとyに適用し
x2とy2を取得します

00:01:16.000 --> 00:01:21.000
ここが最初に操舵してから走行させる
私たちの車のモデルです

00:01:21.000 --> 00:01:23.000
さらに下にスクロールします

00:01:23.000 --> 00:01:30.000
グリッド内にあって かつ障害物がない
有効なグリッドセルに到達した場合

00:01:30.000 --> 00:01:34.000
先ほどのように値に
新しいグリッドセルの値と

00:01:34.000 --> 00:01:36.000
動作のコストを価値に足します

00:01:36.000 --> 00:01:40.000
これは均一ではなく
選択する動作によって異なります

00:01:40.000 --> 00:01:43.000
これによって既存の価値は改善されます

00:01:43.000 --> 00:01:47.000
この価値を新しい価値に設定し
changeをTrueとしてマークします

00:01:47.000 --> 00:01:50.000
また前回のように動作の名前を記録します

00:01:50.000 --> 00:01:53.000
これは実質的には二次元の世界で

00:01:53.000 --> 00:01:57.000
ダイナミック・プログラミングを行った時と
同じコードです

00:01:57.000 --> 00:02:00.000
このコードにより価値関数と
ポリシーの動作が導かれます

00:02:00.000 --> 00:02:04.000
私は三次元ではなく二次元の表を出力しました

00:02:04.000 --> 00:02:09.000
二次元の表を得るには初期状態に
気をつける必要があります

00:02:09.000 --> 00:02:12.000
そうしないと
実際に定義されていない場合があります

00:02:12.000 --> 00:02:17.000
x、y、方向の初期状態を設定しましょう

00:02:17.000 --> 00:02:20.000
あとはポリシーを実行するだけです

00:02:20.000 --> 00:02:26.000
最初の状態でポリシーの形式の三次元の表を

00:02:26.000 --> 00:02:29.000
二次元の表にコピーしています　ここの＃記号です

00:02:29.000 --> 00:02:32.000
ゴール状態にまだ到達していない間は

00:02:32.000 --> 00:02:35.000
ポリシーの表の＊をチェックすることで分かります

00:02:35.000 --> 00:02:40.000
ポリシーの表には＃、R、Lがありますが
その他は前回と同様です

00:02:40.000 --> 00:02:43.000
＃の場合は方向をそのまま保持します

00:02:43.000 --> 00:02:45.000
Rの場合は右折、Lの場合は左折をします

00:02:45.000 --> 00:02:52.000
前進動作を適用して動作のあとに対応するように

00:02:52.000 --> 00:02:55.000
新しいx、yの座標を更新し

00:02:55.000 --> 00:02:58.000
orientationがo2になるように更新します

00:02:58.000 --> 00:03:05.000
最後にポリシーの三次元の記号を
二次元の配列に直接コピーします

00:03:05.000 --> 00:03:07.000
これが最終的に出力する配列です

00:03:07.000 --> 00:03:10.000
ここで重要な点は三次元の完全なポリシーから

00:03:10.000 --> 00:03:14.000
ポリシーを実行する必要があった二次元の配列に
移行していることです

00:03:14.000 --> 00:03:18.000
皆さんもこの出力を得るために
それを行ったでしょう

00:03:18.000 --> 00:03:21.000
難しい部分ですがご自身で解いてほしかったのです

00:03:21.000 --> 00:03:26.000
しかしそれ以外は今までの
ダイナミック・プログラミングのループと同じです

