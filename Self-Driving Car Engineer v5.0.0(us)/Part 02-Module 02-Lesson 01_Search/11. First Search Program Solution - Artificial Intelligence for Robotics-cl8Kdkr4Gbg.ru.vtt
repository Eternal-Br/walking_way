WEBVTT
Kind: captions
Language: ru

00:00:00.000 --> 00:00:04.000
Вот мое решение - я определил функцию "поиск"

00:00:04.000 --> 00:00:07.000
которая является единственной функцией которую я собираюсь запустить в конце концов. Это как основная программа.

00:00:07.000 --> 00:00:12.000
Чтобы проверить клетки, как только они расширены, мы не расширяем их снова,

00:00:12.000 --> 00:00:18.000
Я определяю массив который называю "закрытым", такого же размера, как и моя сетка,

00:00:18.000 --> 00:00:23.000
и он имеет два значения 0 и 1 - 0 означает что он по-прежнему открыт, 1 означает что закрыт.

00:00:23.000 --> 00:00:25.000
Вы также можете использовать логические.

00:00:25.000 --> 00:00:31.000
Здесь присваивается массив того же размера, что и в поле сетки.

00:00:31.000 --> 00:00:36.000
Я инициализировал начальное положение как проверенное

00:00:36.000 --> 00:00:42.000
и назначил координаты х, у, и г-значение 0.

00:00:42.000 --> 00:00:47.000
В моем первоначальном списке будет только 1 элемент из моих первоначальных координат и г значения 0.

00:00:47.000 --> 00:00:52.000
Пока то, что я сделал, я определил массив который называется закрытым, одного и того же размера.

00:00:52.000 --> 00:00:55.000
Всех галочек там нет, за исключением тех что в левом углу,

00:00:55.000 --> 00:01:01.000
и это мое местонахождение в моем списке прямо здесь с г-значением 0.

00:01:01.000 --> 00:01:04.000
В моем коде я использую два флага - один найден,

00:01:04.000 --> 00:01:07.000
который будет верным, когда цель найдена, и один передастся,

00:01:07.000 --> 00:01:11.000
которое будет верно, если я не найду цель и я исследовал все.

00:01:11.000 --> 00:01:15.000
Второй будет в случае, когда мой список окажется пустым, не найдя цели.

00:01:15.000 --> 00:01:19.000
Это действительно важно для случая, когда я не могу найти путь к цели.

00:01:19.000 --> 00:01:23.000
Эти команд были те, которые я использовал для отладки.

00:01:23.000 --> 00:01:26.000
Вы можете посмотреть на них. Они распетывают существующий список. Ничто другое.

00:01:26.000 --> 00:01:28.000
Но вот код.

00:01:28.000 --> 00:01:32.000
Я повторяю, пока не найду путь к цели

00:01:32.000 --> 00:01:35.000
и я не доказывал, что задача нерешаемая.

00:01:35.000 --> 00:01:38.000
Двое найдены и отставка, являются ложными.

00:01:38.000 --> 00:01:45.000
Если мой список пуст, нет ничего, чтобы расширить, а затем отставка является правдой, и я распечатываю "провал".

00:01:45.000 --> 00:01:47.000
Этот один из 2 прекращении условий.

00:01:47.000 --> 00:01:51.000
Вы можете убедить себя, что нет пути от S до G.

00:01:51.000 --> 00:01:54.000
Вы будете расширять каждый узел на левой стороне

00:01:54.000 --> 00:01:58.000
барьера, пока мы, наконец, запустим из узлов расширить

00:01:58.000 --> 00:02:02.000
при каких координатах список будет пуст, и наши поиски провалятся.

00:02:02.000 --> 00:02:06.000
Если есть еще элементы в нашем списке, в другом случае доходит на место.

00:02:06.000 --> 00:02:13.000
Здесь то, как я могу удалить элемент с наименьшим г-значением.

00:02:13.000 --> 00:02:18.000
Я использую функцию сортировки списка, который сортирует элементы в порядке возрастания

00:02:18.000 --> 00:02:20.000
от самых маленьких г-значений вверх.

00:02:20.000 --> 00:02:23.000
Теперь я хочу засунуть элемент с наименьшим номером.

00:02:23.000 --> 00:02:27.000
К сожалению поп появляется в конце, так что я просто отсортирую список в обратном порядке

00:02:27.000 --> 00:02:32.000
а затем добавлю элемент с наименьшим г-значением из этого списка.

00:02:32.000 --> 00:02:35.000
Там есть немного трюков. Этот не очень элегантный.

00:02:35.000 --> 00:02:38.000
Это также не очень эффективно, но это делает работу в настоящее время.

00:02:38.000 --> 00:02:42.000
Что дает мне элемент с наименьшим г-значением.

00:02:42.000 --> 00:02:46.000
Для этого важно, чтобы г-значению занимает первое место в каждой из триплетов.

00:02:46.000 --> 00:02:49.000
Вот почему я поставил его первым, прямо перед х и у.

00:02:49.000 --> 00:02:56.000
Я тогда назначил 3 значения х, у и г, который является моим расширением.

00:02:56.000 --> 00:03:01.000
Опять же, г является первым, х и у вторым и третьим.

00:03:01.000 --> 00:03:04.000
Сейчас я нахожусь в состоянии проверки, могу ли я достичь цели.

00:03:04.000 --> 00:03:08.000
Если х цель 0 и у цель 1, я сделал. Я вызываю найден равным правде.

00:03:08.000 --> 00:03:11.000
Я распечатал этот триплет, и это дает мне триплет здесь.

00:03:11.000 --> 00:03:15.000
Эта "распечатать следующее" здесь это триплет, и это та, которую я искал,

00:03:15.000 --> 00:03:19.000
спрашивая вас о распечатке именно это решение здесь.

00:03:19.000 --> 00:03:22.000
Теперь, если я еще этого не сделал, то вот интересный случай.

00:03:22.000 --> 00:03:24.000
Это суть, что я программирования.

00:03:24.000 --> 00:03:27.000
Я пройдусь через все возможные действия. Их всего 4.

00:03:27.000 --> 00:03:29.000
Дельта представляет собой массив из 4-х различных действий.

00:03:29.000 --> 00:03:33.000
Я применил действие к х и у с этим дополнением здесь

00:03:33.000 --> 00:03:37.000
путем применения соответствующих дельты векторов построить x2 и y2.

00:03:37.000 --> 00:03:48.000
Если x2 попадает в сетку и y2 попадает в сетку и [x2, y2] еще не проверены,

00:03:48.000 --> 00:03:51.000
которые проверяется полем, называющиеся "закрыто",

00:03:51.000 --> 00:03:55.000
и ячейки сетки управляемые -- нет никаких препятствий здесь.

00:03:55.000 --> 00:04:00.000
Если все это верно, то я нашел расширения, и я теперь добавлю к моему списку.

00:04:00.000 --> 00:04:07.000
Я увеличиваю стоимость от г до г2, добавив 1. В этом случае стоимость 1.

00:04:07.000 --> 00:04:11.000
Тогда я добавил новые значения [g2, x2, y2] в мои список,

00:04:11.000 --> 00:04:15.000
и я проверяю координаты [x2, y2], поэтому я никогда не расширю их снова.

00:04:15.000 --> 00:04:18.000
Это рекурсия.

00:04:18.000 --> 00:04:23.000
Иными словами, когда я навлек этот элемент здесь, например,

00:04:23.000 --> 00:04:27.000
Я посмотрел на возможные пути куда робот мог пойти.

00:04:27.000 --> 00:04:30.000
В моей программе, это означает, что робот должен оставаться внутри сетки,

00:04:30.000 --> 00:04:34.000
и ячейки сетки не должны быть занятыми, что этот тест здесь.

00:04:34.000 --> 00:04:37.000
Я также проверил, есть ли уже галочки в ячейке,

00:04:37.000 --> 00:04:41.000
который этот тест здесь. Это всегда правда.

00:04:41.000 --> 00:04:45.000
Я добавил новый элемент в мой список

00:04:45.000 --> 00:04:50.000
с новым г-значением увеличивается и новые координаты.

00:04:50.000 --> 00:04:52.000
Это именно происходит здесь.

00:04:52.000 --> 00:04:56.000
Я увеличиваю г-значение, и добавляю его с новыми координатами.

00:04:56.000 --> 00:04:58.000
Это ключ алгоритма поиска.

00:04:58.000 --> 00:05:01.000
Единственный оставшийся вещь сейчас то, что я называю поиск рутинной

00:05:01.000 --> 09:59:59.000
который печатает мне эти вещи здесь.

