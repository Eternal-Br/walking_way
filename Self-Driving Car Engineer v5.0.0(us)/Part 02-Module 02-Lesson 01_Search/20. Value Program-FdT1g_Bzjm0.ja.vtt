WEBVTT
Kind: captions
Language: ja

00:00:00.000 --> 00:00:04.000
これが私の実装です　これは比較的簡単でしょう

00:00:04.000 --> 00:00:07.000
私の世界と同じサイズの価値関数があります

00:00:07.000 --> 00:00:10.000
そしてすべて99で初期化します

00:00:10.000 --> 00:00:15.000
これは実際の価値と競合しないよう
十分大きな値を求める必要があります

00:00:15.000 --> 00:00:18.000
ここで価値関数を何度も更新しています

00:00:18.000 --> 00:00:22.000
回数は分かりませんが変更がある限り更新します

00:00:22.000 --> 00:00:26.000
そこで変数changeを導入し
冒頭でTrueに設定しています

00:00:26.000 --> 00:00:30.000
変更がある限り更新しますが
changeをきちんとFalseに設定します

00:00:30.000 --> 00:00:34.000
Trueに戻るのは実際に変更した場合のみです

00:00:34.000 --> 00:00:38.000
ここからすべてのグリッドセルを
決まった順序で調べます

00:00:38.000 --> 00:00:42.000
あまり効率的ではありませんが
確実に作業を完了できます

00:00:42.000 --> 00:00:46.000
まず対象となるグリッドセルが
ゴールかどうかをチェックします

00:00:46.000 --> 00:00:49.000
変更があるかを確認する典型的なケースです

00:00:49.000 --> 00:00:53.000
現在の価値が
正しく0に設定されていれば何もしません

00:00:53.000 --> 00:00:59.000
99など0よりも大きい場合は
0に設定して変更を行います

00:00:59.000 --> 00:01:02.000
従ってchangeフラグをTrueに戻します

00:01:02.000 --> 00:01:07.000
このセルがゴールではない場合
ここが私の完全な更新機能ですが

00:01:07.000 --> 00:01:10.000
すべての動作を調べます

00:01:10.000 --> 00:01:14.000
対応するdeltaをxとyに足すことによって

00:01:14.000 --> 00:01:17.000
次に起こり得る状態を動作の実行時に予想します

00:01:17.000 --> 00:01:20.000
この結果x2とy2が得られるので

00:01:20.000 --> 00:01:24.000
x2とy2が妥当な状態かどうかをテストしますが
そのためには

00:01:24.000 --> 00:01:26.000
グリッドの内側になければなりません

00:01:26.000 --> 00:01:31.000
この2つの数値が0以上かつグリッドの
寸法よりも小さいかをチェックします

00:01:31.000 --> 00:01:34.000
またセルを移動できる動作でなければなりません

00:01:34.000 --> 00:01:38.000
そこでグリッド内の座標が
0であることをチェックします

00:01:38.000 --> 00:01:41.000
それが0なら価値を伝播できます

00:01:41.000 --> 00:01:46.000
新しい価値はこの将来のグリッドセル値に
ステップごとのコストを足したもので

00:01:46.000 --> 00:01:48.000
コストは1です

00:01:48.000 --> 00:01:53.000
これがすでに持っている価値よりもよい場合
つまり価値が小さければ

00:01:53.000 --> 00:01:57.800
この新しい価値を元のグリッドセルのxとyに代入し

00:01:57.800 --> 00:02:01.000
もちろんコストステップも足します

00:02:01.000 --> 00:02:04.000
変更したことが分かっているので

00:02:04.000 --> 00:02:08.000
changeをTrueに設定しプロシージャを繰り返します

00:02:08.000 --> 00:02:11.000
処理が完了して最後に残っているのは

00:02:11.000 --> 00:02:14.000
このステートメントを使って
価値関数を出力することです

00:02:14.000 --> 00:02:17.000
この方法はあまり効率的ではありません

00:02:17.000 --> 00:02:20.000
その理由は最後から最初に向かって

00:02:20.000 --> 00:02:23.000
価値が緩やかに伝播するからです

00:02:23.000 --> 00:02:26.000
しかし価値関数を正しく計算してくれます

00:02:26.000 --> 00:02:28.000
より効率的に行う方法は他にもあります

00:02:28.000 --> 00:02:33.000
またゴールまでの経路をすべて塞いだ場合
面白い結果が出ます

00:02:33.000 --> 00:02:38.000
得られた価値関数は
ほとんどの状態変数に対して99を保持し

00:02:38.000 --> 00:02:41.000
ゴールまでの有効な経路がない場所です

