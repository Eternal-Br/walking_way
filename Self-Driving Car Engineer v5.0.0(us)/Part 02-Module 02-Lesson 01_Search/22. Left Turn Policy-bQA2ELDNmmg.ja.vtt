WEBVTT
Kind: captions
Language: ja

00:00:00.000 --> 00:00:05.000
それではこれを実際の車の問題に
応用してみましょう

00:00:05.000 --> 00:00:10.000
使用するものは
いつものように少し簡略化されていますが

00:00:10.000 --> 00:00:15.000
現実世界の経路計画に関連しており
Googleマップなどで応用されています

00:00:15.000 --> 00:00:17.000
ここに車があるとしましょう

00:00:17.000 --> 00:00:23.000
この車は状態としてx、yと
方向であるθを持っています

00:00:23.000 --> 00:00:28.000
分かりやすくするために方向は
4方向から選択します

00:00:28.000 --> 00:00:33.000
上下左右の4つです

00:00:33.000 --> 00:00:39.000
以前の小テストと同じように
この場所に左を向いて到達したいと思います

00:00:39.000 --> 00:00:46.000
位置推定の例と同様
今回の状態空間は三次元だと理解していますね

00:00:46.000 --> 00:00:50.000
ではダイナミック・プログラミング
プランナを実装し

00:00:50.000 --> 00:00:53.000
ここからここまでの最適な経路を見つけます

00:00:53.000 --> 00:00:55.000
そしてコスト関数で遊んでみましょう

00:00:55.000 --> 00:00:57.000
主な動作は3つあります

00:00:57.000 --> 00:01:04.000
1つ目は車が現在の方向に向かって
グリッドセル1つ前進する動作です

00:01:04.000 --> 00:01:10.000
直進のみの動作で迷路のどの場所でも
どの方向にも応用できます

00:01:10.000 --> 00:01:14.000
2つ目は車が左折して前進する動作です

00:01:14.000 --> 00:01:18.000
車がこのセルの位置にいる場合

00:01:18.000 --> 00:01:23.000
左折することができ このセルに移動します

00:01:23.000 --> 00:01:26.000
最後の3つ目は右折して前進する動作です

00:01:26.000 --> 00:01:31.000
その場合 車はこのセルから右折し
このセルに移動します

00:01:31.000 --> 00:01:33.000
私たちの世界をもう一度見てみましょう

00:01:33.000 --> 00:01:36.000
ここに通行できる道があり横の道も通行できます

00:01:36.000 --> 00:01:39.000
右側はループになっています

00:01:39.000 --> 00:01:43.000
この状態空間は二次元ではなく
三次元だということを思い出してください

00:01:43.000 --> 00:01:47.000
私たちのゴールは［2，0］に移動することです

00:01:47.000 --> 00:01:50.000
初期状態はここです

00:01:50.000 --> 00:01:54.000
初期状態は［4，3］という位置だけでなく
0という方向も持っています

00:01:54.000 --> 00:01:57.000
つまり三次元の状態です

00:01:57.000 --> 00:02:02.000
ここにあるのが方向です
0、1、2、3です

00:02:02.000 --> 00:02:05.000
ロボットはここで上へ次で左へ進みます

00:02:05.000 --> 00:02:08.000
ここでは下へ そして右へ進みます

00:02:08.000 --> 00:02:11.000
ここの名前は上、左、下、右に関連しています

00:02:11.000 --> 00:02:13.000
これは興味深いことです

00:02:13.000 --> 00:02:16.000
私たちには3つの動作があり

00:02:16.000 --> 00:02:20.000
方向のインデックスに－1、0、1を追加できます

00:02:20.000 --> 00:02:24.000
－1を追加した場合
ここにある循環配列で1つ上に行き

00:02:24.000 --> 00:02:27.000
右折を行うのと同じことになります

00:02:27.000 --> 00:02:34.000
例えば左折して上に進むと
右折したことと同じになります

00:02:34.000 --> 00:02:38.000
＋1を加えると左折と同じことになります

00:02:38.000 --> 00:02:41.000
方向を変更せずに直進する場合は

00:02:41.000 --> 00:02:46.000
ここにある＃記号で示されます

00:02:46.000 --> 00:02:48.000
これらの動作には異なるコストがかかり

00:02:48.000 --> 00:02:51.000
左折のコストは2で直進のコストは1です

00:02:51.000 --> 00:02:53.000
そして右折のコストも1です

00:02:53.000 --> 00:02:58.000
皆さんもお分かりのとおり
ここで左折するのが好ましい解答です

00:02:58.000 --> 00:03:04.000
実際にこれを実行すると車がここで左折して
ゴール位置に向かうのが分かります

00:03:04.000 --> 00:03:10.000
もし私が左折のコストを20に増やしたとしたら
私の解答は変わります

00:03:10.000 --> 00:03:13.000
車はここで直進し ここで右折

00:03:13.000 --> 00:03:17.000
ここで右折、また右折して
ゴール位置まで直進します

00:03:17.000 --> 00:03:21.000
これが皆さんに実装してほしいソフトウェアで
ヒントが1つあります

00:03:21.000 --> 00:03:27.000
価値関数自体は三次元で
これが私が使用しているコードです

00:03:27.000 --> 00:03:32.000
効率的ではありませんが
この関数にはグリッド内に

00:03:33.000 --> 00:03:37.000
同一の配列が4つあり
巨大なグリッドとして統合されています

00:03:37.000 --> 00:03:41.000
この場合は非常に大きな値999で
すべて初期化されています

00:03:41.000 --> 00:03:47.000
皆さんはこれに似た関数が必要であり
コードの記述が難しくなっています

00:03:47.000 --> 00:03:53.000
この講義の最後のプログラミング課題は
多少時間がかかるかもしれません

00:03:53.000 --> 00:03:58.000
私自身もプログラミングしてこの出力を得るまでに
少し時間がかかりました

