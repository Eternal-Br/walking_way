WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:05.000
现在让我们做点有趣的事情 把这个应用到实际的车辆问题中

00:00:05.000 --> 00:00:10.000
我下面使用的例子和以前一样有些简化

00:00:10.000 --> 00:00:15.000
但是 它确实能反映真实世界中路径规划的实际情况 比如谷歌地图所做的工作 

00:00:15.000 --> 00:00:17.000
假定这里有辆车

00:00:17.000 --> 00:00:23.000
该车当前的状态可以用 x y 以及朝向 theta 来表示

00:00:23.000 --> 00:00:34.000
简化起见 朝向的可选值有四种 上 下 左 右

00:00:34.000 --> 00:00:39.000
正如开始时候我问大家的问题那样 我们的目的地在这里 朝向为左

00:00:39.000 --> 00:00:46.000
注意 这里的状态空间是三维的 和我们先前的定位例子一样

00:00:46.000 --> 00:00:50.000
我现在要实现一个使用动态规划算法的规划器

00:00:50.000 --> 00:00:53.000
规划器会给出从这里到那里的最优路径

00:00:53.000 --> 00:00:55.000
现在我们来考虑成本函数

00:00:55.000 --> 00:00:58.000
这里有三种基本动作

00:00:58.000 --> 00:01:05.000
第一种是移动 表示汽车在朝向方向上向前走一个单元格

00:01:05.000 --> 00:01:10.000
移动不包含转向 所以在这个迷宫中 汽车可以在任何地点做任意方向移动

00:01:10.000 --> 00:01:14.000
第二种是左转然后移动

00:01:14.000 --> 00:01:20.000
在这个格子的这辆车可以选择左转然后移动

00:01:20.000 --> 00:01:23.000
然后它会到达这个位置

00:01:23.000 --> 00:01:26.000
最后一个动作是右转然后移动

00:01:26.000 --> 00:01:29.000
这辆车如果右转加移动

00:01:29.000 --> 00:01:31.000
它会到达这里 朝向是这个方向

00:01:31.000 --> 00:01:33.000
这是先前我们的表格

00:01:33.000 --> 00:01:36.000
大家可以看到 这里有条可通行街道 这里也有一条可通行街道

00:01:36.000 --> 00:01:39.000
右边有一条环形街道

00:01:39.000 --> 00:01:43.000
注意 现在的状态空间是三维的 而不是二维的

00:01:43.000 --> 00:01:47.000
我们的目标是移动到单元格 [2,0] 它在这里

00:01:47.000 --> 00:01:50.000
我们的初始状态在这里

00:01:50.000 --> 00:01:54.000
初始状态不仅包括位置 [4,3] 还包括朝向0

00:01:54.000 --> 00:01:57.000
这是一个三维的状态

00:01:57.000 --> 00:02:02.000
这里是我定义的朝向 0 1 2 3

00:02:02.000 --> 00:02:05.000
第一个朝向使机器人向上走 第二个向左

00:02:05.000 --> 00:02:08.000
第三个向下 第四个向右

00:02:08.000 --> 00:02:11.000
这是朝向对应的文字描述 上 左 下 右

00:02:11.000 --> 00:02:13.000
这里的代码相当有趣

00:02:13.000 --> 00:02:16.000
它们表示动作 我们有三种动作

00:02:16.000 --> 00:02:20.000
我们可以添加朝向的索引 -1 0 或者1

00:02:20.000 --> 00:02:24.000
如果我们添加-1 我们在循环数组中上跳一格到达这里

00:02:24.000 --> 00:02:27.000
和做一个右转动作相同

00:02:27.000 --> 00:02:34.000
例如 如果你先向左然后向上 那将和右转相同

00:02:34.000 --> 00:02:38.000
我如我们添加一个 +1 那和左转相同

00:02:38.000 --> 00:02:41.000
如果我们保持朝向不变

00:02:41.000 --> 00:02:46.000
那么我们将直行 在这里用 # 号表示

00:02:46.000 --> 00:02:48.000
这些动作伴随着不同的成本

00:02:48.000 --> 00:02:51.000
现在 左转的成本为2 直行成本为1

00:02:51.000 --> 00:02:54.000
右转成本也为1

00:02:54.000 --> 00:02:58.000
这种情况下 在这里 左转就成为我们的偏好解

00:02:58.000 --> 00:03:04.000
事实上 当我运行它的时候 大家能看到汽车如何在这里左转到达目标

00:03:04.000 --> 00:03:10.000
如果我把左转的成本增大到20 那么我的解也会有所不同

00:03:10.000 --> 00:03:13.000
大家可以看到 这时候汽车会直行到达这里 然后右转到达这里

00:03:13.000 --> 00:03:18.000
再右转到达这里 在这里继续右转 最后直行到达目标

00:03:18.000 --> 00:03:21.000
我希望大家能实现这样的代码 这里有个提示

00:03:21.000 --> 00:03:27.000
价值函数本身是三维的 这里有些代码 是我使用的

00:03:27.000 --> 00:03:33.000
这些代码效率不一定最好 但是其内部包含了4个相同的数组

00:03:33.000 --> 00:03:37.000
这些数组大小等于网格的大小 它们共同组成一个很大的网格

00:03:37.000 --> 00:03:41.000
这里 我用一个很大的值999对它们进行初始化

00:03:41.000 --> 00:03:47.000
你们也需要类似的函数 不过这样的话 会使编写代码工作更加困难

00:03:47.000 --> 00:03:50.000
这是这节课的最后一个测验

00:03:50.000 --> 00:03:53.000
也是我们最后一个编程作业 也许会耗费你们一些时间

00:03:53.000 --> 99:59:59.999
我自己也花了一些时间来编程 才得出类似这张表格的结果

