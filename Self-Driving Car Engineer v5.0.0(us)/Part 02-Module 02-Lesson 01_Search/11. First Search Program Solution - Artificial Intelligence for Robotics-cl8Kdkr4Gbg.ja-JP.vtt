WEBVTT
Kind: captions
Language: ja-JP

00:00:00.000 --> 00:00:04.000
答えはこうです 関数「search」を定義します

00:00:04.000 --> 00:00:07.000
ここで実行する唯一の関数ですメインルーチンですね

00:00:07.000 --> 00:00:12.000
展開したセルをチェックしておくと 再度展開しなくてすみます

00:00:12.000 --> 00:00:18.000
「closed」という配列を定義して グリッドと同じサイズにします

00:00:18.000 --> 00:00:23.000
2 つの値 0 と 1 があって 0 は open 1 は closed です

00:00:23.000 --> 00:00:25.000
ブール値も使用できます

00:00:25.000 --> 00:00:31.000
ここは フィールドグリッドと同じサイズの配列を割り当てます

00:00:31.000 --> 00:00:36.000
チェックしたら開始位置を初期化して

00:00:36.000 --> 00:00:42.000
座標を x y に割り当て g の値は 0 にします

00:00:42.000 --> 00:00:47.000
最初のオープンリストは初期座標の 1 要素 g 値の 0 しかありません

00:00:47.000 --> 00:00:52.000
ここまで 同じサイズの closed という配列を定義しました

00:00:52.000 --> 00:00:55.000
すべてのチェックマークがない箇所 左上はオープンリストの

00:00:55.000 --> 00:01:01.000
開始位置で g 値が 0 なので除きます

00:01:01.000 --> 00:01:04.000
コードで 2 つのフラグを使用しました 1 つは found です

00:01:04.000 --> 00:01:07.000
これはゴールの位置が見つかると true になります もう 1 つは resign です

00:01:07.000 --> 00:01:11.000
あらゆる場所を探してゴールの位置が見つからないと true になります

00:01:11.000 --> 00:01:15.000
2 番目は ゴールが見つからずにオープンリストが空になった場合です

00:01:15.000 --> 00:01:19.000
ゴールへの経路が見つからない場合は これがとても重要です

00:01:19.000 --> 00:01:23.000
ここの print コマンドはデバッグに使用していました

00:01:23.000 --> 00:01:26.000
これを見てみましょう既存のオープンリストが出力されますが それだけです

00:01:26.000 --> 00:01:28.000
ただし ここにコードがあります

00:01:28.000 --> 00:01:32.000
ゴールまでの経路が見つからず 問題が解決可能だということを

00:01:32.000 --> 00:01:35.000
証明できない間はこれを繰り返します

00:01:35.000 --> 00:01:38.000
found と resign 両方が false です

00:01:38.000 --> 00:01:45.000
リストが空だと展開するものがないので resign は true print は「fail」です

00:01:45.000 --> 00:01:47.000
これは 2 つの終了条件の 1 つです

00:01:47.000 --> 00:01:51.000
S から G へは経路がないと確信できます

00:01:51.000 --> 00:01:54.000
障壁の左側にあるすべてのノードを 展開する

00:01:54.000 --> 00:01:58.000
ノードがなくなるまで展開します

00:01:58.000 --> 00:02:02.000
この時点でオープンリストは空になり 検索は失敗になります

00:02:02.000 --> 00:02:06.000
オープンリストに要素がまだ残っている場合は その他 (else) ケースになります

00:02:06.000 --> 00:02:13.000
g 値が一番小さい 要素を削除する方法です

00:02:13.000 --> 00:02:18.000
リストの sort 関数を使用します 要素を

00:02:18.000 --> 00:02:20.000
最小の g 値から昇順でソートします

00:02:20.000 --> 00:02:23.000
ここで値が一番小さい要素を表示したいのですが

00:02:23.000 --> 00:02:27.000
pop が出てしまうので リストを反転して

00:02:27.000 --> 00:02:32.000
そのリストから最小の g 値を持つ要素を表示します

00:02:32.000 --> 00:02:35.000
ここは少し注意してくださいあまり上手なやり方ではないですし

00:02:35.000 --> 00:02:38.000
効果的とも言い切れませんが とりあえずの目的は果たせます

00:02:38.000 --> 00:02:42.000
g 値が一番小さい 要素を見つけてくれます

00:02:42.000 --> 00:02:46.000
ここは各三重項で g 値が最初に来るのが重要です

00:02:46.000 --> 00:02:49.000
x と y のすぐ前 最初に入れた理由がこれです

00:02:49.000 --> 00:02:56.000
3 つの値を x y g に割り当てて こう展開します

00:02:56.000 --> 00:03:01.000
繰り返しますが g が 1 番 x と y は 2 番と 3 番です

00:03:01.000 --> 00:03:04.000
さて ゴールに到達したかどうかをテストする箇所にきました

00:03:04.000 --> 00:03:08.000
x が goal 0 で y が goal 1 なら達成ですfound は True になります

00:03:08.000 --> 00:03:11.000
この三重項を出力すると ここに三重項がきます

00:03:11.000 --> 00:03:15.000
ここの「print text」はこの三重項で 探していたものです

00:03:15.000 --> 00:03:19.000
まさにここにある答えを出力するよう求めていました

00:03:19.000 --> 00:03:22.000
さて ここで達成とするなら 面白いケースがあります

00:03:22.000 --> 00:03:24.000
つまりはここでしたプログラミングの本質です

00:03:24.000 --> 00:03:27.000
可能なアクションをすべて見ていきます4 つあります

00:03:27.000 --> 00:03:29.000
delta (デルタ) は異なる 4 つのアクションの配列です

00:03:29.000 --> 00:03:33.000
この追加を使用して x と y にアクションを適用します

00:03:33.000 --> 00:03:37.000
対応するデルタベクトルを適用して x2 と y2 を構成します

00:03:37.000 --> 00:03:48.000
x2 がグリッド内 y2 もグリッド内で [x2, y2] はチェックされていない場合

00:03:48.000 --> 00:03:51.000
ここはこの「closed」というフィールドでテストされるのですが

00:03:51.000 --> 00:03:55.000
さらにグリッドセルが通行可能ならば ここに障害はありません

00:03:55.000 --> 00:04:00.000
これらすべてが正しければ ここで展開され オープンリストに追加されます

00:04:00.000 --> 00:04:07.000
1 足して cost を g から g2 に増やします この場合 cost は 1 です

00:04:07.000 --> 00:04:11.000
新しい [g2, x2, y2] をオープンリストに追加して

00:04:11.000 --> 00:04:15.000
座標 [x2, y2] をチェックすると これ以降は再度展開することはありません

00:04:15.000 --> 00:04:18.000
これが再帰です

00:04:18.000 --> 00:04:23.000
別の例を考えます この要素をここに書いてみます

00:04:23.000 --> 00:04:27.000
ロボットが移動可能な方法を探します

00:04:27.000 --> 00:04:30.000
このソフトウェアでは ロボットはグリッド内に留まり

00:04:30.000 --> 00:04:34.000
グリッドセルには何もありません ここでテストしています

00:04:34.000 --> 00:04:37.000
セルごとにチェックマークが付いているかどうかも確認します

00:04:37.000 --> 00:04:41.000
これはここでテストしていますこれは常に true です

00:04:41.000 --> 00:04:45.000
新しい要素をオープンリストに追加しました

00:04:45.000 --> 00:04:50.000
新しい g 値は増分され 座標も新しくなりました

00:04:50.000 --> 00:04:52.000
それがここで起きていることです

00:04:52.000 --> 00:04:56.000
g 値を増やして 新しい座標でそれを追加します

00:04:56.000 --> 00:04:58.000
これが Search (検索) アルゴリズムの鍵です

00:04:58.000 --> 00:05:01.000
最後に search ルーチンを呼び出します

00:05:01.000 --> 99:59:59.999
これが ここに 出力されます

