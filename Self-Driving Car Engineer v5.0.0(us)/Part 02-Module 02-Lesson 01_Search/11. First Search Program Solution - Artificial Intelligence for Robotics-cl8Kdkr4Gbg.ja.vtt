WEBVTT
Kind: captions
Language: ja

00:00:00.560 --> 00:00:03.450
これが私のプログラムです
search関数を定義しました

00:00:03.450 --> 00:00:06.350
最後までこの関数しか使わないので
メインルーチンです

00:00:06.700 --> 00:00:12.000
同じセルを2度は展開したくないので

00:00:12.000 --> 00:00:18.000
重複チェックのためにグリッドと同じ大きさの
closedという列を定義します

00:00:18.000 --> 00:00:23.000
これには2つの値があり
0が未展開で1が展開済みを示します

00:00:23.000 --> 00:00:25.000
ブール型を使ってもいいでしょう

00:00:25.000 --> 00:00:30.800
ここでclosedに
グリッドと同じ大きさの配列を割り当てます

00:00:31.000 --> 00:00:36.000
スタート地点のセルを展開済みとし

00:00:36.000 --> 00:00:42.000
x座標、y座標の初期値にゼロを割り当てて
g値もゼロで初期化します

00:00:42.000 --> 00:00:46.240
最初のopenリストの要素は1つだけで
xy座標にinit、g値にゼロが割り当てられています

00:00:46.700 --> 00:00:52.000
ここまででclosedは
グリッドと同じ大きさの配列を定義しました

00:00:52.000 --> 00:00:55.000
スタート地点のチェックマーク以外はありません

00:00:55.000 --> 00:01:00.200
OPENリストでのスタート地点はこの左上で
g値はゼロになっています

00:01:00.800 --> 00:01:03.290
プログラムの中では2つのフラグを使っています
1つはfoundで

00:01:03.290 --> 00:01:06.630
ゴール地点が発見できたらtrueになります

00:01:06.630 --> 00:01:11.000
もう1つはresignですべてのセルに展開しても
ゴールが発見できなかった場合にtrueになります

00:01:11.000 --> 00:01:15.000
2つ目のフラグはゴールが発見できずに
openリストに候補が無くなった場合に使用します

00:01:15.000 --> 00:01:19.000
この場合はどこでゴールへの経路が
探せなくなったかがとても重要になります

00:01:19.000 --> 00:01:23.000
ここで示されるprint命令は
デバッグに使ったものです

00:01:23.000 --> 00:01:26.000
これはOPENリストの要素を出力しただけです

00:01:26.000 --> 00:01:28.000
これらがプログラムのコードです

00:01:28.000 --> 00:01:32.000
ゴールまで経路が見つからず
問題が解けないことが証明されない限りは

00:01:32.000 --> 00:01:35.000
以下の処理を繰り返していきます

00:01:35.000 --> 00:01:37.100
foundとresignの両方がfalseです

00:01:37.500 --> 00:01:40.530
OPENリストが空で展開する候補もなくなったら

00:01:42.000 --> 00:01:44.670
resignはtrueとなりfailと出力されます

00:01:45.000 --> 00:01:47.000
これは2つある終了条件のうちの1つです

00:01:47.000 --> 00:01:51.000
スタートからゴールまでの経路は
ないと分かりました

00:01:51.000 --> 00:01:54.000
展開できるノードが無くなるまで

00:01:54.000 --> 00:01:58.000
障害物の左側のすべてのノードに展開し

00:01:58.000 --> 00:02:02.000
OPENリストが空になればそこで探索は失敗です

00:02:02.550 --> 00:02:06.000
もしOPENリストの要素がまだあれば
違う展開になります

00:02:06.380 --> 00:02:12.500
これが最小のg値を持つ要素を
除外していく方法です

00:02:12.500 --> 00:02:14.930
ソート関数を使って

00:02:14.930 --> 00:02:19.200
g値が昇順になるように並べ替えます

00:02:20.000 --> 00:02:23.000
ここでpopを使ってリストの要素を取り出します

00:02:23.000 --> 00:02:27.000
あいにくpopはリストの末尾の要素を取り出すので

00:02:27.000 --> 00:02:32.000
リストを逆順に並べ替えてから
g値が最小のものを取り出します

00:02:32.000 --> 00:02:35.000
ちょっとした小細工なので
あまりきれいではありません

00:02:35.000 --> 00:02:38.000
効率的とも言えませんが必要な処理なのです

00:02:38.300 --> 00:02:42.000
ここでg値が最小である要素を取り出します

00:02:42.000 --> 00:02:46.000
3つの値のセットの最初に
g値を設定することがポイントなので

00:02:46.000 --> 00:02:49.000
そのためxy座標の前にg値をセットします

00:02:49.000 --> 00:02:56.000
そのあとでx、y、gに次の展開の値を割り当てます

00:02:56.000 --> 00:02:59.140
もう1度言いますがgが1番目でその後にx、yです

00:03:00.700 --> 00:03:03.350
次はゴールに到達したかどうかを判定します

00:03:03.350 --> 00:03:08.000
x＝goal［0］、y＝goal［1］なら
foundフラグをtrueにします

00:03:08.000 --> 00:03:11.000
openリストの3つの値を画面の下に出力します

00:03:11.000 --> 00:03:15.000
このprint nextで
求めている3つの値を出力することができます

00:03:15.000 --> 00:03:18.600
これが皆さんに出している課題です

00:03:18.850 --> 00:03:22.000
探索が終了していない場合は
面白い処理になります

00:03:22.000 --> 00:03:24.000
これが私のプログラムの核心部分です

00:03:24.000 --> 00:03:27.000
すべての可能な動きについて処理を行います

00:03:27.000 --> 00:03:29.000
deltaは4つの異なる動きを定義した列です

00:03:29.000 --> 00:03:33.000
動きを定義したこのdeltaをx、yに加算して

00:03:33.000 --> 00:03:37.000
x2、y2を作り出します

00:03:37.000 --> 00:03:42.520
もしx2とy2がgグリッド内に収まって

00:03:43.600 --> 00:03:51.000
ここでclosedリストを参照して
［x2，y2］が未チェックなら

00:03:51.600 --> 00:03:54.400
障害物もないので展開可能なセルと判定されます

00:03:54.450 --> 00:04:00.000
これらすべてがtrueなら展開できて
OPENリストに要素を追加します

00:04:00.000 --> 00:04:06.300
また各ステップ当たりのコストが1なので
g2＝g＋1とします

00:04:06.840 --> 00:04:11.000
その後でOPENリストに［g2，x2，y2］を追加して

00:04:11.600 --> 00:04:15.000
同じセルを2度 展開しないように
座標［x2，y2］にチェックを入れます

00:04:15.600 --> 00:04:17.600
これは反復処理です

00:04:17.600 --> 00:04:21.790
言い換えれば例として要素を書いて説明した時は

00:04:23.280 --> 00:04:26.330
ロボットの可能な動きについて調べました

00:04:26.330 --> 00:04:30.000
このプログラムにおいてロボットは
6×5のグリッドセルの中に収まっていて

00:04:30.000 --> 00:04:34.000
展開するセルは
空いている状態でなければいけません

00:04:34.000 --> 00:04:37.000
該当のセルが
すでにチェック済みであるかどうかも調べますが

00:04:37.000 --> 00:04:41.000
それはここで判定します　常にtrueでした

00:04:41.000 --> 00:04:45.000
そのあとで1つ加算されたg値と新しいxy座標を

00:04:45.000 --> 00:04:48.980
OPENリストに追加しました

00:04:50.000 --> 00:04:52.000
それはこの部分で処理されます

00:04:52.000 --> 00:04:54.920
g値に1つ加算して
新しいxy座標とともにリストに追加します

00:04:55.600 --> 00:04:57.400
これが探索アルゴリズムのカギです

00:04:57.900 --> 00:05:01.000
最後にsearchルーチンを呼び出して

00:05:01.000 --> 00:05:04.330
結果を表示させればいいだけです

