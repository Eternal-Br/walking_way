WEBVTT
Kind: captions
Language: ja-JP

00:00:00.000 --> 00:00:05.000
実際に実装するプログラムはこれまで実装したものに比べて

00:00:05.000 --> 00:00:08.000
極めて短いことがわかります

00:00:08.000 --> 00:00:10.000
この変更を加えて実装した A* は最も強力な探索アルゴリズム

00:00:10.000 --> 00:00:14.000
の 1 つであり 未整備の環境での

00:00:14.000 --> 00:00:18.000
自動運転車に現在使用されています

00:00:18.000 --> 00:00:22.000
最初に open リストの要素を展開し

00:00:22.000 --> 00:00:25.000
以前のように g 値だけ含めるのではなく f 値も含めるようにします

00:00:25.000 --> 00:00:27.000
私は h 値も含めましたが

00:00:27.000 --> 00:00:31.000
必ずしもそうする必要はありません

00:00:31.000 --> 00:00:34.000
今回は 5 つの要素を使用し g 値は以前と同じです

00:00:34.000 --> 00:00:39.000
h はセル x y のヒューリスティック値であり f は g と h の合計です

00:00:39.000 --> 00:00:43.000
f を左端に記述したのはソート処理に必要だからです

00:00:43.000 --> 00:00:47.000
これでリストをソートするときに f を基準にソートされます

00:00:47.000 --> 00:00:51.000
2 つの要素が加えられたことに注目してください

00:00:51.000 --> 00:00:57.000
また f を左端に移動させることで g 値の最小値ではなく

00:00:57.000 --> 00:01:01.000
f 値の最小値をもつ要素が取り出されるようになっています

00:01:01.000 --> 00:01:06.000
さらに下がってこれらの行で記述されているようにノードを展開します

00:01:06.000 --> 00:01:11.000
次の構造のようにインデックスに少し変更を加える必要があります

00:01:11.000 --> 00:01:16.000
ここでは x が要素番号 3 になります インデックスが 0 から始まる場合

00:01:16.000 --> 00:01:18.000
正確にはリストで 4 番目の要素となります

00:01:18.000 --> 00:01:19.000
y は 4 番目で

00:01:19.000 --> 00:01:21.000
g は 1 番目の要素です

00:01:21.000 --> 00:01:27.000
f と h はすぐに計算できるのでここで指定する必要はありません

00:01:27.000 --> 00:01:34.000
さらに下がってここでノードをリストから展開します

00:01:34.000 --> 00:01:39.000
そして考えられるすべての動作および次の状態を計算し

00:01:39.000 --> 00:01:42.000
展開する上で適切な状態であるかテストします

00:01:42.000 --> 00:01:48.000
これまでと同様 g は cost 関数の分だけ加算しますがここに新しいコードが 2 行あります

00:01:48.000 --> 00:01:52.000
最初の行では新しく展開したノードのヒューリスティック関数を計算します

00:01:52.000 --> 00:01:53.000
これは極めて単純なもので

00:01:53.000 --> 00:01:54.000
h2 と呼びます

00:01:54.000 --> 00:02:00.000
それから次のコード行では g 値と h 値の新しい合計を計算します

00:02:00.000 --> 00:02:06.000
これら 5 つの値:新しい f 値 新しい g 値 新しい h 値

00:02:06.000 --> 00:02:10.000
そして展開ノードの x y 座標を open リストに付加します

00:02:10.000 --> 00:02:14.000
新しい値として最も重要なのは f 値ですが h 値も重要です

00:02:14.000 --> 00:02:18.000
A* の実装については以上です

00:02:18.000 --> 00:02:21.000
つまり g 値の最小値ではなく f 値の最小値を持つノードが

00:02:21.000 --> 00:02:26.000
選択されるように スタックからノードを取り出すロジックを

00:02:26.000 --> 00:02:30.000
変更しただけです これが A* を実装する方法です

00:02:30.000 --> 00:02:32.000
ではこれを実行してみましょう

00:02:32.000 --> 00:02:34.000
これは以前に見た迷路のグリッドです

00:02:34.000 --> 00:02:38.000
最上部を空けるようにして下を壁でふさぎます

00:02:38.000 --> 00:02:41.000
この場合 A* はあまり有効に機能しません

00:02:41.000 --> 00:02:44.000
このエリアにはどちらの道に進むかという優先度がなく

00:02:44.000 --> 00:02:46.000
A* はやっとゴールノードを見つけます

00:02:46.000 --> 00:02:50.000
ただしここに大きな障害物を水平に設置すると状況が変わります

00:02:50.000 --> 00:02:54.000
非常に興味深いことに A* は水平方向の経路と

00:02:54.000 --> 00:02:56.000
垂直方向の経路のどちらが最適かを決められないことがわかります

00:02:56.000 --> 00:03:01.000
そのため水平方向と垂直方向のノードを行ったり来たりします

00:03:01.000 --> 00:03:05.000
端に到達した時点で以前と同じ手法が適用されます

00:03:05.000 --> 00:03:07.000
中央部でノードが展開されなくなりゴール方向に

00:03:07.000 --> 00:03:10.000
まっすぐ進んで到達します

00:03:10.000 --> 00:03:12.000
A* を使用しない場合には起こりません

00:03:12.000 --> 00:03:15.000
古い探索アルゴリズムに戻す方法は空の

00:03:15.000 --> 00:03:17.000
ヒューリスティック関数を指定することです

00:03:17.000 --> 00:03:24.000
これがどこでも常に h をゼロに初期化するヒューリスティック関数の定義であり

00:03:24.000 --> 00:03:27.000
このヒューリスティック関数の代わりに使用します 今は使わないので

00:03:27.000 --> 00:03:30.000
heuristic_old とします そしてこれが現在のヒューリスティック関数です

00:03:30.000 --> 00:03:35.000
値がすべて 0 のヒューリスティック関数を用いて実行すると 元の探索アルゴリズムに戻ります

00:03:35.000 --> 00:03:39.000
ご覧のようにこの探索アルゴリズムでは内側が少し探索され

00:03:39.000 --> 00:03:42.000
その結果 A* の場合よりも多くのノードが展開されています

00:03:42.000 --> 00:03:46.000
これはささいなことに見えますが非常に大規模な環境では大きな違いが出ます

00:03:46.000 --> 00:03:50.000
ゴールに到達できない袋小路が

00:03:50.000 --> 00:03:51.000
ある場合は特に顕著です

00:03:51.000 --> 99:59:59.999
このように A* は単純な探索に比べてはるかに効率的に機能します

