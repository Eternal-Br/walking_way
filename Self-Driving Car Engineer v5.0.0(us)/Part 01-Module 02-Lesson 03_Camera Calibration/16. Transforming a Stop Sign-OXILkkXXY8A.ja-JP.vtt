WEBVTT
Kind: captions
Language: ja-JP

00:00:00.050 --> 00:00:03.699
これは ある角度から見たSTOP標識の画像です

00:00:03.700 --> 00:00:07.240
透視変換を作成および適用して

00:00:07.240 --> 00:00:10.199
この標識を正面から見たようにする方法をお見せします

00:00:10.199 --> 00:00:14.449
すでに述べたように 透視変換を扱うのは

00:00:14.449 --> 00:00:17.730
私たちが作成するソフトウェアは最終的に道路の画像にこれを行って

00:00:17.730 --> 00:00:19.629
車線の曲率がわかるようにするからです

00:00:19.629 --> 00:00:23.619
ここで例として交通標識を使用するのは

00:00:23.620 --> 00:00:27.330
画像に透視変換を正しく行ったことを

00:00:27.329 --> 00:00:30.696
テキストやその他のわかりやすい参照点で容易に見分けることができるためです

00:00:30.696 --> 00:00:35.420
透視変換を作成するには まず この画像内の平面上に矩形を定義する

00:00:35.420 --> 00:00:38.039
4つの点を選択します

00:00:38.039 --> 00:00:41.200
ある視点から別の視点への線形変換を定義するには

00:00:41.200 --> 00:00:43.170
4つの点で十分です

00:00:43.170 --> 00:00:44.210
また この例では

00:00:44.210 --> 00:00:48.469
STOP標識の表面上の平面を定義する点を選択します

00:00:48.469 --> 00:00:52.240
同じ4点を表示して変換したい場所も選択します

00:00:52.240 --> 00:00:55.530
これは しばしば 歪んだ画像と呼ばれます

00:00:55.530 --> 00:00:59.340
次に OpenCV関数を使用して 変換を計算できます

00:00:59.340 --> 00:01:01.790
これは元の画像の点を

00:01:01.789 --> 00:01:03.960
別の視点の歪んだ画像にマッピングすることです

00:01:05.090 --> 00:01:08.450
このノートブックに STOP標識の画像を書き込みました

00:01:08.450 --> 00:01:11.200
それがインタラクティブウィンドウに表示されています

00:01:11.200 --> 00:01:14.500
画像が少し角度をつけて撮影されたことがわかります

00:01:14.500 --> 00:01:17.150
これに変換を適用して

00:01:17.150 --> 00:01:19.000
正面から見た標識にします

00:01:19.000 --> 00:01:23.340
まず、このオリジナルのソース画像と、まだ存在しませんが

00:01:23.340 --> 00:01:26.969
歪んだディスティネーション画像に手動で4つの点を作成します

00:01:26.969 --> 00:01:29.929
これらの点が透視変換を定義します

00:01:29.930 --> 00:01:32.690
まずソースのイメージポイントを作成します

00:01:32.689 --> 00:01:34.480
必要な各点のX座標とY座標を見て

00:01:34.480 --> 00:01:37.160
点を選びます

00:01:37.159 --> 00:01:39.289
このインタラクティブウィンドウでは

00:01:39.290 --> 00:01:42.359
各点にマウスを合わせると そのXとYの値が表示されます

00:01:42.359 --> 00:01:44.579
では STOP標識を拡大して 見やすくしましょう

00:01:46.750 --> 00:01:50.280
最初の点は標識の右上隅に定義します

00:01:50.280 --> 00:01:53.040
2番目の点は その下です

00:01:53.040 --> 00:01:56.780
その左と最後に左上隅です

00:01:58.280 --> 00:02:01.980
これが選択した4点のX座標とY座標です

00:02:01.980 --> 00:02:05.310
この4つの点は標識上の矩形の平面を定義します

00:02:05.310 --> 00:02:08.969
それを画像の上に表示して 必要な場所にあるかどうかを確認することもできます

00:02:08.969 --> 00:02:12.770
それにはplt.plot X座標とY座標 そしてこのドット文字を使用します

00:02:14.340 --> 00:02:17.377
ここに4つの点がすべて表示されていますが なかなかいいようです

00:02:17.377 --> 00:02:19.302
[無音]

00:02:19.301 --> 00:02:20.709
ここまでが最初のステップです

00:02:20.710 --> 00:02:23.980
しかし 透視変換を適用するには2つのステップが必要です

00:02:23.979 --> 00:02:27.169
そこで これらの座標をwarpという名前の関数に入れます

00:02:27.169 --> 00:02:30.586
この関数は画像を取り込んで 歪んだ画像を返します

00:02:30.586 --> 00:02:33.484
これが画像を取り込むwarp関数です

00:02:33.485 --> 00:02:35.945
ここでは先ほど選んだのと同じ4つの座標が

00:02:35.944 --> 00:02:39.935
ソース画像を意味するsrcという名前の点の配列に置かれています

00:02:39.935 --> 00:02:44.055
次に、ワープド画像に必要な矩形平面を定義して

00:02:44.055 --> 00:02:47.155
ソースポイントを配置したい4つの点を選びます

00:02:47.155 --> 00:02:48.224
選びます

00:02:48.224 --> 00:02:51.504
今回 点を選ぶには

00:02:51.504 --> 00:02:52.740
は同じ画像に目見当で矩形を描きます

00:02:52.740 --> 00:02:54.770
そしてその矩形を定義する4つの点を選びます

00:02:54.770 --> 00:02:58.210
右上隅から始めて左上隅へと進みます

00:02:58.210 --> 00:03:02.770
この4つの点は必要な矩形を定義します  これらの点を

00:03:02.770 --> 00:03:07.550
warp関数に入れて デスティネーションを意味するdstという名前の点の配列にします

00:03:07.550 --> 00:03:09.080
ソースポイントと

00:03:09.080 --> 00:03:12.810
デスティネーションポイントができたので 透視変換を計算できます

00:03:12.810 --> 00:03:17.310
これは関数getPerspectiveTransformによって返される行列です

00:03:17.310 --> 00:03:21.259
関数getPerspectiveTransformは4つのソースポイントと

00:03:21.259 --> 00:03:23.219
デスティネーションポイントを取り

00:03:23.219 --> 00:03:27.659
マッピング透視行列を返します これをMと呼ぶことにします

00:03:27.659 --> 00:03:31.194
逆透視変換を行って画像の歪み補正を行うこともできます

00:03:31.194 --> 00:03:35.875
それには この関数のソースポイントとデスティネーションポイントを入れ替えるだけです

00:03:35.875 --> 00:03:37.530
これは変換を元に戻すだけです

00:03:38.719 --> 00:03:43.376
次に必要なのは 変換Mを元の画像に適用して 歪んだ画像を取得するだけです

00:03:43.376 --> 00:03:47.066
warpPerspectiveを呼び出して これを行います

00:03:47.066 --> 00:03:51.606
warpPerspectiveは内部画像 透視行列M 歪んだ画像のサイズを取りますが

00:03:51.606 --> 00:03:56.144
ここでは元の画像と同じサイズにしておきます

00:03:56.144 --> 00:04:00.408
また補間方法も取ります

00:04:00.407 --> 00:04:04.449
これは画像を歪めるときに失われるポイントを埋めるだけですこれを線形補間といいます

00:04:04.449 --> 00:04:08.179
この関数は この行列Mと与えられた画像に基づいて

00:04:08.180 --> 00:04:09.890
歪んだ画像を返します

00:04:09.889 --> 00:04:12.129
最後に この歪んだ画像を返します

00:04:13.159 --> 00:04:17.439
では warp関数を画像に適用するとどうなるか見てみましょう

00:04:17.439 --> 00:04:19.269
これがオリジナル画像と変換後の画像を

00:04:19.269 --> 00:04:21.588
並べて表示するコードです

00:04:21.588 --> 00:04:23.810
これが元の画像と歪んだ画像です

00:04:23.810 --> 00:04:24.519
かなり良いようです

00:04:24.519 --> 00:04:28.469
STOP標識の正面に立って見たようになりました

00:04:28.470 --> 00:04:31.340
今度は皆さんが新しい画像に透視変換を適用する番です

