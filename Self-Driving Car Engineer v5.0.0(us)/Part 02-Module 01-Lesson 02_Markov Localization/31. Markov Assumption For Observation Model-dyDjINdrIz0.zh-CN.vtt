WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:02.865
这里 马尔可夫假设又派上用场了

00:00:02.865 --> 00:00:05.804
因为你假设你现在知道状态 Xt

00:00:05.804 --> 00:00:10.199
那么车辆的观察结果以及在 Xt 之前的移动如何都不重要了

00:00:10.199 --> 00:00:14.139
这些值已经用来估算 Xt 了

00:00:14.140 --> 00:00:17.515
而且这些值对 t 没有价值

00:00:17.515 --> 00:00:20.550
这意味着 我们假设 t 独立于

00:00:20.550 --> 00:00:24.539
之前的所有观察和控制

00:00:24.539 --> 00:00:28.129
同样地 这个例子也使用了马尔可夫假设

00:00:28.129 --> 00:00:34.004
我可以把我们的先验分布简化为 p(zt)

00:00:34.005 --> 00:00:38.219
仅依赖于 Xt 和地图

00:00:38.219 --> 00:00:40.993
我们再仔细看看观察模型

00:00:40.993 --> 00:00:46.534
你是否记得 这个 t 是或者可能是多次观察的向量？

00:00:46.534 --> 00:00:49.949
这意味着 我们可以用这种方式重写观察模型

00:00:49.950 --> 00:00:54.425
现在 我们假设单个距离值 zt 1 到 zt k 的噪音行为

00:00:54.424 --> 00:01:00.099
是相互独立的

00:01:00.100 --> 00:01:03.460
这也意味着所有观察都是相互独立的

00:01:03.460 --> 00:01:08.010
因此 我们能够把观察模型表示为

00:01:08.010 --> 00:01:13.719
每个单个距离测量值的单独概率分布的乘积

00:01:13.719 --> 00:01:15.114
现在 问题是

00:01:15.114 --> 00:01:19.629
我们如何定义单个距离测量值的观察模型？

00:01:19.629 --> 00:01:22.674
一般来说 有很多不同的观察模型

00:01:22.674 --> 00:01:27.575
因为我们有很多不同传感器 比如激光雷达

00:01:27.575 --> 00:01:30.875
摄像头、雷达或超声传感器

00:01:30.875 --> 00:01:35.599
而且每个传感器都有特定的噪音行为和表现

00:01:35.599 --> 00:01:39.099
观察模型还依赖于地图类型

00:01:39.099 --> 00:01:43.669
你可以使用密集的二维或三维网格地图 或基于特征的稀疏地图

00:01:43.670 --> 00:01:45.308
在我们的一维案例中

00:01:45.308 --> 00:01:48.190
我们假设传感器测量了

00:01:48.189 --> 00:01:52.125
距离驾驶方向上最近的 n 个对象的距离

00:01:52.125 --> 00:01:54.454
如右侧所示

00:01:54.454 --> 00:02:02.185
汽车测量了 19 米 探测到第一个对象 然后 又测量了 37 米 探测到第二个对象

00:02:02.185 --> 00:02:06.135
前面说过 对象代表地图上的地标

00:02:06.135 --> 00:02:09.289
这里 我们假设观察噪音可以建模为

00:02:09.289 --> 00:02:12.974
高斯分布 标准差为 1 米

00:02:12.974 --> 00:02:18.264
我们还假设 传感器可以测量的范围是 0 到 100 米

00:02:18.264 --> 00:02:20.839
要实现观察模型

00:02:20.840 --> 00:02:27.925
你使用给定的状态 Xt 和给定的地图来估算所谓的伪距离

00:02:27.925 --> 00:02:32.945
这些伪距离代表了真实的距离值 其假设条件为

00:02:32.944 --> 00:02:35.840
车辆在地图上的具体位置

00:02:35.840 --> 00:02:37.405
是 Xt

00:02:37.405 --> 00:02:41.870
例如 假设你的车辆在位置 20 这里

00:02:41.870 --> 00:02:45.335
并且首先观察到 5 米

00:02:45.335 --> 00:02:47.210
然后观察到 11 米

00:02:47.210 --> 00:02:49.370
接着是 39 米

00:02:49.370 --> 00:02:52.974
最后是第 57 米 观察到最后一个地标

00:02:52.974 --> 00:02:55.424
和真正的观察相比

00:02:55.424 --> 00:02:58.465
这个位置看起来很不可能 对吗？

00:02:58.465 --> 00:03:02.180
因此 观察更接近在位置 40 的这个地方

00:03:02.180 --> 00:03:03.189
根据这个例子

00:03:03.189 --> 00:03:05.645
单个距离测量的观察模型

00:03:05.645 --> 00:03:09.575
可以根据下列正态分布确定

00:03:09.574 --> 00:03:16.389
该正态分布由 Z 星 tk 和 sigma确定

00:03:16.389 --> 00:03:20.314
深入了解之后 你就能够在 C++ 中实现观察模型了

00:03:20.314 --> 00:03:22.234
但在你开始编程之前

00:03:22.235 --> 00:03:26.440
先和我一起学完基本定位滤波器理论的最后部分

