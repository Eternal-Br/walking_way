WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:02.240
我讲了很多数学知识

00:00:02.240 --> 00:00:05.660
首先 我们回顾一下前面几个步骤的主要内容

00:00:05.660 --> 00:00:07.570
总结一下

00:00:07.570 --> 00:00:09.910
贝叶斯定位滤波器 或贝叶斯滤波器

00:00:09.910 --> 00:00:13.240
是递归状态预估的通用框架

00:00:13.240 --> 00:00:16.210
递归表示我们使用之前的状态

00:00:16.210 --> 00:00:19.870
来估算新状态 仅依赖于当前观察

00:00:19.870 --> 00:00:23.440
和控制 无需知道全部的历史数据

00:00:23.440 --> 00:00:27.310
运动模型描述了滤波器的预测步骤

00:00:27.309 --> 00:00:29.899
观察模型是更新步骤

00:00:29.899 --> 00:00:33.320
它可以估算新的状态概率

00:00:33.320 --> 00:00:36.320
你之前已经听过预测和更新步骤

00:00:36.320 --> 00:00:38.520
之间的互动

00:00:38.520 --> 00:00:41.370
比如 Andray 在融合课程中讨论

00:00:41.369 --> 00:00:43.729
卡尔曼滤波器时讲过

00:00:43.729 --> 00:00:47.599
这意味着 当前的一维定位、卡尔曼滤波器

00:00:47.600 --> 00:00:50.640
以及例子滤波器都是贝叶斯滤波器

00:00:50.640 --> 00:00:52.579
的实现

00:00:52.579 --> 00:00:55.280
现在 你了解了概率推理和

00:00:55.280 --> 00:00:57.109
递归的状态估算

00:00:57.109 --> 00:01:00.530
这是个了不起的成就 不仅仅针对定位

00:01:00.530 --> 00:01:04.310
对整个无人驾驶车纳米课程都很了不起

00:01:04.310 --> 00:01:07.480
既然你已经熟悉了相关理论

00:01:07.480 --> 00:01:12.370
我们再回到 C++ 案例 完成定位器

