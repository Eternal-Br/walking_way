WEBVTT
Kind: captions
Language: zh-CN

00:00:00.320 --> 00:00:04.227
这次 我们来看一个更真实的图像

00:00:04.227 --> 00:00:07.179
这是一辆汽车的 64×64 像素图像

00:00:07.179 --> 00:00:11.509
让我们计算每个像素的梯度幅值和方向

00:00:11.509 --> 00:00:15.429
我们不会逐像素使用这些梯度

00:00:15.429 --> 00:00:21.289
而是统计每个小的单元格中的梯度 假设每个单元格大小为 8×8 像素

00:00:21.289 --> 00:00:24.349
在每个单元格内有神奇的事情会发生

00:00:24.350 --> 00:00:27.400
你可以计算单元格内 64 个

00:00:27.399 --> 00:00:32.019
梯度的直方图

00:00:32.020 --> 00:00:36.720
梯度样本按照方向被分布到直方图的 9 个柱 (orientation bins) 中

00:00:36.719 --> 00:00:37.810
然后求和

00:00:37.810 --> 00:00:41.510
样本规模不大的时候 通常不需要很高的精度

00:00:41.509 --> 00:00:44.899
所得到的直方图看起来大概是这样

00:00:44.899 --> 00:00:47.060
将还有一个更好的可视化方法

00:00:47.060 --> 00:00:51.480
就是在把各个梯度按照方向分类放置

00:00:51.479 --> 00:00:56.719
从而得到图中所示的各方向矢量大小不同的星形

00:00:56.719 --> 00:01:00.689
最长矢量的方向

00:01:00.689 --> 00:01:01.949
代表这个单元格的主梯度方向

00:01:01.950 --> 00:01:06.450
注意 这个直方图并不是

00:01:06.450 --> 00:01:07.540
对每个方向梯度数量进行求和

00:01:07.540 --> 00:01:11.860
你需要计算的是所有像素梯度的矢量和

00:01:11.859 --> 00:01:16.280
因此 梯度幅值越大 对该方向对应的直方图柱的贡献就越大

00:01:16.280 --> 00:01:21.760
从而减少了例如噪声引入的随机梯度影响

00:01:21.760 --> 00:01:26.490
换句话说 图像中的每个像素根据其梯度方向

00:01:26.489 --> 00:01:30.259
对直方图中对应方向的柱进行投票

00:01:30.260 --> 00:01:31.219
但是每一票的强度 或称为权重

00:01:31.219 --> 00:01:36.090
取决于该像素梯度的幅值

00:01:36.090 --> 00:01:38.079
当你对所有单元格投票后

00:01:38.079 --> 00:01:42.409
你开始看到原始结构轮廓的出现

00:01:42.409 --> 00:01:45.269
正如此前采用更简单的形状演示的那样

00:01:45.269 --> 00:01:49.289
这个轮廓可以用作给定形状的特征

00:01:49.290 --> 00:01:54.780
它被称为梯度方向直方图 或 HoG 特征

00:01:54.780 --> 00:01:58.920
这种方法的主要优势在于

00:01:58.920 --> 00:02:03.310
你可以在形状发生小幅变化同时 保持形状特征的独特性

00:02:03.310 --> 00:02:07.265
可以通过调整各个参数 来改变特征对于小幅变化的适应程度

00:02:07.265 --> 00:02:11.699
这些参数包括 柱的数量 单元格格数

00:02:11.699 --> 00:02:15.780
单元格大小、以及是否在单元格之间增加重叠部分等

00:02:15.780 --> 00:02:20.620
在实际应用中 我们可以使用许多其他增强功能

00:02:20.620 --> 00:02:24.120
包括对每个单元格内的梯度幅值进行归一化处理

00:02:24.120 --> 00:02:28.030
如果想更深入地了解 HoG

00:02:28.030 --> 00:02:29.319
以及如何用它来进行人的检测

00:02:29.319 --> 00:02:33.234
请参考讲师注释中的链接

