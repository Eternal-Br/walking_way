WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.009
设计成本函数是比较困难的工作

00:00:03.009 --> 00:00:06.945
而将它们组合起来以生成可用的车辆行为则是非常困难的工作

00:00:06.945 --> 00:00:09.990
其中的一些困难与成本函数设计相关

00:00:09.990 --> 00:00:13.775
包括既要解决新问题 又不会影响老问题

00:00:13.775 --> 00:00:15.810
当你从事与无人驾驶车有关的工作时

00:00:15.810 --> 00:00:18.179
你也许会发现 车辆行为还可以

00:00:18.179 --> 00:00:21.050
但是一些特定情况除外

00:00:21.050 --> 00:00:25.019
比如 在交通信号灯处 车辆可能畏畏缩缩 不敢大胆左转

00:00:25.019 --> 00:00:27.254
于是 为了解决这个问题

00:00:27.254 --> 00:00:28.875
你添加了新的成本函数

00:00:28.875 --> 00:00:31.815
或者修改了当前使用的成本函数 或者修改了权重

00:00:31.815 --> 00:00:33.134
但是 你每次去做这些的时候

00:00:33.134 --> 00:00:34.649
很可能 你会把新问题

00:00:34.649 --> 00:00:37.140
带入已经工作得很好的原有模块中

00:00:37.140 --> 00:00:41.505
实践中 我们通过回归测试来解决这个问题

00:00:41.505 --> 00:00:43.980
我们定义了一些场景

00:00:43.979 --> 00:00:46.944
每个场景都有预期行为

00:00:46.945 --> 00:00:49.005
接下来 每当我们做出改变

00:00:49.005 --> 00:00:50.880
我们运行所有测试用例来进行测试

00:00:50.880 --> 00:00:55.455
确保车辆依然还保持预期行为

00:00:55.454 --> 00:00:57.734
关于测试 我们这里不展开论述

00:00:57.734 --> 00:01:03.174
但是测试是很重要的部分

00:01:03.174 --> 00:01:08.179
另一个困难是 如何去平衡各种目标量之间的冲突

00:01:08.180 --> 00:01:11.460
比如 我们想要高效地到达目的地

00:01:11.459 --> 00:01:14.354
但是如果我们处于这样一个场景 在那里安全是个重要问题

00:01:14.355 --> 00:01:18.305
那么 我们会解决安全问题 而忽略效率

00:01:18.305 --> 00:01:20.880
这方面的一种解决方法是定义权重

00:01:20.879 --> 00:01:24.049
权重反映出成本函数相关问题的类型

00:01:24.049 --> 00:01:25.875
比如 我们不会考虑

00:01:25.875 --> 00:01:29.185
任何物理上不可行的行为

00:01:29.185 --> 00:01:32.640
然后我们还要考虑安全性 合规性 舒适性

00:01:32.640 --> 00:01:36.079
当这些目标全部满足后 我们才会考虑高效性

00:01:36.079 --> 00:01:37.679
但是我们也会根据情况 来调整

00:01:37.680 --> 00:01:41.050
这些权重的相对重要性

00:01:41.049 --> 00:01:42.929
例如 如果红灯亮了

00:01:42.930 --> 00:01:45.490
与进入一般高速驾驶模式相比

00:01:45.489 --> 00:01:48.384
合规性就变得非常重要

00:01:48.385 --> 00:01:51.225
这引出了我们最后一个困难

00:01:51.224 --> 00:01:54.609
那就是 如何推导出每一个成本函数

00:01:54.609 --> 00:01:59.400
理想情况下 每个成本函数负责某个特定方面

00:01:59.400 --> 00:02:04.890
这些方面是我们之前在速度成本函数例子中没有涉及的东西

00:02:04.890 --> 00:02:08.460
我们想要在高速高效行驶和不超速之间

00:02:08.460 --> 00:02:10.125
获取一种平衡

00:02:10.125 --> 00:02:14.810
超速行为涉及到合规性

00:02:14.810 --> 00:02:16.920
实践中 我们也许会定义

00:02:16.919 --> 00:02:21.099
几个成本函数 并和速度相关联

00:02:21.099 --> 00:02:25.659
在上述例子中 我们或许会定义一个二态成本函数 

00:02:25.659 --> 00:02:27.969
用来检测是否超速

00:02:27.969 --> 00:02:31.060
还有一个连续性成本函数 用来将车速调到目标车速

00:02:31.060 --> 00:02:34.465
通过给特定规则定义一个成本函数

00:02:34.465 --> 00:02:38.444
比如 安全性 合规性 高效性

00:02:38.444 --> 00:02:45.204
我们可以标准化所有成本函数的输出值 让结果位于-1和1之间

00:02:45.205 --> 00:02:48.260
另外 尽可能参数化也是很有用的

00:02:48.259 --> 00:02:51.429
这样我们可以使用一些参数优化技术

00:02:51.430 --> 00:02:53.560
比如 梯度下降 加上我们的回归测试集

00:02:53.560 --> 00:02:57.310
来用程序调整我们的成本函数

00:02:57.310 --> 00:03:00.090
最后 通过车辆状态来思考问题也很有用

00:03:00.090 --> 00:03:02.064
我们能用来间接控制车辆的参数有

00:03:02.064 --> 00:03:05.710
位置 速度 加速度等

00:03:05.710 --> 00:03:10.170
构造成本函数时候 脑子里想着这些东西会很有帮助

00:03:10.169 --> 00:03:11.979
我们来看一个例子

00:03:11.979 --> 00:03:16.927
假设我们想要考虑以下类型的成本函数

00:03:16.927 --> 00:03:18.044
为了让我们的思考

00:03:18.044 --> 00:03:19.549
容易和直观一点

00:03:19.550 --> 00:03:25.207
我们就来考虑位置 速度 和加速度

00:03:25.206 --> 00:03:27.750
“是否超速”就是一个二态问题

00:03:27.750 --> 00:03:30.096
对应的成本函数在这里

00:03:30.096 --> 00:03:34.004
然后 让我们保持速度接近限制值的成本函数在这里

00:03:34.004 --> 00:03:38.069
现在 我们不用之前看起来比较怪异的不连续图形

00:03:38.069 --> 00:03:41.044
这次的图形是像这样的抛物线

00:03:41.044 --> 00:03:45.044
这里 尽管这个点的成本是低的 但是需要超过限速

00:03:45.044 --> 00:03:49.799
那也没什么问题 因为我们的二元成本函数将阻止它

00:03:49.800 --> 00:03:51.735
我们来继续思考速度

00:03:51.735 --> 00:03:54.210
我们试图在某个速度上行驶

00:03:54.210 --> 00:03:57.060
这个速度接近所有车辆的平均速度

00:03:57.060 --> 00:04:01.826
安全起见 哪怕这个速度比限速稍高或者略低

00:04:01.826 --> 00:04:03.974
然后这个成本函数将会在这里定义

00:04:03.974 --> 00:04:05.444
在位置栏这里

00:04:05.444 --> 00:04:09.329
显然 我们这里有个可行性考虑 那就是碰撞避免

00:04:09.330 --> 00:04:12.330
我们不能行驶到另一辆车的位置上

00:04:12.330 --> 00:04:14.340
然后 基于安全原因

00:04:14.340 --> 00:04:15.719
我们还要考虑缓冲距离

00:04:15.719 --> 00:04:18.149
我们想离别的车辆远点

00:04:18.149 --> 00:04:21.089
这里的成本函数将检测是否我们行驶在靠近道路中线的位置上

00:04:21.089 --> 00:04:25.369
并且 行驶车道是否靠近我们的目标车道

00:04:25.370 --> 00:04:29.350
对于加速度 我们首先考虑

00:04:29.350 --> 00:04:33.472
加速度的可行性

00:04:33.471 --> 00:04:36.849
其次 我们会尽量避免加速度的突然改变

00:04:36.850 --> 00:04:41.350
因为那会降低舒适性

00:04:41.350 --> 00:04:46.235
加速度突变也被称为 Jerk 大家会在下一个课程里详细了解它

00:04:46.235 --> 00:04:48.910
例如 我们来考虑车辆进入高速路的场景

00:04:48.910 --> 00:04:51.550
这里可能存在潜在危险 所以我们特别希望

00:04:51.550 --> 00:04:54.737
尽快加速到道路车辆的平均速度上

00:04:54.737 --> 00:04:58.485
所以此时这个成本函数也许变得比平时更加有意义 

00:04:58.485 --> 00:05:01.840
但是 我们也想确保 如果没有空档 我们会等待机会

00:05:01.839 --> 00:05:06.699
所以我们想要确保 这个成本函数在效率方面具有更高权重

00:05:06.699 --> 00:05:12.329
我们可以把这些进入高速时的优先级同别的场景进行对比

00:05:12.329 --> 00:05:17.629
比如 一辆车行驶近绿灯时 灯突然变黄

00:05:17.629 --> 00:05:21.790
在这种情况下 我们可能想要加大合规性的权重 

00:05:21.790 --> 00:05:24.685
并可能需要增加一个全新的成本函数

00:05:24.685 --> 00:05:28.420
以顺应交通法规

00:05:28.420 --> 00:05:31.750
现在 那个成本函数不属于我们目前的

00:05:31.750 --> 00:05:34.637
位置 速度 和加速度分类中

00:05:34.637 --> 00:05:36.610
所以我只是将它放在这里

00:05:36.610 --> 00:05:42.870
如果我们讨论的东西让你感觉有些复杂 那么 你的感觉非常正常

00:05:42.870 --> 00:05:47.819
当使用有限状态机的时候 要避免这些复杂性是相当困难的 

00:05:47.819 --> 00:05:50.569
特别是 当原因是因为有限状态机本身的特性导致的时候

00:05:50.569 --> 00:05:53.189
但是 我们还是试图解决这种特别棘手的难题

00:05:53.189 --> 00:05:57.219
但是 无论使用何种方法 有些复杂性确实是无法避免的 

