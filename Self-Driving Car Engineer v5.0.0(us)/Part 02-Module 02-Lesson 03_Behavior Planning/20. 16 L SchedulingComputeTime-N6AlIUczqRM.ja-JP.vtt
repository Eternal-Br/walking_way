WEBVTT
Kind: captions
Language: ja-JP

00:00:00.000 --> 00:00:04.035
レッスンの最初で既にこの図をご覧いただいてると思います

00:00:04.035 --> 00:00:07.620
今では トラジェクトリーモジュールなどに比べて動作モジュールがあまり更新されない理由が

00:00:07.620 --> 00:00:12.554
お分かりいただけるかもしれません

00:00:12.554 --> 00:00:15.570
これは ハイレベルな決定を動作モジュールで行い もっと時間がかかり

00:00:15.570 --> 00:00:20.954
頻繁に変更しないことが理由です

00:00:20.954 --> 00:00:23.969
しかしトラジェクトリーモジュールは未だ私たちの決定を頼りにしており

00:00:23.969 --> 00:00:27.989
動作プランナーなどの比較的遅いモジュールが

00:00:27.989 --> 00:00:31.439
他のより速いコンポーネントの適切な機能を詰まらせることを

00:00:31.440 --> 00:00:37.125
システムアーキテクチャ全体が考慮していないことが問題です

00:00:37.125 --> 00:00:40.280
問題のスケジューリングとして知っていること 自動運転車では

00:00:40.280 --> 00:00:44.859
どのように取り扱われるかについてお話ししましょう

00:00:44.859 --> 00:00:50.769
この図では 動作モジュールの 2 つの処理サイクル中に何が起こるのかを示しています

00:00:50.770 --> 00:00:55.585
見てお分かりのとおり 予測モジュールは動作モジュールに比べ 高頻度で更新されます

00:00:55.585 --> 00:00:58.570
トラジェクトリーモジュールはそれ以上ですといった具合にです

00:00:58.570 --> 00:01:05.125
でも 動作がその最初のサイクルを完了したあと 何が起こるのかに注目してください

00:01:05.125 --> 00:01:07.224
その 2 番目のサイクルを開始するには

00:01:07.224 --> 00:01:11.304
動作モジュールは予測およびローカライゼーションからデータが必要です

00:01:11.305 --> 00:01:15.160
ローカライゼーションの場合 この例では 新しいデータがあり

00:01:15.159 --> 00:01:19.884
動作はそれだけを使えるので 理論上では簡単です

00:01:19.885 --> 00:01:22.270
でも 予測の場合はどうでしょう

00:01:22.269 --> 00:01:26.019
この例では それは実際更新サイクル中です

00:01:26.019 --> 00:01:29.685
動作は予測が完了するまで待っているべきでしょうか?

00:01:29.685 --> 00:01:35.155
いいえ 待ち始めると 終了しているコンポーネントのパイプラインを遮断してしまいます

00:01:35.155 --> 00:01:40.420
答えは ここからデータを使用して少し古くなってしまうことを許容するです

00:01:40.420 --> 00:01:43.314
最後のプロジェクトのハーフプランナーを実装するとき

00:01:43.314 --> 00:01:46.509
このすべてを扱うコードを提供します

00:01:46.510 --> 00:01:50.000
でも どのように行われるか説明することに越したことはありません

