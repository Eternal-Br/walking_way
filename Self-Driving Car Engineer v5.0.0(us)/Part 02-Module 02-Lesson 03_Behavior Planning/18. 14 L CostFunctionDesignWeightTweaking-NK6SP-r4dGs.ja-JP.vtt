WEBVTT
Kind: captions
Language: ja-JP

00:00:00.000 --> 00:00:03.009
コスト関数を設計することは難しく

00:00:03.009 --> 00:00:06.945
 また合理的な自動車の動作を生成するために 全部を連携させることは難しいです

00:00:06.945 --> 00:00:09.990
コスト関数の設計に関連したいくつかの難しい点は 古い問題を解決せずに

00:00:09.990 --> 00:00:13.775
新しい問題を解決することも含まれます

00:00:13.775 --> 00:00:15.810
自動運転車で作業をしているとき

00:00:15.810 --> 00:00:18.179
一部の特定の状況を除いて

00:00:18.179 --> 00:00:21.050
自動車はとても合理的に動作していると思うかもしれません

00:00:21.050 --> 00:00:25.019
信号で左に曲がるには 積極的でなさすぎるのかもしれません

00:00:25.019 --> 00:00:27.254
この問題を解決するために

00:00:27.254 --> 00:00:28.875
新しいコスト関数を追加する

00:00:28.875 --> 00:00:31.815
既にあるものを微調整する または重みを変更するのいずれかを行います

00:00:31.815 --> 00:00:33.134
でもそれを行うといつも

00:00:33.134 --> 00:00:34.649
既にうまくいっているところで

00:00:34.649 --> 00:00:37.140
別の問題が出てくる可能性があります

00:00:37.140 --> 00:00:41.505
実際に 予期したように動作している状況セットを

00:00:41.505 --> 00:00:43.980
いくつか設定した回帰テストを使って

00:00:43.979 --> 00:00:46.944
解決します

00:00:46.945 --> 00:00:49.005
変更するといつでも

00:00:49.005 --> 00:00:50.880
今までのすべてのテストケースで自動車をシミュレートし

00:00:50.880 --> 00:00:55.455
予期したように動作するようにします

00:00:55.454 --> 00:00:57.734
ここでは テストについてはこれ以上話しませんが

00:00:57.734 --> 00:01:03.174
セーフティクリティカルなアプリケーションでのソフトウェアの開発においては重要な部分です

00:01:03.174 --> 00:01:08.179
次の難しい点は 極端に異なる高さのコストを均等にすることです

00:01:08.180 --> 00:01:11.460
というのは もちろん目的地に効率的にたどり着きたいですが

00:01:11.459 --> 00:01:14.354
安全面で問題がある場合は

00:01:14.355 --> 00:01:18.305
その問題を解決することを考え 効率的かどうかは全く考慮しません

00:01:18.305 --> 00:01:20.880
これを行うには コスト関数が揚げている問題のタイプを

00:01:20.879 --> 00:01:24.049
反映する重みをもつことです

00:01:24.049 --> 00:01:25.875
物理学的に

00:01:25.875 --> 00:01:29.185
絶対可能ではない動作を極力不利にして

00:01:29.185 --> 00:01:32.640
安全性 適正 快適さについて考えようとします

00:01:32.640 --> 00:01:36.079
それらがクリアになってから 効率について考えます

00:01:36.079 --> 00:01:37.679
でも 状況によりこれらの重みの関連する重要性を調整することを考えます

00:01:41.049 --> 00:01:42.929
たとえば 信号が赤になると

00:01:42.930 --> 00:01:45.490
通常の高速道路の運転で考えるときよりも

00:01:45.489 --> 00:01:48.384
適正についてもっと考えることになります

00:01:48.385 --> 00:01:51.225
そして これが 個々のコスト関数について論理的に考えるという

00:01:51.224 --> 00:01:54.609
最後の難しい点につながっていきます

00:01:54.609 --> 00:01:59.400
理想的には、それぞれのコスト関数は固有の役割を果たします	

00:01:59.400 --> 00:02:04.890
これは速度コスト関数の最初のころの例ではしてなかったことです

00:02:04.890 --> 00:02:08.460
早く運転するために 要望を均等化しようとしていました

00:02:08.460 --> 00:02:10.125
それは 法律を厳守した速度制限を超えないということを考えながら

00:02:10.125 --> 00:02:14.810
効率を意識して行う必要があります

00:02:14.810 --> 00:02:16.920
実際 自動車速度に関連するコスト関数を

00:02:16.919 --> 00:02:21.099
いくつか定義しようと考えるかもしれません

00:02:21.099 --> 00:02:25.659
その場合 法定速度を超えてないかをチェックするだけの

00:02:25.659 --> 00:02:27.969
バイナリコスト関数と

00:02:27.969 --> 00:02:31.060
目標速度に向けて加速させる継続コスト関数があるかもしれません

00:02:31.060 --> 00:02:34.465
安全性 適正 効率性などの非常に特有の役割を

00:02:34.465 --> 00:02:38.444
それぞれのコスト関数を割り当てることで

00:02:38.444 --> 00:02:45.204
すべてのコスト関数の出力を -1 ～ 1 に標準化できます

00:02:45.205 --> 00:02:48.260
さらに いつでも可能な時にパラメーター化することに役立ちます

00:02:48.259 --> 00:02:51.429
これで 回帰テスト一式と併せた勾配降下法のような

00:02:51.430 --> 00:02:53.560
いくつかのパラメーター最適化テクニックを使用して

00:02:53.560 --> 00:02:57.310
プログラムでコスト関数を微調整できます

00:02:57.310 --> 00:03:00.090
最終的に 自動車の状態の面においては役立ちます

00:03:00.090 --> 00:03:02.064
車両に関して間接的に制御できることは

00:03:02.064 --> 00:03:05.710
その位置 速度 および加速度です

00:03:05.710 --> 00:03:10.170
コスト関数について考えるとき これらを頭に置いておくと役立ちます

00:03:10.169 --> 00:03:11.979
例を見てみましょう

00:03:11.979 --> 00:03:16.927
コスト関数の次のクラスについて考えてみます

00:03:16.927 --> 00:03:18.044
また簡単にするために

00:03:18.044 --> 00:03:19.549
すべてはっきりしておくために

00:03:19.550 --> 00:03:25.207
位置 速度 加速度について考えてみましょう

00:03:25.206 --> 00:03:27.750
バイナリ 「速度を超えていますか? 」

00:03:27.750 --> 00:03:30.096
コスト関数がここにきて

00:03:30.096 --> 00:03:34.004
速度制限内に収まるようにしておくためのコスト関数はここにきます

00:03:34.004 --> 00:03:38.069
また 前に作成したへんなうまくつながってないグラフではなく

00:03:38.069 --> 00:03:41.044
このような放物線になります

00:03:41.044 --> 00:03:45.044
速度制限を超える速度のこのコストが低くても

00:03:45.044 --> 00:03:49.799
そのような動作を予防するバイナリコスト関数があるので それは大丈夫です

00:03:49.800 --> 00:03:51.735
速度について引き続き考えていきます

00:03:51.735 --> 00:03:54.210
安全面のことを考えて 交通量の平均速度が制限速度より遅い

00:03:54.210 --> 00:03:57.060
または速い場合でも その平均速度で走行したいと

00:03:57.060 --> 00:04:01.826
考えることもあると思います

00:04:01.826 --> 00:04:03.974
それはここで行います

00:04:03.974 --> 00:04:05.444
位置カラムで

00:04:05.444 --> 00:04:09.329
絶対に起こりうる心配があります それは衝突の回避です

00:04:09.330 --> 00:04:12.330
既に車があるところでは 走行できません

00:04:12.330 --> 00:04:14.340
安全面の理由から

00:04:14.340 --> 00:04:15.719
バッファ距離を確保したいです

00:04:15.719 --> 00:04:18.149
それによりほかの自動車と十分な距離を保とうとします

00:04:18.149 --> 00:04:21.089
また必ず車線の真ん中に近い道路で

00:04:21.089 --> 00:04:25.369
ゴールの車線に近い車線を走行しているかどうかをチェックするするコスト関数が必要です

00:04:25.370 --> 00:04:29.350
加速については

00:04:29.350 --> 00:04:33.472
まず車が実行できる動作のみを考慮し

00:04:33.471 --> 00:04:36.849
そのうえで加速が急変化するのを

00:04:36.850 --> 00:04:41.350
避けようとします

00:04:41.350 --> 00:04:46.235
これについては 次のレッスン詳しく学習する jerk とし知られています

00:04:46.235 --> 00:04:48.910
たとえば高速道路での合流を考えてみましょう

00:04:48.910 --> 00:04:51.550
これはできるだけ早く交通速度に上げる必要がある、

00:04:51.550 --> 00:04:54.737
潜在的に危険な状況です

00:04:54.737 --> 00:04:58.485
よって そのため、このコスト関数は通常以上により重要な要素になる可能性があります

00:04:58.485 --> 00:05:01.840
しかし 必ず十分な車間距離がない場合は速度を落とすようにします

00:05:01.839 --> 00:05:06.699
そのため このコスト関数とこれが十分に高くなっているか測定します

00:05:06.699 --> 00:05:12.329
また これらの合流の優先度を、異なる状況と比較することができます

00:05:12.329 --> 00:05:17.629
たとえば 車が青信号に近づいてるときに 突然黄色に変わったとします

00:05:17.629 --> 00:05:21.790
この状況では 合法に関する重みを上げて

00:05:21.790 --> 00:05:24.685
交通規則に従うために まったく新しいコスト関数を

00:05:24.685 --> 00:05:28.420
追加する必要があると思います

00:05:28.420 --> 00:05:31.750
それはうまくその位置

00:05:31.750 --> 00:05:34.637
速度 または加速クラスに収まりません

00:05:34.637 --> 00:05:36.610
そのため ここにおいておきます

00:05:36.610 --> 00:05:42.870
これが複雑だと感じさせるようであれば それは正しいです

00:05:42.870 --> 00:05:47.819
 finite state machines を使用している場合は この展開される複雑さを回避することはとても難しいです

00:05:47.819 --> 00:05:50.569
finite state machine それ自身の一部であるからです

00:05:50.569 --> 00:05:53.189
でも 非常に難しい問題を解決しようとしています

00:05:53.189 --> 00:05:57.219
また どのソリューションを使ったとしても 一部の複雑さは回避できません

