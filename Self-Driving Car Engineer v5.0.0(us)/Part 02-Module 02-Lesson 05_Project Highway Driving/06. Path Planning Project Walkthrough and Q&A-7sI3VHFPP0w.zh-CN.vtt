WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.740
大家好 我是 David Silver

00:00:03.740 --> 00:00:06.720
优达学城纳米学位无人驾驶车的团队主管

00:00:06.720 --> 00:00:09.880
大家好 我是 Aaron Brown

00:00:09.880 --> 00:00:12.440
负责内容开发 构建了本实战项目路径规划

00:00:12.440 --> 00:00:16.040
这也是我们今天要学习的主题

00:00:16.040 --> 00:00:19.395
没错 我们今天要学习路径规划

00:00:19.395 --> 00:00:21.160
这是第二学期的第一个实战项目

00:00:21.160 --> 00:00:26.090
并且是无人驾驶车路径规划模块的唯一一个实战项目

00:00:26.090 --> 00:00:28.220
好的 我们开始吧

00:00:28.220 --> 00:00:30.290
Aaron 是你开发的这个项目

00:00:30.290 --> 00:00:31.615
我从哪里开始讲呢？

00:00:31.615 --> 00:00:33.830
从教室开始可以吗？

00:00:33.830 --> 00:00:38.859
好的 我们从搜索项目存储库开始

00:00:38.859 --> 00:00:42.030
没问题

00:00:42.030 --> 00:00:43.173
Windisk

00:00:43.173 --> 00:00:50.320
优达学城路径规划实战项目 可以在谷歌上搜索到吧？

00:00:50.320 --> 00:00:51.340
是的 点击第一个

00:00:51.340 --> 00:00:52.140
点击第一个

00:00:52.140 --> 00:00:55.480
很好

00:00:55.480 --> 00:00:57.020
这里有所有代码

00:00:57.020 --> 00:01:01.110
包括可以下载模拟器的链接

00:01:01.110 --> 00:01:03.495
让我们看看

00:01:03.495 --> 00:01:05.815
我已经下载了模拟器

00:01:05.815 --> 00:01:08.480
好的

00:01:08.480 --> 00:01:09.717
那么下一步进行什么呢？

00:01:09.717 --> 00:01:12.830
我们可以把这个库克隆过来

00:01:12.830 --> 00:01:13.711
好的

00:01:13.711 --> 00:01:17.175
现在开始为路径规划器建立一些代码

00:01:17.175 --> 00:01:20.080
好的 克隆库

00:01:20.080 --> 00:01:21.320
我已经克隆好了

00:01:21.320 --> 00:01:26.045
就在我的终端里

00:01:26.045 --> 00:01:31.545
现在来到 CarND 路径规划项目目录中

00:01:31.545 --> 00:01:32.770
实际上 是源代码

00:01:32.770 --> 00:01:34.400
就在这个实战项目的子目录里

00:01:34.400 --> 00:01:35.030
好的

00:01:35.030 --> 00:01:36.656
下一步呢？

00:01:36.656 --> 00:01:42.071
在源代码中 所有的 main 代码都来自 main.cpp

00:01:42.071 --> 00:01:42.525
好的

00:01:42.525 --> 00:01:44.930
Read Me 里也有一些指令

00:01:44.930 --> 00:01:47.480
先开始吧

00:01:47.480 --> 00:01:53.217
当你从模拟器来到 C++ 代码 你需要考虑什么呢

00:01:53.217 --> 00:01:56.740
好的 我们谈到了克隆库

00:01:56.740 --> 00:02:01.250
怎么建立库 以及如何运行

00:02:01.250 --> 00:02:02.390
是啊

00:02:02.390 --> 00:02:04.850
不过要确认的是

00:02:04.850 --> 00:02:08.300
我还正在

00:02:08.300 --> 00:02:09.410
初始状态

00:02:09.410 --> 00:02:13.395
我将从库里搜索 main.cpp 来到这里

00:02:13.395 --> 00:02:16.790
我已经运行了 CMake

00:02:16.790 --> 00:02:19.160
现在 我只是想让这个项目

00:02:19.160 --> 00:02:20.510
确保能够编译

00:02:20.510 --> 00:02:21.740
确保能够编译

00:02:21.740 --> 00:02:24.340
我将运行二进制文件

00:02:24.340 --> 00:02:26.440
好的 正在运行路径规划二进制文件

00:02:26.440 --> 00:02:29.870
结束翻页 运行模拟器

00:02:29.870 --> 00:02:29.871
是啊

00:02:29.871 --> 00:02:31.220
接下来呢？

00:02:31.220 --> 00:02:33.095
那辆车就在这里

00:02:33.095 --> 00:02:35.450
有一个 xy 点的空列表

00:02:35.450 --> 00:02:36.720
有点让人失望

00:02:36.720 --> 00:02:39.575
是啊 所以 我们需要对路径规划器添加一些 xy 点

00:02:39.575 --> 00:02:43.065
那么如何进行呢？

00:02:43.065 --> 00:02:45.460
我们需要去教室吗？还是需要做一些其他的？

00:02:45.460 --> 00:02:49.892
让我们打开 main.cpp

00:02:49.892 --> 00:02:52.896
最初打开时

00:02:52.896 --> 00:02:56.896
会看到一些我们可以使用的辅助函数

00:02:56.896 --> 00:02:59.790
我们来研究一下这些函数

00:02:59.790 --> 00:03:05.275
好的

00:03:05.275 --> 00:03:07.900
有一个 hasData 辅助函数

00:03:07.900 --> 00:03:09.280
我们需要这个辅助函数吗？

00:03:09.280 --> 00:03:11.891
这实际上是 uWebSocket 模板中的

00:03:11.891 --> 00:03:15.220
我们在其他实战项目中见过

00:03:15.220 --> 00:03:16.070
好的

00:03:16.070 --> 00:03:17.260
这个项目有距离

00:03:17.260 --> 00:03:18.580
所以这个函数很有用

00:03:18.580 --> 00:03:21.240
所以就是计算两点间的欧几里得距离

00:03:21.240 --> 00:03:23.998
这个实战项目要用到大量几何运算

00:03:23.998 --> 00:03:24.157
好的

00:03:24.157 --> 00:03:25.690
最近的导航点

00:03:25.690 --> 00:03:29.046
高速公路周围有所有这些导航点的映射

00:03:29.046 --> 00:03:29.185
好的

00:03:29.185 --> 00:03:30.958
可以看到哪个点距离我们最近

00:03:30.958 --> 00:03:31.109
好的

00:03:31.109 --> 00:03:33.368
以及哪个点是下一个导航点

00:03:33.368 --> 00:03:35.680
最近的导航点和下一个导航点之间的距离是多少？

00:03:35.680 --> 00:03:39.505
因为你就在一个导航点的正前面

00:03:39.505 --> 00:03:44.350
并且你所处的角度告诉你 你想去这个更远的点

00:03:44.350 --> 00:03:46.930
而不是距离你更近却在后面的点

00:03:46.930 --> 00:03:50.140
明白 就像在飞机上 距离你最近 却在你后面的出口

00:03:50.140 --> 00:03:50.598
是啊

00:03:50.598 --> 00:03:52.535
明白

00:03:52.535 --> 00:03:54.833
我们来看看

00:03:54.833 --> 00:03:55.716
GetFrenet

00:03:55.716 --> 00:03:59.200
因此 在路径规划课程中

00:03:59.200 --> 00:04:01.900
我们谈到了大量的 Fermi-Frenet 坐标点

00:04:01.900 --> 00:04:05.105
这些点在高速公路上尤其有用

00:04:05.105 --> 00:04:09.850
所以 我们有从 frenet 坐标到 xy 坐标的这些变换

00:04:09.850 --> 00:04:11.305
明白 这里的参数是什么呢？

00:04:11.305 --> 00:04:12.986
有五个参数 都是什么呢？

00:04:12.986 --> 00:04:16.395
包括你想要的 x 和 y

00:04:16.395 --> 00:04:19.240
我们还有数据 因为这有助于进行转换

00:04:19.240 --> 00:04:22.225
如果你查看地图

00:04:22.225 --> 00:04:25.780
此外 还有最开始计算的 x 和 y

00:04:25.780 --> 00:04:30.180
坐标点的列表

00:04:30.180 --> 00:04:37.210
明白 那么哪些是我们需要担心的 哪些又是我们

00:04:37.210 --> 00:04:40.400
不用思考太多就能进入的呢？

00:04:40.400 --> 00:04:41.290
Xy 和 θ

00:04:41.290 --> 00:04:41.465
好的

00:04:41.465 --> 00:04:45.835
基本上 只需要使用

00:04:45.835 --> 00:04:50.720
我们在一开始计算得到的 x 和 y

00:04:50.720 --> 00:04:51.598
好的

00:04:51.598 --> 00:04:54.829
从一个文件来到一个映射

00:04:54.829 --> 00:04:57.430
那么我们是否需要考虑

00:04:57.430 --> 00:05:00.345
getFrenet  内部发生了什么 或者我们只是将其

00:05:00.345 --> 00:05:01.645
看成一个黑匣子？

00:05:01.645 --> 00:05:03.370
你可以看做一个黑匣子

00:05:03.370 --> 00:05:06.395
不过这个代码就在这里 你实际上可以修改

00:05:06.395 --> 00:05:09.025
甚至可以改善

00:05:09.025 --> 00:05:12.954
或许你对怎么变换有不同的想法

00:05:12.954 --> 00:05:13.076
好的

00:05:13.076 --> 00:05:15.040
自由度很大

00:05:15.040 --> 00:05:19.200
让我们看看

00:05:19.200 --> 00:05:22.544
我们得到了 getFrenet 和  getXY

00:05:22.544 --> 00:05:23.040
明白

00:05:23.040 --> 00:05:25.540
应该相反

00:05:25.540 --> 00:05:27.612
Frenet 和  xy 并不完全

00:05:27.612 --> 00:05:31.315
实际上 并不是一个线性变换

00:05:31.315 --> 00:05:34.960
明白 因此 不是赋值 x 和 y

00:05:34.960 --> 00:05:37.000
我们赋值 s 和 d 即 Frenet 坐标系

00:05:37.000 --> 00:05:38.215
不是赋值 θ

00:05:38.215 --> 00:05:42.170
我们赋值这个矢量图 s

00:05:42.170 --> 00:05:42.760
好的

00:05:42.760 --> 00:05:44.295
又看到了 x 和 y 映射

00:05:44.295 --> 00:05:46.450
我们需要考虑映射吗？这个映射只在开始处？

00:05:46.450 --> 00:05:49.620
是在开始处计算得到 可以直接使用

00:05:49.620 --> 00:05:53.140
只是为函数内部的映射使用

00:05:53.140 --> 00:05:55.055
明白 现在 我们来到 main 函数

00:05:55.055 --> 00:05:56.646
那些是辅助函数 这个是 main 函数

00:05:56.646 --> 00:05:56.673
是啊

00:05:56.673 --> 00:06:03.370
貌似这里有大量的变量

00:06:03.370 --> 00:06:04.810
还有几个常量

00:06:04.810 --> 00:06:06.500
还有 CSV 文件

00:06:06.500 --> 00:06:09.280
它看起来像是轨道的链接

00:06:09.280 --> 00:06:11.570
当你打包背景时可能会有所帮助

00:06:11.570 --> 00:06:12.985
好的

00:06:12.985 --> 00:06:16.210
我们继续吧 打开映射的文本文档

00:06:16.210 --> 00:06:19.750
并加载矢量 x

00:06:19.750 --> 00:06:22.525
y s dx 和 dy 的 doubles

00:06:22.525 --> 00:06:27.510
dx 和 dy 只是这个导航点的垂直分量

00:06:27.510 --> 00:06:30.579
明白 我们从哪里打开 CSV 文件呢？

00:06:30.579 --> 00:06:36.985
实际上它只是来自数据 称为 highwaymap.csv

00:06:36.985 --> 00:06:42.130
所以 我们正在使用 stringstream 来实际进行加载

00:06:42.130 --> 00:06:43.990
明白 完成了

00:06:43.990 --> 00:06:47.480
然后就可以在项目中直接使用了

00:06:47.480 --> 00:06:52.135
好的 所以现在

00:06:52.135 --> 00:06:53.618
有信息传递

00:06:53.618 --> 00:06:58.020
这里发生了什么？

00:06:58.020 --> 00:07:01.075
一旦我们得到了通常的 uWebSocket 模板

00:07:01.075 --> 00:07:03.610
就得到了定位数据

00:07:03.610 --> 00:07:04.017
好的

00:07:04.017 --> 00:07:06.875
所以 模拟器正在告诉我们

00:07:06.875 --> 00:07:11.380
汽车的 xy 和 sd Frenet 坐标的准确位置

00:07:11.380 --> 00:07:12.025
好的

00:07:12.025 --> 00:07:15.390
以及汽车的角度和速度

00:07:15.390 --> 00:07:17.204
好的

00:07:17.204 --> 00:07:18.955
就是这个

00:07:18.955 --> 00:07:22.360
如果事件等于遥测功能

00:07:22.360 --> 00:07:24.370
就是这个操作发生的空间吗？

00:07:24.370 --> 00:07:27.970
所以这是我们将要处理的变量

00:07:27.970 --> 00:07:32.290
从而决定我们如何创建工程点

00:07:32.290 --> 00:07:36.055
明白 因此这里有一堆变量需要定义

00:07:36.055 --> 00:07:39.393
一些 Json 的东西得到定义

00:07:39.393 --> 00:07:41.780
传感器融合也很重要

00:07:41.780 --> 00:07:43.435
所以 我们谈到了定位

00:07:43.435 --> 00:07:47.015
路上行驶的所有其他汽车也采用了传感器融合

00:07:47.015 --> 00:07:48.625
我们不想撞上其他车

00:07:48.625 --> 00:07:52.270
并且还想超过它们

00:07:52.270 --> 00:07:55.030
明白 这里是 TODO

00:07:55.030 --> 00:07:57.610
“定义一条由 (x,y) 坐标点组成的路径

00:07:57.610 --> 00:08:00.565
汽车将每 0.2 秒钟顺序经过“

00:08:00.565 --> 00:08:02.840
然后 在这个  TODO 下面

00:08:02.840 --> 00:08:07.960
我们得到了一些 Json 变量 看起来与 x 和 y 变量相同

00:08:07.960 --> 00:08:09.455
或者与 x 和 xy 变量相邻

00:08:09.455 --> 00:08:11.561
这就构成了我们的路径规划器

00:08:11.561 --> 00:08:11.575
明白

00:08:11.575 --> 00:08:13.680
x 和 y 坐标点

00:08:13.680 --> 00:08:15.210
为了使汽车向前行驶

00:08:15.210 --> 00:08:17.410
我们必须设置这些 x 变量

00:08:17.410 --> 00:08:20.160
以及 y 变量 因为现在我们正在声明

00:08:20.160 --> 00:08:22.055
接下来 我们正在应用

00:08:22.055 --> 00:08:24.333
因此 我们的汽车目前静止不动

00:08:24.333 --> 00:08:26.800
这些矢量里面没有变量

00:08:26.800 --> 00:08:27.970
所以汽车没法行驶

00:08:27.970 --> 00:08:29.087
没错

00:08:29.087 --> 00:08:30.860
那么如何使汽车行驶呢？

00:08:30.860 --> 00:08:34.940
教室里有一些初学者代码

00:08:34.940 --> 00:08:38.170
我希望你看到了 好的

00:08:38.170 --> 00:08:42.795
这是教室里出现的第一个概念

00:08:42.795 --> 00:08:45.420
还有一个 GIF

00:08:45.420 --> 00:08:47.815
谈到了 50 英里的时速限制

00:08:47.815 --> 00:08:50.553
就像在举例说明这种完美的控制器

00:08:50.553 --> 00:08:53.110
汽车恰好在你给的点上

00:08:53.110 --> 00:08:56.203
它的角度将与这些点保持一致

00:08:56.203 --> 00:08:57.280
明白 那有什么用呢？

00:08:57.280 --> 00:08:59.487
我只是想使汽车抵达某个目的地

00:08:59.487 --> 00:09:00.880
幸运的是

00:09:00.880 --> 00:09:02.490
只是六行代码

00:09:02.490 --> 00:09:04.240
是这六行代码吗？

00:09:04.240 --> 00:09:04.817
是的

00:09:04.817 --> 00:09:09.820
好的 我们输入这六行代码 看看结果

00:09:09.820 --> 00:09:11.500
继续并拷贝

00:09:11.500 --> 00:09:14.016
只需拷贝这些代码

00:09:14.016 --> 00:09:16.630
或许我会在这里输入这些代码

00:09:16.630 --> 00:09:22.600
或许只输入 END

00:09:22.600 --> 00:09:38.090
就可以使这些格式更好一些

00:09:38.090 --> 00:09:41.210
好的 那么发生了什么呢？

00:09:41.210 --> 00:09:43.340
有一个 double 称为距离增量

00:09:43.340 --> 00:09:45.630
我猜是 0.5 米

00:09:45.630 --> 00:09:49.910
就是这些坐标点将被分开的距离

00:09:49.910 --> 00:09:52.215
明白 不过为什么是 0.5 呢？

00:09:52.215 --> 00:09:54.770
是因为时速为 50 英里吗？

00:09:54.770 --> 00:09:58.335
是的 很接近  50 英里每小时

00:09:58.335 --> 00:10:01.875
明白 然后我们遍历循环 50 次？

00:10:01.875 --> 00:10:06.220
嗯 我们将在路径规划器中使用 50 点的恒定大小

00:10:06.220 --> 00:10:08.570
明白 因此 next_x_vals 矢量

00:10:08.570 --> 00:10:12.630
和 next_y_vals 矢量每个将包括 50 个数值

00:10:12.630 --> 00:10:16.160
因此 将这些矢量合并起来 总共为 50 个数值

00:10:16.160 --> 00:10:21.110
每次我们只是回推这个奇怪的计算

00:10:21.110 --> 00:10:26.590
(car_x+(dist_ inc*i)*cos(deg2rad(car_yaw) 这是什么呢？

00:10:26.590 --> 00:10:30.110
这个公式有一点复杂 因为我们的车有一定的角度

00:10:30.110 --> 00:10:32.955
我们将一直在这个角度上

00:10:32.955 --> 00:10:35.650
以恒定速度行驶在一条直线上

00:10:35.650 --> 00:10:36.310
明白

00:10:36.310 --> 00:10:39.920
恒定速度源自于我们使用距离增量的事实

00:10:39.920 --> 00:10:43.365
明白 如果我们建立并运行这个增量

00:10:43.365 --> 00:10:44.780
汽车将以直线行驶?

00:10:44.780 --> 00:10:45.160
是的

00:10:45.160 --> 00:10:46.430
你能保证吗？

00:10:46.430 --> 00:10:56.550
是的

00:10:56.550 --> 00:11:00.210
让我们看看运行结果 或许应该提前设置

00:11:00.210 --> 00:11:05.725
现在运行路径规划器

00:11:05.725 --> 00:11:06.150
是的

00:11:06.150 --> 00:11:06.356
直线 好棒

00:11:06.356 --> 00:11:09.800
不过我们看到弹起来一堆红色旗子 是吧？

00:11:09.800 --> 00:11:12.100
是的 我们穿过一棵树

00:11:12.100 --> 00:11:14.660
首先

00:11:14.660 --> 00:11:19.650
我们将立即以时速零公里的速度 一直行驶到时速为 50 公里

00:11:19.650 --> 00:11:21.770
这会造成很大的抖动

00:11:21.770 --> 00:11:25.675
好的 接下来怎么做呢？

00:11:25.675 --> 00:11:29.465
现在我们可以试试

00:11:29.465 --> 00:11:32.540
或者 就待在车道线里 这就很好

00:11:32.540 --> 00:11:33.830
待在车道线里很好

00:11:33.830 --> 00:11:36.770
让我们看看 我们可以用 Frenet 坐标吗？

00:11:36.770 --> 00:11:37.340
当然

00:11:37.340 --> 00:11:41.200
好的 我们正在创建

00:11:41.200 --> 00:11:46.440
得到了 50 个数值的概念列表

00:11:46.440 --> 00:11:48.200
在这个列表里

00:11:48.200 --> 00:11:49.955
不过这是 x y 坐标值

00:11:49.955 --> 00:11:53.120
相反 如果我们使用 s d 坐标值 会发生什么呢？

00:11:53.120 --> 00:11:58.845
好的 让我们试试

00:11:58.845 --> 00:12:05.055
并将 new_x_y  坐标值放进矢量中

00:12:05.055 --> 00:12:08.690
从而使我们继续沿着公路行驶 而非驶离公路路面

00:12:08.690 --> 00:12:13.230
如果我们想停留在车道线内 可以采用Frenet

00:12:13.230 --> 00:12:19.110
明白 因此我们可以采用 double next_s 就可以得到

00:12:19.110 --> 00:12:20.840
或者 double 抱歉

00:12:20.840 --> 00:12:23.290
我们可以从 cars_s 开始

00:12:23.290 --> 00:12:24.560
好的

00:12:24.560 --> 00:12:28.340
我们将进行 double getXY

00:12:28.340 --> 00:12:34.330
将在下一个测试后再运用 getXY

00:12:34.330 --> 00:12:35.130
明白

00:12:35.130 --> 00:12:40.460
getXY 实际上正在运用 next_s 和 next_d

00:12:40.460 --> 00:12:49.169
明白 因此我们将处理  car_s+i*dist_inc

00:12:49.169 --> 00:12:53.310
Car_s 得到了一个确定的

00:12:53.310 --> 00:12:55.560
S 坐标值和 Frenet 坐标值

00:12:55.560 --> 00:12:57.150
当我们遍历这个循环时

00:12:57.150 --> 00:13:01.390
我们希望每次都会推进另一个 dist_inc 对吧？

00:13:01.390 --> 00:13:05.430
是的 不过不是进行 i1 次 而是进行 i+1 次遍历

00:13:05.430 --> 00:13:05.431
为什么呢？

00:13:05.431 --> 00:13:08.955
否则 我们的第一点就是汽车所在的点

00:13:08.955 --> 00:13:10.730
汽车不会转换位置

00:13:10.730 --> 00:13:11.180
明白

00:13:11.180 --> 00:13:13.505
并且会静止不动

00:13:13.505 --> 00:13:17.203
好的 那么进行 i+1 次遍历

00:13:17.203 --> 00:13:19.320
好的

00:13:19.320 --> 00:13:23.400
现在 你打算怎么处理 next_d 呢？

00:13:23.400 --> 00:13:27.748
double next_d

00:13:27.748 --> 00:13:30.585
我们现在中间车道线

00:13:30.585 --> 00:13:32.532
如果我记得没错

00:13:32.532 --> 00:13:37.720
导航点是从道路中间的双黄线开始测量的

00:13:37.720 --> 00:13:41.310
那么 从导航点开始 有一个半车道线？

00:13:41.310 --> 00:13:42.480
没错

00:13:42.480 --> 00:13:47.440
我记得在教室里读到过 车道线 4 米宽

00:13:47.440 --> 00:13:52.880
因此 从导航点开始的一个半车道线的距离为

00:13:52.880 --> 00:13:56.120
1.5 倍乘以 4 米 等于 6 米

00:13:56.120 --> 00:13:56.180
是的

00:13:56.180 --> 00:13:58.290
好的 那么我将设置为 6

00:13:58.290 --> 00:14:00.440
这就是 Frenet 真正有用的地方

00:14:00.440 --> 00:14:04.890
如果我们只是想待在这个不变的车道线内 或者在 d_cons 中

00:14:04.890 --> 00:14:06.840
好的

00:14:06.840 --> 00:14:12.160
现在我们准备好创建矢量 x y

00:14:12.160 --> 00:14:12.670
明白

00:14:12.670 --> 00:14:15.330
getXY 函数将帮助我们

00:14:15.330 --> 00:14:15.810
明白

00:14:15.810 --> 00:14:17.705
因此可能是一个矢量

00:14:17.705 --> 00:14:18.955
让我回过去再看

00:14:18.955 --> 00:14:22.240
我貌似忘了矢量 getXY 函数的签名

00:14:22.240 --> 00:14:22.630
当然

00:14:22.630 --> 00:14:24.364
如果我们滚动鼠标

00:14:24.364 --> 00:14:29.970
向上查找 看到了 getXY

00:14:29.970 --> 00:14:31.717
好的 为 s

00:14:31.717 --> 00:14:32.910
d  maps_s

00:14:32.910 --> 00:14:36.865
Maps_x  maps_y 返回 doubles 的矢量

00:14:36.865 --> 00:14:38.720
我们已经看到了两个 doubles

00:14:38.720 --> 00:14:40.380
是的 只是你的 X 和 Y

00:14:40.380 --> 00:14:42.520
一个 X  一个 Y

00:14:42.520 --> 00:14:43.398
让我们进行吧

00:14:43.398 --> 00:14:54.080
或许可以得到

00:14:54.080 --> 00:15:02.690
Vector&amp;lt double&amp;gt xy = getXY

00:15:02.690 --> 00:15:11.630
将是next_s  next_d maps_s maps

00:15:11.630 --> 00:15:16.252
这个与 maps_s 完全不同

00:15:16.252 --> 00:15:17.930
你太狡猾了

00:15:17.930 --> 00:15:21.818
这是一个缩写

00:15:21.818 --> 00:15:24.150
因此 就在那里 map_waypoints_s

00:15:24.150 --> 00:15:25.940
我们来看看

00:15:25.940 --> 00:15:27.390
195 行

00:15:27.390 --> 00:15:30.020
只需要查找声明的地方

00:15:30.020 --> 00:15:32.343
因此 你声明了 map_waypoints_x

00:15:32.343 --> 00:15:36.940
Map_waypoints_y 和 map_waypoints_s

00:15:36.940 --> 00:15:40.340
这个函数正在使用缩写

00:15:40.340 --> 00:15:51.800
明白 那就是 map_waypoints_s

00:15:51.800 --> 00:16:01.742
Map_waypoints_y 和 map_waypoints_s

00:16:01.742 --> 00:16:06.420
好的 现在得到了 X 和 Y

00:16:06.420 --> 00:16:07.400
很好

00:16:07.400 --> 00:16:11.895
如果我只是放到这里 那么 next_x_vals

00:16:11.895 --> 00:16:16.725
将是 x y 的第一个组成部分

00:16:16.725 --> 00:16:23.280
将 x y 的第二个组成部分放到下一个 y_vals 矢量的 y 矢量中

00:16:23.280 --> 00:16:25.310
(xy[1])

00:16:25.310 --> 00:16:26.200
是的

00:16:26.200 --> 00:16:28.650
我们将保存这个

00:16:28.650 --> 00:16:30.493
到现在为止还挺好

00:16:30.493 --> 00:16:32.190
我觉得没问题

00:16:32.190 --> 00:16:39.480
真是急死我了

00:16:39.480 --> 00:16:41.190
别着急 先运行路径规划

00:16:41.190 --> 00:16:44.970
好的 让我们看看结果怎么样

00:16:44.970 --> 00:16:45.860
好的

00:16:45.860 --> 00:16:49.670
我们希望这次能停留在汽车车道线内

00:16:49.670 --> 00:16:51.050
确实在车道线内

00:16:51.050 --> 00:16:54.490
虽然还是红色 不过在车道线内

00:16:54.490 --> 00:16:57.135
让我们看看发生了什么

00:16:57.135 --> 00:17:01.273
要让汽车停留在车道线内 并不需要太多行代码

00:17:01.273 --> 00:17:05.400
不过确实对这些点的粗略表述

00:17:05.400 --> 00:17:07.040
我们在很大程度上依赖于

00:17:07.040 --> 00:17:14.075
Get_xy 函数 除了在这些边界外 这个函数运作很好

00:17:14.075 --> 00:17:23.345
我们的映射由这些稀疏的导航点组成 包括这些角落和线段

00:17:23.345 --> 00:17:26.900
在这些角落 这些点往往会变得一团糟

00:17:26.900 --> 00:17:30.250
这会导致一些加速度和混乱问题

00:17:30.250 --> 00:17:32.200
明白 貌似我们正违反了速度限制

00:17:32.200 --> 00:17:34.790
速度限制为 55 英里每小时

00:17:34.790 --> 00:17:38.015
因为我们仍然在使用 0.5

00:17:38.015 --> 00:17:40.650
或许可以通过使用 0.4 来更正

00:17:40.650 --> 00:17:42.890
让我们从这个开始 看看会发生什么

00:17:42.890 --> 00:17:45.410
我们还影响了公路上行驶的其他汽车

00:17:45.410 --> 00:17:48.300
你不是一个好司机

00:17:48.300 --> 00:17:52.834
让我们研究下

00:17:52.834 --> 00:18:01.320
如果只是将距离增量缩短到 0.3

00:18:01.320 --> 00:18:03.680
能解决我们的速度限制问题吗？

00:18:03.680 --> 00:18:08.285
将有助于平均速度

00:18:08.285 --> 00:18:10.190
应该低得多

00:18:10.190 --> 00:18:12.650
不过仍然存在一些情况

00:18:12.650 --> 00:18:15.530
因为这些点并非完全线性

00:18:15.530 --> 00:18:18.080
所以在这种转换中点可能会聚集起来

00:18:18.080 --> 00:18:22.645
并且它们的间距有点奇怪

00:18:22.645 --> 00:18:24.945
明白了 所以这个平均速度要低得多

00:18:24.945 --> 00:18:26.920
现在时速为 33 英里

00:18:26.920 --> 00:18:27.560
是的

00:18:27.560 --> 00:18:30.405
我们违反速度限制的情况并不是很频繁

00:18:30.405 --> 00:18:34.100
但是每隔一段时间 程序却警告我们正在违反速度限制

00:18:34.100 --> 00:18:38.385
是啊 我们可以在这些角落例子中看到

00:18:38.385 --> 00:18:40.535
貌似大多数情况下

00:18:40.535 --> 00:18:43.875
除了有这个边缘之外 所有间隔都很好

00:18:43.875 --> 00:18:48.636
明白 因此我们得到了在其车道线内 行驶速度很慢的汽车

00:18:48.636 --> 00:18:53.740
但有这样的拐点 突然之间汽车颠簸

00:18:53.740 --> 00:18:55.400
甚至违反速度限制

00:18:55.400 --> 00:18:59.120
我们需要做的是 清理这种障碍

00:18:59.120 --> 00:19:01.300
清理这种障碍

00:19:01.300 --> 00:19:03.020
那么具体如何进行呢？

00:19:03.020 --> 00:19:10.325
在轨迹生成课上 有一个关于抖动最小化的课程

00:19:10.325 --> 00:19:12.800
不过我是在教室中看到的

00:19:12.800 --> 00:19:14.720
你提到了样条函数相关的

00:19:14.720 --> 00:19:17.330
我们可以利用这个令人敬畏的样条函数库

00:19:17.330 --> 00:19:20.205
这与我们之前在MPC中使用

00:19:20.205 --> 00:19:23.000
适合通过导航点多项式的项目

00:19:23.000 --> 00:19:26.150
所做的不太相似

00:19:26.150 --> 00:19:26.930
好的

00:19:26.930 --> 00:19:29.330
相比多项式 样条函数有一些优点

00:19:29.330 --> 00:19:32.375
样条函数可以保证穿过所有点

00:19:32.375 --> 00:19:38.130
因为样条函数是多项式的分段函数

00:19:38.130 --> 00:19:43.300
明白 教室里有一些样条函数库

00:19:43.300 --> 00:19:45.620
我记得在大学里

00:19:45.620 --> 00:19:48.945
有一整堂课都在讲数值分析

00:19:48.945 --> 00:19:52.110
我记得有三分之一时间在讲样条函数

00:19:52.110 --> 00:19:52.940
好的

00:19:52.940 --> 00:19:56.120
计算多项式分段函数 即样条函数

00:19:56.120 --> 00:19:59.096
有各种奇怪方式

00:19:59.096 --> 00:20:02.875
他们有点像多项式拟合

00:20:02.875 --> 00:20:05.240
除了他们经历所有的点

00:20:05.240 --> 00:20:08.120
并且保证在这些点之间平滑过渡

00:20:08.120 --> 00:20:10.240
是的 一阶导数和二阶导数

00:20:10.240 --> 00:20:13.160
为何使用线条函数 而非多项式拟合呢？

00:20:13.160 --> 00:20:19.290
因为这里有一个库 可以更好地解决问题

00:20:19.290 --> 00:20:20.690
明白 因此有人写了这个代码

00:20:20.690 --> 00:20:23.990
我们将应用线条函数 而非多项式拟合

00:20:23.990 --> 00:20:24.860
单个的头文件

00:20:24.860 --> 00:20:26.065
来到单个的头文件

00:20:26.065 --> 00:20:29.425
所以这里是头文件 我们来下载

00:20:29.425 --> 00:20:32.110
我已经下载完成了

00:20:32.110 --> 00:20:37.037
来看一下源代码文件

00:20:37.037 --> 00:20:40.360
源代码 样条函数

00:20:40.360 --> 00:20:42.568
嗯 已经下载了

00:20:42.568 --> 00:20:45.690
所以如果我们来到这里

00:20:45.690 --> 00:20:51.470
需要将其添加到列表中

00:20:51.470 --> 00:20:53.730
嗯 添加到 spline.h 中

00:20:53.730 --> 00:20:55.128
明白

00:20:55.128 --> 00:20:57.870
不过你还可以进行多项式拟合

00:20:57.870 --> 00:21:01.230
创建路径规划器有很多种方式

00:21:01.230 --> 00:21:04.190
不过我喜欢别人给我写的代码

00:21:04.190 --> 00:21:05.970
是的 不错

00:21:05.970 --> 00:21:09.320
我们这里有  spines.h 文件吗？

00:21:09.320 --> 00:21:11.950
没有 你需要添加

00:21:11.950 --> 00:21:14.417
好的  #include

00:21:14.417 --> 00:21:17.611
你记得是 spine.h 还是 spines.h？

00:21:17.611 --> 00:21:20.888
我觉得是 spine.h

00:21:20.888 --> 00:21:33.110
Spine.h 好的 我不该清除 Bash 记录

00:21:33.110 --> 00:21:35.510
Ll_source_spline.h 因此现在我们已经添加了 spine.h

00:21:35.510 --> 00:21:40.475
我们需要将 spline.h 用于

00:21:40.475 --> 00:21:46.115
清除汽车在模拟器中遇到的不相交路径

00:21:46.115 --> 00:21:49.676
嗯 我很喜欢你的解决方案

00:21:49.676 --> 00:21:52.900
不过我想尝试其他方案

00:21:52.900 --> 00:21:54.000
你想尝试什么呢？

00:21:54.000 --> 00:21:58.150
我可能需要创建一些点

00:21:58.150 --> 00:22:01.130
只创建几个点 可能彼此相隔较远

00:22:01.130 --> 00:22:02.820
可能相隔 30 米

00:22:02.820 --> 00:22:05.480
然后利用样条函数进行拟合

00:22:05.480 --> 00:22:09.030
然后将某些点放进这个样条函数中

00:22:09.030 --> 00:22:11.340
明白

00:22:11.340 --> 00:22:13.340
好的 让我们试试

00:22:13.340 --> 00:22:17.110
我正好给你发了一些可以用的代码

00:22:17.110 --> 00:22:22.900
太好了 那让我切换到你的文件

00:22:22.900 --> 00:22:30.375
我记得存在了源代码库中 aaron.cpp

00:22:30.375 --> 00:22:41.390
我不记得为啥尝试 cd 搜索 aaron.cpp

00:22:41.390 --> 00:22:43.860
好的 我们把代码拷贝到 main 中

00:22:43.860 --> 00:22:45.908
现在 就有了这个 main cpp 文件

00:22:45.908 --> 00:22:49.840
我已经在 spline.h 中放了各种文件

00:22:49.840 --> 00:22:53.045
好的 你已经超过我了

00:22:53.045 --> 00:22:56.760
好的 让我们往下滚动鼠标键

00:22:56.760 --> 00:23:00.760
就可以展示正在进行的程序

00:23:00.760 --> 00:23:01.520
嗯 好主意

00:23:01.520 --> 00:23:04.570
或者可以搜索

00:23:04.570 --> 00:23:05.280
我们基本上找到了 int main

00:23:05.280 --> 00:23:06.960
就在这里

00:23:06.960 --> 00:23:08.670
非常接近了

00:23:08.670 --> 00:23:14.130
我们正在进行上次做的事情 并且收集了所有这些映射导航点

00:23:14.130 --> 00:23:15.823
我们来看看

00:23:15.823 --> 00:23:17.220
所以如果遥测

00:23:17.220 --> 00:23:19.620
然后你能够得到一些注释码

00:23:19.620 --> 00:23:21.135
我们回头再看

00:23:21.135 --> 00:23:22.440
好的

00:23:22.440 --> 00:23:25.965
好的 我们现在就让事情尽可能简单

00:23:25.965 --> 00:23:29.280
我们想让汽车做的就是在车道线内

00:23:29.280 --> 00:23:33.360
有恒定速度行驶 并且尽量平滑

00:23:33.360 --> 00:23:33.880
好的

00:23:33.880 --> 00:23:35.970
不要违反加速 造成抖动

00:23:35.970 --> 00:23:37.880
明白 那么你现在干嘛呢？

00:23:37.880 --> 00:23:42.530
为了开始

00:23:42.530 --> 00:23:46.430
我实际上要来到这里 定义两个变量

00:23:46.430 --> 00:23:47.450
好的

00:23:47.450 --> 00:23:49.805
这两个变量是我们的车道线

00:23:49.805 --> 00:23:52.165
我将从车道线一开始

00:23:52.165 --> 00:23:55.955
我可以使用这个 从而快速切换到其他车道线 如果有需要

00:23:55.955 --> 00:23:58.050
那么车道线零就在很靠左的车道线吧

00:23:58.050 --> 00:23:59.805
车道线一在中间 车道线二在右边？

00:23:59.805 --> 00:24:02.520
没错 下一步

00:24:02.520 --> 00:24:05.440
我还会提供一些参考速度

00:24:05.440 --> 00:24:08.965
就在这里 我只是想尽量接近速度限制

00:24:08.965 --> 00:24:12.300
我不想超过 50 所以我采用49.5

00:24:12.300 --> 00:24:13.825
好的

00:24:13.825 --> 00:24:19.360
一旦我来到这里 得到几个变量

00:24:19.360 --> 00:24:22.660
我将设置这个大小

00:24:22.660 --> 00:24:25.535
源自于前路径大小

00:24:25.535 --> 00:24:27.220
所以这里的前导航点列表

00:24:27.220 --> 00:24:30.580
在我进行转换时可以真正帮助我

00:24:30.580 --> 00:24:33.685
那么这就是汽车在实现这个计算更多点的特定运行之前

00:24:33.685 --> 00:24:38.260
经过的最后一条路径？

00:24:38.260 --> 00:24:42.400
是的 这个模拟器实际上将告诉我前一条路径是什么

00:24:42.400 --> 00:24:43.770
好的

00:24:43.770 --> 00:24:47.410
让我们向下滑动

00:24:47.410 --> 00:24:50.260
那么是不是因为路径通常为 50 点 所以采用 50 呢？

00:24:50.260 --> 00:24:53.415
你甚至可以采用 100 或 1,000

00:24:53.415 --> 00:24:58.330
实际上 你可以采用这个路径规划器创建你想要的任何点

00:24:58.330 --> 00:24:58.810
明白

00:24:58.810 --> 00:25:01.650
并且这样做喜忧参半

00:25:01.650 --> 00:25:02.000
好的

00:25:02.000 --> 00:25:06.030
如果就在 1,000  你正在应用这些点

00:25:06.030 --> 00:25:09.110
或许环境突然变化

00:25:09.110 --> 00:25:10.990
无法及时响应

00:25:10.990 --> 00:25:13.250
因为正卡在这里

00:25:13.250 --> 00:25:14.565
好的

00:25:14.565 --> 00:25:20.620
因此 我的意思是 我想采用这些间隔宽松的导航点

00:25:20.620 --> 00:25:25.525
我将创建这个矢量双列表 并在这里创建

00:25:25.525 --> 00:25:29.190
并且 我想追踪引用状态

00:25:29.190 --> 00:25:32.110
将在汽车的位置

00:25:32.110 --> 00:25:36.010
或者在前一个路径终点

00:25:36.010 --> 00:25:38.945
因此我定义这个引用状态为 x y 和 偏航角

00:25:38.945 --> 00:25:41.575
好的 x y 和 偏航角

00:25:41.575 --> 00:25:45.460
现在我要搞清楚前路径大小

00:25:45.460 --> 00:25:47.110
要么非常接近于空

00:25:47.110 --> 00:25:52.370
要么将有一些我可以利用的点

00:25:52.370 --> 00:25:53.650
如果非常接近于空

00:25:53.650 --> 00:25:55.730
那么我将采用汽车状态

00:25:55.730 --> 00:25:58.630
因此就在这里

00:25:58.630 --> 00:26:03.510
我想创建与汽车角度相切的一条路径

00:26:03.510 --> 00:26:08.290
因此 我将查看汽车的位置

00:26:08.290 --> 00:26:11.620
并且根据这个角度 及时往后追溯

00:26:11.620 --> 00:26:17.335
从而创建两个点 确保路径相切

00:26:17.335 --> 00:26:22.860
所以如果我刚刚开始 我没有任何前导航点

00:26:22.860 --> 00:26:25.000
如果我有一些前导航点

00:26:25.000 --> 00:26:29.140
我将采用相同的点

00:26:29.140 --> 00:26:34.180
确保通过使用前路经的最后一个点与之相切 并且是倒数第二个点

00:26:34.180 --> 00:26:37.775
我准备将这个点添加到 x 和 y 点上

00:26:37.775 --> 00:26:42.430
我还会将这个引用 x 和 y

00:26:42.430 --> 00:26:46.225
改为前路径的最后一部分 然后继续

00:26:46.225 --> 00:26:50.800
利用切线计算

00:26:50.800 --> 00:26:51.992
明白

00:26:51.992 --> 00:26:54.790
因此基本上说来 你正在查看的是

00:26:54.790 --> 00:27:00.940
汽车正追踪的前路径的最后几个点

00:27:00.940 --> 00:27:08.115
并采用这几个点计算汽车正在前进的角度

00:27:08.115 --> 00:27:08.237
是啊

00:27:08.237 --> 00:27:11.675
对吧？然后将这些点放到前列表中？

00:27:11.675 --> 00:27:15.940
是的 到目前 我已经放了两个 x 和两个 y

00:27:15.940 --> 00:27:21.630
好的 你有两个点 与这对矢量相关

00:27:21.630 --> 00:27:23.220
是的

00:27:23.220 --> 00:27:26.640
这是我的起始引用

00:27:26.640 --> 00:27:28.155
这是其他一些点

00:27:28.155 --> 00:27:30.570
因此我正在使用 Frenet

00:27:30.570 --> 00:27:32.863
这在之前已经做过

00:27:32.863 --> 00:27:36.025
不过我只是想确认它们相隔很远

00:27:36.025 --> 00:27:40.106
好的 与其说你正在看一个距离增量

00:27:40.106 --> 00:27:45.140
实际上你正在查看 30 60 90

00:27:45.140 --> 00:27:46.860
而不是循环并创建其中的50个

00:27:46.860 --> 00:27:48.830
你只需创建其中的三个？

00:27:48.830 --> 00:27:49.610
是的

00:27:49.610 --> 00:27:49.703
好的

00:27:49.703 --> 00:27:51.860
因此 我将放置另外三个点

00:27:51.860 --> 00:27:54.600
不过并不是相隔 0.5 米

00:27:54.600 --> 00:27:56.120
而是相隔 30 米

00:27:56.120 --> 00:28:01.468
明白 当我将六个点作为 d 坐标时 你有 2 加上 4 次车道线

00:28:01.468 --> 00:28:03.100
这是第一条车道线

00:28:03.100 --> 00:28:05.260
因此 2 加上 4  等于 6

00:28:05.260 --> 00:28:05.348
是啊

00:28:05.348 --> 00:28:07.915
不过如果你不断改变车道线变量 可以得到[听不清]

00:28:07.915 --> 00:28:09.660
也很有用

00:28:09.660 --> 00:28:10.695
好的

00:28:10.695 --> 00:28:14.350
继续放置多的点

00:28:14.350 --> 00:28:17.155
那么这是什么呢？这些矢量点都有什么？

00:28:17.155 --> 00:28:19.350
他们有两个前导航点 并且汽车的位置一般为 30 米

00:28:19.350 --> 00:28:25.690
60 米 90米

00:28:25.690 --> 00:28:26.190
是的

00:28:26.190 --> 00:28:28.590
现在已经有五个点了

00:28:28.590 --> 00:28:29.060
没错

00:28:29.060 --> 00:28:32.370
好的

00:28:32.370 --> 00:28:36.230
这些实际上非常有用

00:28:36.230 --> 00:28:42.180
并对这个本地汽车的坐标点进行转换

00:28:42.180 --> 00:28:44.965
这是我们已经在 MPC 中做过的

00:28:44.965 --> 00:28:48.395
我们改变 从而确保汽车或

00:28:48.395 --> 00:28:52.128
前路径的最后一个点位于零点

00:28:52.128 --> 00:28:56.020
即起始点 角度为零度

00:28:56.020 --> 00:28:57.830
稍后就起作用了

00:28:57.830 --> 00:28:59.480
和我一起等会儿吧

00:28:59.480 --> 00:29:01.245
一起等会儿 好的

00:29:01.245 --> 00:29:04.145
所以我们在想 如果汽车正在朝这个方向前进

00:29:04.145 --> 00:29:05.888
就像 xy 坐标

00:29:05.888 --> 00:29:09.020
如果我们可以改变 那么就方便查看汽车的参考坐标系

00:29:09.020 --> 00:29:12.000
所以它只是直行 而不是以45度

00:29:12.000 --> 00:29:15.750
也许它应该始终在零度

00:29:15.750 --> 00:29:17.350
让数学问题更容易处理

00:29:17.350 --> 00:29:19.270
让数学问题更容易处理 很好

00:29:19.270 --> 00:29:21.730
所以我们在这里进行变换

00:29:21.730 --> 00:29:23.330
改变旋转

00:29:23.330 --> 00:29:23.580
好的

00:29:23.580 --> 00:29:26.330
所以这是你可能从 MPC 认识的一些数学

00:29:26.330 --> 00:29:27.690
好的

00:29:27.690 --> 00:29:32.660
这是我们一直在构建的样条线

00:29:32.660 --> 00:29:34.000
回到这条样条线

00:29:34.000 --> 00:29:37.580
因此我定义了一条样条线 s

00:29:37.580 --> 00:29:41.570
然后 我为这条样条线简单地设置了某些 x 和 y 点

00:29:41.570 --> 00:29:41.770
好的

00:29:41.770 --> 00:29:46.400
实际上

00:29:46.400 --> 00:29:51.250
我正在建立上一次使用 xx 元音和 xy 元音时所处理的位置

00:29:51.250 --> 00:29:54.055
这些是路径规划器将要使用的实际点

00:29:54.055 --> 00:29:58.850
我们有这一组 x 和 y 点 现在又有另外一组空白点

00:29:58.850 --> 00:30:05.000
我们需要在其中构建未来路径

00:30:05.000 --> 00:30:08.395
所以我们现在把所有这些设置好

00:30:08.395 --> 00:30:12.020
我们已经大量谈到了前路径 这是它发挥作用的地方

00:30:12.020 --> 00:30:12.620
好的

00:30:12.620 --> 00:30:15.590
因此 如果前路径有任何点

00:30:15.590 --> 00:30:19.640
我就把这些点添加到路径规划器中

00:30:19.640 --> 00:30:19.835
明白

00:30:19.835 --> 00:30:21.905
这可以帮助过渡

00:30:21.905 --> 00:30:28.445
所以你要确保每一次从头开始重新创建路径

00:30:28.445 --> 00:30:33.710
为什么不只是在它上面添加点 并且使用你上次仍留下的点

00:30:33.710 --> 00:30:36.320
明白 因此如果前路径

00:30:36.320 --> 00:30:41.105
为 50 个点 我们在这里就会有50个点？

00:30:41.105 --> 00:30:44.270
是的 这就是正确的做法

00:30:44.270 --> 00:30:47.760
用 50 减去前路径 x 点的大小

00:30:47.760 --> 00:30:51.162
明白 是不是这个 50 减去前路径 x 点的大小总是等于零

00:30:51.162 --> 00:30:53.930
前路径 x 点大小为 50？

00:30:53.930 --> 00:30:58.735
前路径大小小于 50

00:30:58.735 --> 00:31:00.560
假设你正在进行遍历

00:31:00.560 --> 00:31:02.485
生成 50 个点

00:31:02.485 --> 00:31:05.105
或许这个模拟器会经过三个点

00:31:05.105 --> 00:31:09.757
因此你会剩下 47 个点 在下次会报告

00:31:09.757 --> 00:31:11.300
因此 现在是 47

00:31:11.300 --> 00:31:16.700
前路径 x 点或前路径 x 不是完整的前路径

00:31:16.700 --> 00:31:18.725
这是前路径中没有被汽车

00:31:18.725 --> 00:31:23.020
消耗掉的点

00:31:23.020 --> 00:31:23.810
没错

00:31:23.810 --> 00:31:27.320
因此如果汽车消耗了上次 50 个导航点中的三个点

00:31:27.320 --> 00:31:30.160
那么前路径将有 47 个剩余点

00:31:30.160 --> 00:31:32.090
因此我们只需要创建三个点

00:31:32.090 --> 00:31:37.950
明白 如果汽车消耗掉 40 个点 那么前路径将只剩 10 个点

00:31:37.950 --> 00:31:38.440
没错

00:31:38.440 --> 00:31:39.760
好的

00:31:39.760 --> 00:31:41.140
好的

00:31:41.140 --> 00:31:47.290
所以我们添加前导航点

00:31:47.290 --> 00:31:51.370
这就是它变得有趣的地方

00:31:51.370 --> 00:31:57.650
继续将这些点添加到样条线中

00:31:57.650 --> 00:32:00.140
不过我想搞清楚

00:32:00.140 --> 00:32:04.770
如何将沿着样条线的这些点分开 从而得到期望速度

00:32:04.770 --> 00:32:06.950
等一下 你将这些点添加到样条线哪里？

00:32:06.950 --> 00:32:09.450
因此都添加到这里

00:32:09.450 --> 00:32:13.600
将 x 和 y 个点添加到 s

00:32:13.600 --> 00:32:17.030
因此这是另外五个点 而非前导航点

00:32:17.030 --> 00:32:20.915
没错 我们正在处理两套数据

00:32:20.915 --> 00:32:21.190
好的

00:32:21.190 --> 00:32:27.945
一套是彼此间隔较远 构成样条线的导航点数据

00:32:27.945 --> 00:32:30.760
另外一套是路径规划点数据

00:32:30.760 --> 00:32:34.365
我们将第一套数据称为锚点 从而使其保持直线

00:32:34.365 --> 00:32:39.160
而第二套数据就像下一个 x 文件 或者未来路径等等

00:32:39.160 --> 00:32:39.416
是啊

00:32:39.416 --> 00:32:41.930
因此你已经将锚点添加到样条线中

00:32:41.930 --> 00:32:44.010
貌似在这里的中间

00:32:44.010 --> 00:32:48.560
在未来路径上添加任何前路径剩余的点

00:32:48.560 --> 00:32:49.220
没错

00:32:49.220 --> 00:32:51.515
还有一些延续性

00:32:51.515 --> 00:32:55.870
现在我们再回来看看样条线和锚点 对吧？

00:32:55.870 --> 00:32:56.470
是的

00:32:56.470 --> 00:32:56.830
好的

00:32:56.830 --> 00:32:59.530
这将是提供一些视觉辅助的好时机

00:32:59.530 --> 00:33:01.480
好的 提供一些视觉辅助

00:33:01.480 --> 00:33:02.110
是的

00:33:02.110 --> 00:33:05.340
就像那种视觉辅助？

00:33:05.340 --> 00:33:06.280
没错

00:33:06.280 --> 00:33:08.230
好的 很棒 是你做的吗？

00:33:08.230 --> 00:33:13.002
是啊 如假包换

00:33:13.002 --> 00:33:17.260
这是本地坐标系统中的汽车

00:33:17.260 --> 00:33:17.780
好的

00:33:17.780 --> 00:33:20.100
你能看见在零度

00:33:20.100 --> 00:33:20.830
好的

00:33:20.830 --> 00:33:23.690
这就像我们拥有的样条线

00:33:23.690 --> 00:33:24.090
好的

00:33:24.090 --> 00:33:28.580
我希望得到的是 使这些点沿着样条线间隔开 并且以这样的方式间隔开

00:33:28.580 --> 00:33:33.705
从而使车辆以所需的速度前进

00:33:33.705 --> 00:33:36.530
明白

00:33:36.530 --> 00:33:38.625
如果汽车每小时行驶 50 英里或者 49.5 英里

00:33:38.625 --> 00:33:41.745
你需要这些点之间的距离恰到好处？

00:33:41.745 --> 00:33:42.410
没错

00:33:42.410 --> 00:33:44.690
好的 你不能直接查询吗？

00:33:44.690 --> 00:33:47.565
我需要做一些数学工作

00:33:47.565 --> 00:33:51.890
进行线性化

00:33:51.890 --> 00:33:53.160
结果很棒

00:33:53.160 --> 00:33:54.040
好的

00:33:54.040 --> 00:33:57.760
我想通过挑选一些水平线数值来进行

00:33:57.760 --> 00:33:59.130
假设 30 米

00:33:59.130 --> 00:33:59.660
好的

00:33:59.660 --> 00:34:03.765
从而搞清楚这个点在这条样条线上的位置

00:34:03.765 --> 00:34:08.755
因为我们有 s 函数 只是 f(x)

00:34:08.755 --> 00:34:12.225
给样条线赋值 x 返回一些 y

00:34:12.225 --> 00:34:18.470
只计算汽车到我设置的目标点之间的距离

00:34:18.470 --> 00:34:21.850
得到了这个 d 这就需要用到数学知识

00:34:21.850 --> 00:34:22.850
好的

00:34:22.850 --> 00:34:26.250
我想将其分为 N 段

00:34:26.250 --> 00:34:29.645
结果是这些 N 段乘以

00:34:29.645 --> 00:34:34.540
0.02 因为汽车将每隔 0.02 秒就会来到一个点

00:34:34.540 --> 00:34:35.100
好的

00:34:35.100 --> 00:34:39.035
再乘以速度 在这里是我的理想速度

00:34:39.035 --> 00:34:40.490
就等于 D

00:34:40.490 --> 00:34:41.330
好的

00:34:41.330 --> 00:34:44.170
因为时间单位为秒钟

00:34:44.170 --> 00:34:46.590
即每秒多少米

00:34:46.590 --> 00:34:49.310
去掉秒钟 就得到了距离的单位米

00:34:49.310 --> 00:34:52.130
在每个小段末尾 就得到多少米

00:34:52.130 --> 00:34:53.495
当我们拥有所有的目标时

00:34:53.495 --> 00:34:54.770
会得到全部的距离

00:34:54.770 --> 00:34:57.785
明白 这就是速度

00:34:57.785 --> 00:34:58.320
是的

00:34:58.320 --> 00:35:03.500
我没法搞清楚速度是什么 vel代表速度吗？

00:35:03.500 --> 00:35:06.110
好的 那么这里的收获是什么呢？

00:35:06.110 --> 00:35:10.115
收获就是当我们在做这件事情的时候

00:35:10.115 --> 00:35:12.695
我们可以计算 n 可以是什么

00:35:12.695 --> 00:35:16.055
由于这只是个三角形 结果就是

00:35:16.055 --> 00:35:19.160
因为这个斜边被分解为 n 段

00:35:19.160 --> 00:35:23.150
所以这个 x 轴也将被分解为 n 段

00:35:23.150 --> 00:35:23.300
好的

00:35:23.300 --> 00:35:26.585
一旦我们获得这些 x 值后

00:35:26.585 --> 00:35:28.280
我们可以告诉样条线

00:35:28.280 --> 00:35:30.380
”这个 x 值对应的 y 值是多少呢？“

00:35:30.380 --> 00:35:32.090
然后我们就得到了这些点

00:35:32.090 --> 00:35:33.799
所以你只需要告诉这些样条线

00:35:33.799 --> 00:35:35.300
”这是个 x 值

00:35:35.300 --> 00:35:38.715
你可以告诉我 这个 x 值所对应的 y 值吗？”

00:35:38.715 --> 00:35:39.440
没错

00:35:39.440 --> 00:35:39.790
明白

00:35:39.790 --> 00:35:41.810
然后我们就能知道需要多少个点

00:35:41.810 --> 00:35:44.720
沿着样条线有多少个 XY值

00:35:44.720 --> 00:35:46.800
那你可以通过代码展示吗？

00:35:46.800 --> 00:35:49.680
嗯 好主意

00:35:49.680 --> 00:35:50.294
好的

00:35:50.294 --> 00:35:52.605
我们正在编写代码

00:35:52.605 --> 00:35:55.940
这是水平线 为 30

00:35:55.940 --> 00:35:56.562
好的

00:35:56.562 --> 00:35:58.920
好的

00:35:58.920 --> 00:36:01.250
就像我说的那样 目标 y

00:36:01.250 --> 00:36:04.190
只是问样条线 给定的 x 对应的 y 值

00:36:04.190 --> 00:36:07.790
Aaron 这是 vm 你不用使用鼠标

00:36:07.790 --> 00:36:09.680
没错

00:36:09.680 --> 00:36:11.510
然后我们得到了这个目标距离

00:36:11.510 --> 00:36:15.770
这就是单纯地计算距离

00:36:15.770 --> 00:36:18.620
不论是否是前路径的最后一点

00:36:18.620 --> 00:36:21.680
还是这个目标对应的汽车本身

00:36:21.680 --> 00:36:21.920
好的

00:36:21.920 --> 00:36:25.795
我们有这个从零开始的 x 插件

00:36:25.795 --> 00:36:29.390
这与我们所做的两个本地变换有关

00:36:29.390 --> 00:36:30.680
我们在原点开始

00:36:30.680 --> 00:36:33.569
好的

00:36:33.569 --> 00:36:38.090
目标值 x 为 30 然后获得了 y 值

00:36:38.090 --> 00:36:41.990
我们已经声明了样条线 现在只需进行的是将目标值 x

00:36:41.990 --> 00:36:46.245
代入到样条线 s 因此在上面我们声明了样条线

00:36:46.245 --> 00:36:48.945
设置了锚点

00:36:48.945 --> 00:36:53.470
现在需要做的是 将 30 代入到 s 并返回 y 值

00:36:53.470 --> 00:36:56.040
利用这种样条线库非常简单

00:36:56.040 --> 00:36:58.740
我喜欢看别人写简单的代码

00:36:58.740 --> 00:37:03.920
所以现在我们已经添加了沿着样条线的这些点

00:37:03.920 --> 00:37:04.730
好的

00:37:04.730 --> 00:37:07.600
这是我在上一个幻灯片中展示过的数学

00:37:07.600 --> 00:37:09.600
我想搞清楚 n 应该是多少

00:37:09.600 --> 00:37:11.500
由于我有这个目标距离

00:37:11.500 --> 00:37:13.270
因此我知道参考速度

00:37:13.270 --> 00:37:17.290
再除以 2.24 因为我要表示单位小时的英里数

00:37:17.290 --> 00:37:19.010
单位为秒每米

00:37:19.010 --> 00:37:22.090
然后 得到了这个 x 点

00:37:22.090 --> 00:37:24.760
而这只是在加上目标值 x 除以 n 之前

00:37:24.760 --> 00:37:27.935
X 附加的结果

00:37:27.935 --> 00:37:34.270
因此 n 是你在图表中给我们展示的内容

00:37:34.270 --> 00:37:41.640
x 点是这种视觉下 x 轴的

00:37:41.640 --> 00:37:43.897
每个散列标示

00:37:43.897 --> 00:37:47.605
这种视觉下的 x 轴 因此 x 附加条码就是我们开始的地方

00:37:47.605 --> 00:37:48.895
X 将为零

00:37:48.895 --> 00:37:54.580
然后我们插入目标值 x 除以 n n 代表散列标示的数量

00:37:54.580 --> 00:37:54.927
是的

00:37:54.927 --> 00:37:57.082
好的

00:37:57.082 --> 00:38:02.795
为了得到 y 点 就问 s 函数 x 点对应的 y 点是多少

00:38:02.795 --> 00:38:05.550
好的 因此这告诉了我们

00:38:05.550 --> 00:38:11.015
在样条线上 每个小珍珠或吃豆人金块或者导航点的位置

00:38:11.015 --> 00:38:13.960
它们相隔较远 以至于汽车需要以恰当速度运行

00:38:13.960 --> 00:38:14.580
是的

00:38:14.580 --> 00:38:16.870
好的

00:38:16.870 --> 00:38:21.680
在我们的案例中 我们想以时速为 49.5 英里的速度进行

00:38:21.680 --> 00:38:21.930
明白

00:38:21.930 --> 00:38:23.785
所以我们进行循环

00:38:23.785 --> 00:38:28.210
我们需要记住的最后一件事是我们在本地坐标中

00:38:28.210 --> 00:38:28.267
好的

00:38:28.267 --> 00:38:30.460
需要返回到全球坐标中

00:38:30.460 --> 00:38:32.020
因此就像基础变换一样

00:38:32.020 --> 00:38:35.000
我们需要将刚才做的事情颠倒顺序再做一遍

00:38:35.000 --> 00:38:39.220
因此 我们就在这里移动 然后旋转

00:38:39.220 --> 00:38:40.280
好的

00:38:40.280 --> 00:38:44.170
最后 我们将这个重新放进下一个 x 值中

00:38:44.170 --> 00:38:48.690
x y 值 就完成了

00:38:48.690 --> 00:38:51.360
你觉得这个代码会使无人驾驶车比我驾驶的车行驶得更好吗？工作量很大

00:38:51.360 --> 00:38:53.410
让我们试试吧

00:38:53.410 --> 00:38:56.130
好的

00:39:03.400 --> 00:39:05.970
幸好

00:39:05.970 --> 00:39:08.113
已经存储起来了

00:39:08.113 --> 00:39:10.250
我是不是忘了存储？

00:39:10.250 --> 00:39:11.030
我不知道

00:39:11.030 --> 00:39:12.610
别着急

00:39:12.610 --> 00:39:14.310
我们很快就能找到办法

00:39:14.310 --> 00:39:17.050
让我们开始吧

00:39:17.050 --> 00:39:18.167
开始

00:39:18.167 --> 00:39:20.835
无人驾驶车行驶更平缓

00:39:20.835 --> 00:39:23.740
不过一开始 会超越最大抖动

00:39:23.740 --> 00:39:30.580
因为我们从时速零英里开始 经历 50.02 秒

00:39:30.580 --> 00:39:33.700
明白 因此我们从完全停止到时速 50 英里

00:39:33.700 --> 00:39:34.413
是的

00:39:34.413 --> 00:39:41.520
明白

00:39:41.520 --> 00:39:41.825
是的

00:39:41.825 --> 00:39:43.865
那么会发生什么

00:39:43.865 --> 00:39:45.550
会撞上汽车 还是会停止？

00:39:45.550 --> 00:39:48.610
目前 我们不是在确认我们前面是否有汽车

00:39:48.610 --> 00:39:50.890
因此会追尾碰撞

00:39:50.890 --> 00:39:51.970
天啦

00:39:51.970 --> 00:39:53.530
我们可以看一下吗？

00:39:53.530 --> 00:39:55.760
可以 撞击时会出现红色小旗子

00:39:55.760 --> 00:39:57.970
所以 现在碰到了几个问题 需要解决

00:39:57.970 --> 00:40:01.952
第一个问题是冷启动

00:40:01.952 --> 00:40:05.270
我们在冷启动时会打乱加速参数

00:40:05.270 --> 00:40:07.830
第二个问题是需要确认我们前方的汽车

00:40:07.830 --> 00:40:08.020
是的

00:40:08.020 --> 00:40:09.815
那么如何解决呢？

00:40:09.815 --> 00:40:11.170
首先

00:40:11.170 --> 00:40:13.340
不和我们前面的汽车亲密接触当然更好

00:40:13.340 --> 00:40:14.600
没问题

00:40:14.600 --> 00:40:17.830
如果可以的话 让我们避免这个事情

00:40:17.830 --> 00:40:20.787
好的

00:40:20.787 --> 00:40:24.040
所以 让我们来这里 你会记得

00:40:24.040 --> 00:40:25.480
我有一些代码添加了注释

00:40:25.480 --> 00:40:25.860
是的

00:40:25.860 --> 00:40:27.120
现在它会发挥作用

00:40:27.120 --> 00:40:30.000
我貌似忘记了你批注的所有代码

00:40:30.000 --> 00:40:38.620
现在 让我们谈论传感器融合

00:40:38.620 --> 00:40:39.898
好的

00:40:39.898 --> 00:40:41.870
给我讲讲传感器融合吧

00:40:41.870 --> 00:40:48.480
好的 这个模拟器正在报告公路上其他汽车列表

00:40:48.480 --> 00:40:55.590
所有这些其他汽车有一些 s 数值为 d xy vx 和 vy值

00:40:55.590 --> 00:40:55.753
好的

00:40:55.753 --> 00:41:00.120
我们想利用这些数值来找出汽车的位置

00:41:00.120 --> 00:41:04.320
汽车的速度 以及如何表现

00:41:04.320 --> 00:41:04.960
好的

00:41:04.960 --> 00:41:11.630
因此现在 如果我们想避免撞击我们前面的汽车

00:41:11.630 --> 00:41:13.610
需要浏览

00:41:13.610 --> 00:41:19.245
这个传感器列表 并确认汽车是否在车道线内

00:41:19.245 --> 00:41:21.500
并确认这辆汽车与我们的距离

00:41:21.500 --> 00:41:21.714
好的

00:41:21.714 --> 00:41:23.540
如果距离太近 那么可以采取一些行动

00:41:23.540 --> 00:41:24.320
好的

00:41:24.320 --> 00:41:30.300
因此现在 我只是做这个帮忙

00:41:30.300 --> 00:41:31.880
我在查看前路径大小

00:41:31.880 --> 00:41:34.990
以及我是否有导航点需要处理

00:41:34.990 --> 00:41:37.785
我现在要改变这个汽车 s

00:41:37.785 --> 00:41:41.550
它实际上代表了前路径距离 s

00:41:41.550 --> 00:41:41.806
好的

00:41:41.806 --> 00:41:45.135
因此 我将在 Frenet 中进行

00:41:45.135 --> 00:41:48.735
因为在 Frenet 中处理这种逻辑 会非常轻松

00:41:48.735 --> 00:41:52.400
好的 现在展示给我吧

00:41:52.400 --> 00:41:55.290
因此 例如

00:41:55.290 --> 00:41:58.190
我将要查看这里的 D 值

00:41:58.190 --> 00:42:02.550
我可以考虑 汽车是否在什么车道线中

00:42:02.550 --> 00:42:03.768
明白

00:42:03.768 --> 00:42:05.235
因此 我们正在拉

00:42:05.235 --> 00:42:09.963
传感器融合是矢量

00:42:09.963 --> 00:42:12.810
它是双重的矢量

00:42:12.810 --> 00:42:18.300
因此 外部矢量就像一个列表一样存储

00:42:18.300 --> 00:42:21.515
基本上说来 公路上每辆汽车的汽车参数

00:42:21.515 --> 00:42:23.640
然后 内部矢量就是这些参数

00:42:23.640 --> 00:42:28.435
因此 传感器融合 I 将是公路上的 I-F 汽车 对吧？

00:42:28.435 --> 00:42:30.700
并且  在 readme 中

00:42:30.700 --> 00:42:35.100
这个模板会告诉你如何访问所有不同数据

00:42:35.100 --> 00:42:39.453
明白 因此 我猜测传感器融合指数 I

00:42:39.453 --> 00:42:42.180
指数六 明显是

00:42:42.180 --> 00:42:45.045
公路上 I_F 汽车的第六个值

00:42:45.045 --> 00:42:49.560
对于第六个值 我猜是 Frenet  坐标中的 D 值

00:42:49.560 --> 00:42:51.050
是的 结果是 D 值

00:42:51.050 --> 00:42:54.255
好的 现在得到了 D 值

00:42:54.255 --> 00:42:56.600
继续绕这些汽车进行四次循环

00:42:56.600 --> 00:42:57.810
因此 对于每辆车

00:42:57.810 --> 00:43:03.210
我们通过说出那辆车的 D 值是什么 来启动循环中的一个块

00:43:03.210 --> 00:43:03.737
没错

00:43:03.737 --> 00:43:04.100
好的

00:43:04.100 --> 00:43:06.940
D 值会告诉我们汽车所在的车道线

00:43:06.940 --> 00:43:07.473
明白

00:43:07.473 --> 00:43:08.580
在这个案例中

00:43:08.580 --> 00:43:10.380
我并不关心汽车是否在车道线内

00:43:10.380 --> 00:43:11.680
明白

00:43:11.680 --> 00:43:17.975
因此 我们得到了车道线 只是想确认是否在车道线内

00:43:17.975 --> 00:43:23.000
如果 D 小于 2 加 4 乘车道线加 2

00:43:23.000 --> 00:43:27.755
并且大于 2 加 4 乘车道线减 2

00:43:27.755 --> 00:43:30.770
那么就是加 2 和减 2 的区别

00:43:30.770 --> 00:43:33.815
在这个范围内 每个车道线为 4 米宽

00:43:33.815 --> 00:43:36.605
因此 我们要确认 比如

00:43:36.605 --> 00:43:37.940
汽车是否在中心车道线内

00:43:37.940 --> 00:43:40.690
汽车是否在 4 到 8 米范围内

00:43:40.690 --> 00:43:44.782
明白 所以我们只能说汽车在 6 米处

00:43:44.782 --> 00:43:47.060
但是却只给出了中间车道线

00:43:47.060 --> 00:43:47.890
没错

00:43:47.890 --> 00:43:52.060
我们可以说 汽车是不是在 2 加 4 乘车道线

00:43:52.060 --> 00:43:55.705
这可以给我们所有这些车道线 不过却基本上只给我们中心值

00:43:55.705 --> 00:43:59.099
因此 如果汽车在这个车道线内 不过远离中心

00:43:59.099 --> 00:44:02.980
我们就需要查看这个范围 从而确定汽车的位置

00:44:02.980 --> 00:44:05.130
如果我们愿意 甚至还可以使其变成狭窄曲线

00:44:05.130 --> 00:44:05.252
如果我们愿意 还可以再变窄点

00:44:05.252 --> 00:44:06.830
是的

00:44:06.830 --> 00:44:09.445
这简直是速度与激情啊

00:44:09.445 --> 00:44:12.133
所以如果汽车在车道线内

00:44:12.133 --> 00:44:15.220
我将计算汽车的速度

00:44:15.220 --> 00:44:16.130
好的

00:44:16.130 --> 00:44:18.505
我可以 运行 double 型 vx 和 vy

00:44:18.505 --> 00:44:21.110
就是第三个和第四个元素

00:44:21.110 --> 00:44:22.850
然后计算速度

00:44:22.850 --> 00:44:26.290
所以我只是在计算它的速度大小

00:44:26.290 --> 00:44:29.581
好的 所以我们计算 x 速度

00:44:29.581 --> 00:44:35.873
Y 速度 然后运行距离公式

00:44:35.873 --> 00:44:37.290
好的 差不多

00:44:37.290 --> 00:44:39.440
基本上是运行距离公式来得到 -

00:44:39.440 --> 00:44:40.950
是的 只是为了得到那个矢量的大小

00:44:40.950 --> 00:44:41.693
为了得到那个矢量的大小

00:44:41.693 --> 00:44:44.330
因为我们有 vx 所以我们有 x 和 y 分量

00:44:44.330 --> 00:44:47.210
不过我们是想得到那个矢量的大小

00:44:47.210 --> 00:44:48.995
没错

00:44:48.995 --> 00:44:54.290
然后 输出 double 型 check_car_s 等于

00:44:54.290 --> 00:44:58.020
第五个元素的传感器融合 这就是汽车的 s 值

00:44:58.020 --> 00:44:59.810
知道汽车是否真的距离我们很近

00:44:59.810 --> 00:45:01.970
真的非常重要

00:45:01.970 --> 00:45:03.500
现在 对于每辆车

00:45:03.500 --> 00:45:06.560
我们得到了-如果这辆车在我们的车道线内

00:45:06.560 --> 00:45:09.170
然后我们进一步确认是否在车道线上 然后

00:45:09.170 --> 00:45:13.705
得到了汽车的速度 以及 Frenet坐标系中的 s 坐标

00:45:13.705 --> 00:45:14.520
是的

00:45:14.520 --> 00:45:14.714
好的

00:45:14.714 --> 00:45:17.180
速度部分实际上

00:45:17.180 --> 00:45:20.690
对于预测汽车将来的位置非常有用

00:45:20.690 --> 00:45:22.320
好的

00:45:22.320 --> 00:45:28.040
这行代码代表什么？

00:45:28.040 --> 00:45:31.597
这个 check_car_s+=?

00:45:31.597 --> 00:45:31.842
是的

00:45:31.842 --> 00:45:33.553
如果使用了前导航点

00:45:33.553 --> 00:45:36.920
那么我们可以及时地向外投影 s 值

00:45:36.920 --> 00:45:39.935
没问题

00:45:39.935 --> 00:45:42.590
我们为什么要向外投影 s 值呢？

00:45:42.590 --> 00:45:47.120
因为如果我们正在使用前导航点

00:45:47.120 --> 00:45:50.090
我们还没有到达那里

00:45:50.090 --> 00:45:50.230
好的

00:45:50.230 --> 00:45:54.880
我们的汽车仍然有一些靠下

00:45:54.880 --> 00:45:55.174
好的

00:45:55.174 --> 00:45:58.985
所以我们想查看汽车将来的位置

00:45:58.985 --> 00:46:01.325
因为如果我们正在使用前导航点

00:46:01.325 --> 00:46:03.620
这个路径代表未来

00:46:03.620 --> 00:46:08.965
不过我们正在查看我们的汽车位置以及所有其他汽车的当前快照

00:46:08.965 --> 00:46:11.315
因此从前路径的角度来看

00:46:11.315 --> 00:46:14.985
我们想说其他车的未来位置

00:46:14.985 --> 00:46:15.680
好的

00:46:15.680 --> 00:46:16.140
是的

00:46:16.140 --> 00:46:18.720
好的 我们来看其他车的未来位置

00:46:18.720 --> 00:46:19.275
是的

00:46:19.275 --> 00:46:20.400
好的

00:46:20.400 --> 00:46:24.080
这里 我们正进行更多的逻辑运算

00:46:24.080 --> 00:46:29.220
确认汽车 s 是否靠近其他汽车 cars_s

00:46:29.220 --> 00:46:35.290
如果 check_car_s 大于 car_s 那么汽车就在我们前面

00:46:35.290 --> 00:46:39.080
如果这个间距小于

00:46:39.080 --> 00:46:42.905
假设 30 米 那么我们需要采取行动

00:46:42.905 --> 00:46:46.070
明白 因此如果我们的汽车的未来位置

00:46:46.070 --> 00:46:49.505
在这辆车未来位置的 30 米范围内

00:46:49.505 --> 00:46:50.945
那么就需要采取行动

00:46:50.945 --> 00:46:51.650
是的

00:46:51.650 --> 00:46:52.130
明白

00:46:52.130 --> 00:46:54.305
因此 需要运行逻辑

00:46:54.305 --> 00:46:56.315
最好能降低汽车速度

00:46:56.315 --> 00:46:59.330
甚至可以标记 说我们想变更车道线

00:46:59.330 --> 00:47:00.446
好的

00:47:00.446 --> 00:47:02.810
在这个简单例子中

00:47:02.810 --> 00:47:07.960
我将把这个参考速度记为 29.5

00:47:07.960 --> 00:47:10.230
好的 来试试吧

00:47:10.230 --> 00:47:14.900
让我们继续 保存这个参考速度

00:47:14.900 --> 00:47:25.500
不过我觉得

00:47:25.500 --> 00:47:26.860
你没有保存

00:47:26.860 --> 00:47:34.320
再保存一遍

00:47:34.320 --> 00:47:37.650
感谢你的提醒 David

00:47:37.650 --> 00:47:40.300
不客气

00:47:45.390 --> 00:47:56.720
好的 到这里了

00:47:56.720 --> 00:47:59.735
好的

00:47:59.735 --> 00:48:04.040
因此 这个速度仍然超过了原点的最大抖动

00:48:04.040 --> 00:48:07.580
所以汽车仍然要从冷启动到 50 英里每小时 不过还好

00:48:07.580 --> 00:48:09.230
这不是我们这里要解决的问题

00:48:09.230 --> 00:48:11.190
我们在这里要解决的问题是

00:48:11.190 --> 00:48:14.470
我们能否在撞到这辆黄色汽车前刹车？

00:48:14.470 --> 00:48:17.740
好的 这里确实提示了会有撞击

00:48:17.740 --> 00:48:19.970
是的 看起来-

00:48:19.970 --> 00:48:22.665
虽然看起来还没有撞上 但是

00:48:22.665 --> 00:48:25.660
却看起来是爬上了那辆黄色汽车 现在正在往下走

00:48:25.660 --> 00:48:25.960
是的

00:48:25.960 --> 00:48:29.820
我们的车能看到 30 米以外或者 30 米以内的黄色汽车

00:48:29.820 --> 00:48:31.385
正在减速

00:48:31.385 --> 00:48:33.170
是的 已经看到了这辆黄色汽车

00:48:33.170 --> 00:48:37.160
我们让它走 29 米 然后不让它快速回退

00:48:37.160 --> 00:48:38.576
好的

00:48:38.576 --> 00:48:43.195
我们检测到了

00:48:43.195 --> 00:48:47.275
让我们看看

00:48:47.275 --> 00:48:51.030
我还是想解决这个冷启动问题

00:48:51.030 --> 00:48:51.780
好的

00:48:51.780 --> 00:48:53.140
那么如何解决呢？

00:48:53.140 --> 00:48:57.610
让我们来看看

00:48:57.610 --> 00:48:59.540
一路上

00:48:59.540 --> 00:49:04.700
我们一直在说要么按照设置速度运行 要么立刻改变速度

00:49:04.700 --> 00:49:06.530
我们真的要思考的是

00:49:06.530 --> 00:49:10.790
“我们可以做一个渐进式的速度变化吗？”

00:49:10.790 --> 00:49:11.855
好的

00:49:11.855 --> 00:49:15.140
因为我们想要采用加速度运行

00:49:15.140 --> 00:49:18.590
例如 或许是 5 米每平方秒

00:49:18.590 --> 00:49:24.100
然后 我们需要增加或者减去参考速度

00:49:24.100 --> 00:49:28.545
因此 与其说我们要走 29.5 米

00:49:28.545 --> 00:49:31.460
不如在这里设立一个小旗子标记

00:49:31.460 --> 00:49:34.950
然后告诉汽车 “你走得很近了”

00:49:34.950 --> 00:49:36.300
然后来到这里

00:49:36.300 --> 00:49:39.070
我将要查看这里的小旗子

00:49:39.070 --> 00:49:40.715
如果距离太近

00:49:40.715 --> 00:49:43.965
那么可以从这个参考速度减去某个常数值

00:49:43.965 --> 00:49:47.030
0.224

00:49:47.030 --> 00:49:49.694
这并不是一个神奇数字

00:49:49.694 --> 00:49:52.890
结果加速度为 5 米每平方秒

00:49:52.890 --> 00:49:55.880
低于要求的 10 米每平方秒

00:49:55.880 --> 00:49:57.370
明白

00:49:57.370 --> 00:50:04.538
因此 我并不是很了解这个加速度如何在一开始能让汽车减速

00:50:04.538 --> 00:50:07.035
貌似只会在这辆车在其前面的另外一辆车前停下时

00:50:07.035 --> 00:50:10.185
能降低这辆车的速度

00:50:10.185 --> 00:50:14.855
为了解决这个问题 还需要做另外一件事

00:50:14.855 --> 00:50:17.270
就是回到这里 然后以

00:50:17.270 --> 00:50:20.520
零英里每小时速度开始运行

00:50:20.520 --> 00:50:22.785
好的 因此 我们将以零速度开始

00:50:22.785 --> 00:50:25.808
看看如何加速

00:50:25.808 --> 00:50:29.060
这已经包括在我们的逻辑中

00:50:29.060 --> 00:50:31.070
明白

00:50:31.070 --> 00:50:33.910
如果参考速度低于 49.5

00:50:33.910 --> 00:50:36.550
那么我会添加到上面

00:50:36.550 --> 00:50:38.164
好的 如果距离太近

00:50:38.164 --> 00:50:39.280
不过一开始

00:50:39.280 --> 00:50:41.590
不过距离太近 因为这辆车前面没有任何车

00:50:41.590 --> 00:50:46.090
只是冷启动 前面只有一些公路 但是然后

00:50:46.090 --> 00:50:50.230
如果参考速度低于我们要行驶的速度

00:50:50.230 --> 00:50:53.050
然后开始加速 不过要慢一些加速

00:50:53.050 --> 00:50:54.577
没错

00:50:54.577 --> 00:50:57.960
现在是每个循环都要进行增量处理

00:50:57.960 --> 00:51:00.485
我们可以更高效

00:51:00.485 --> 00:51:03.610
我们可以回到路径规划器那里 能看到每个点

00:51:03.610 --> 00:51:08.090
改变参考速度

00:51:08.090 --> 00:51:10.870
明白 那么这个参考速度

00:51:10.870 --> 00:51:14.475
会对后来计算得到的导航点产生什么影响？

00:51:14.475 --> 00:51:19.140
实际上会影响我们的终点值 我们往下看看

00:51:19.140 --> 00:51:21.960
浏览一下

00:51:21.960 --> 00:51:23.850
就在这里

00:51:23.850 --> 00:51:25.828
我们正在运用参考速度

00:51:25.828 --> 00:51:27.380
这有难度 我还没有看到

00:51:27.380 --> 00:51:32.765
如果我们在这个循环里 从参考速度中加上或者减去

00:51:32.765 --> 00:51:35.280
那么就会高效很多

00:51:35.280 --> 00:51:37.170
好的

00:51:37.170 --> 00:51:39.300
那我们需要运行程序 看看如何进行的吗？

00:51:39.300 --> 00:51:39.790
当然

00:51:39.790 --> 00:51:43.060
好的

00:51:45.870 --> 00:51:52.570
好的 来看看

00:51:54.280 --> 00:51:57.200
就在这里

00:51:57.200 --> 00:51:59.230
我以为一会儿没法走到哪呢

00:51:59.230 --> 00:51:59.463
是的

00:51:59.463 --> 00:52:00.560
好的 来看看

00:52:00.560 --> 00:52:02.990
不过电池没电了

00:52:02.990 --> 00:52:05.080
好的 我们来吧 你可以看见

00:52:05.080 --> 00:52:11.680
汽车来到了 49.5 米

00:52:11.680 --> 00:52:12.350
是的

00:52:12.350 --> 00:52:14.820
一开始 当汽车超过最大加速度或者最大抖动时

00:52:14.820 --> 00:52:18.095
我们还没有看到任何大的红旗子

00:52:18.095 --> 00:52:19.920
不过现在 这是有趣的地方

00:52:19.920 --> 00:52:24.850
我们是否可以缓慢降低速度？

00:52:24.850 --> 00:52:25.610
好的

00:52:25.610 --> 00:52:26.440
我们在这里

00:52:26.440 --> 00:52:29.150
我们的路径已经非常接近于白色汽车

00:52:29.150 --> 00:52:31.340
不过这个黑色汽车

00:52:31.340 --> 00:52:34.140
我们自己的汽车

00:52:34.140 --> 00:52:36.725
却没有撞上白色汽车

00:52:36.725 --> 00:52:38.358
继续行驶 再次减速

00:52:38.358 --> 00:52:41.010
很好 非常棒 因此如果我们再等 15 分钟

00:52:41.010 --> 00:52:42.520
这辆车是否会围绕轨道行驶？

00:52:42.520 --> 00:52:44.700
是的

00:52:44.700 --> 00:52:46.110
太棒了 不过 当然

00:52:46.110 --> 00:52:48.525
最好是这辆车能够超越白色汽车

00:52:48.525 --> 00:52:52.240
因此 让我们看看 我们如何改变车道线

00:52:52.240 --> 00:52:55.010
让我们看看 我们如何改变车道线？

00:52:55.010 --> 00:52:59.105
这就是我真的很喜欢样条库的原因之一

00:52:59.105 --> 00:53:05.088
跑题了 不好意思

00:53:05.088 --> 00:53:06.430
我们如何改变车道线？

00:53:06.430 --> 00:53:07.930
你什么时候想改变车道线？

00:53:07.930 --> 00:53:15.270
当你前面的一辆车速度太慢 改变车道线很安全

00:53:15.270 --> 00:53:19.355
并且我们有一些逻辑代码 可以检查汽车是否行驶太慢 对吧？

00:53:19.355 --> 00:53:21.450
是的 我们减速 已经展示过了

00:53:21.450 --> 00:53:23.875
如果这辆车的未来位置

00:53:23.875 --> 00:53:27.685
在我们未来位置的 30 米范围内 那么就需要减速行驶

00:53:27.685 --> 00:53:30.580
那么或许我们需要执行一些代码

00:53:30.580 --> 00:53:33.220
明白 因此如果我们的汽车的未来位置

00:53:33.220 --> 00:53:36.965
在我们未来位置的 30 米范围内 那么就需要改变车道线

00:53:36.965 --> 00:53:37.570
是的

00:53:37.570 --> 00:53:38.390
明白 那么如何解决呢？

00:53:38.390 --> 00:53:48.320
让我们继续前进 并查看车道线是否大于零

00:53:48.320 --> 00:53:49.844
我们从车道线 1 开始

00:53:49.844 --> 00:53:51.500
只是这条中心车道线

00:53:51.500 --> 00:53:56.825
假设这条车道线等于 0

00:53:56.825 --> 00:53:58.700
那么我们应该做什么呢？

00:53:58.700 --> 00:54:03.455
应该左拐

00:54:03.455 --> 00:54:07.270
因此 如果我们在中间或者右边车道线

00:54:07.270 --> 00:54:11.780
那么尽可能快地冲向左侧车道

00:54:11.780 --> 00:54:13.270
我不知道哪儿会出错

00:54:13.270 --> 00:54:16.450
在这个例子中  我们是盲目地左转

00:54:16.450 --> 00:54:16.810
明白

00:54:16.810 --> 00:54:19.355
而不管是否有汽车

00:54:19.355 --> 00:54:20.590
好的 来看看

00:54:20.590 --> 00:54:31.150
因此 我们准备这样做 好的-

00:54:34.180 --> 00:54:38.490
我一直认为它不会去任何地方

00:54:38.490 --> 00:54:42.580
好的 因此 我们有一个比较好的角度

00:54:42.580 --> 00:54:46.620
我绝对不想把这个变成短程加速赛

00:54:46.620 --> 00:54:49.260
还没有 因此这辆汽车只是在做它的事情

00:54:49.260 --> 00:54:50.735
我们之前见到过

00:54:50.735 --> 00:54:53.880
只是在它的车道线行驶

00:54:53.880 --> 00:54:55.380
你认为它仍然会停下来

00:54:55.380 --> 00:54:57.630
是停在这辆白色的汽车后面 还是另外一辆汽车后面？

00:54:57.630 --> 00:54:58.860
貌似是那辆红色汽车

00:54:58.860 --> 00:55:00.570
将停在那辆红色汽车后面？

00:55:00.570 --> 00:55:03.480
好的 让我们拭目以待

00:55:03.480 --> 00:55:08.880
这就是那辆红色汽车 我们已经非常接近了

00:55:08.880 --> 00:55:11.175
不过还是一个很好的车道线变化

00:55:11.175 --> 00:55:14.389
并未违反抖动限制

00:55:14.389 --> 00:55:17.340
只是有一些变化 这个样条线真的能帮助解决问题

00:55:17.340 --> 00:55:22.860
样条线会插入两辆汽车中间 并在左边车道线前面 30 米

00:55:22.860 --> 00:55:24.655
明白 给我看看发生这个的代码

00:55:24.655 --> 00:55:28.470
样条线究竟在哪里插入车道线变化？

00:55:28.470 --> 00:55:35.030
好的 我们在这里改变车道线

00:55:35.120 --> 00:55:39.450
如果我们往下看

00:55:39.450 --> 00:55:48.160
你会注意到车道线是我们要添加到样条线的其中一部分

00:55:48.160 --> 00:55:51.530
与其说六是车道线

00:55:51.530 --> 00:55:54.395
因为你将 2 加 4 乘以车道线

00:55:54.395 --> 00:55:58.240
当车道线从六换成二后

00:55:58.240 --> 00:56:02.720
因为零车道线中间距离导航点两米

00:56:02.720 --> 00:56:05.920
所以 车道线变为二

00:56:05.920 --> 00:56:12.530
因此 2 加上 4  乘以 0 等于2

00:56:12.530 --> 00:56:19.640
因此这就是为什么 d 坐标最后等于 2 的原因

00:56:19.640 --> 00:56:21.110
明白

00:56:21.110 --> 00:56:24.320
然后设置好了样条线导航点

00:56:24.320 --> 00:56:30.103
或许汽车的当前导航点就在 d 乘以 6

00:56:30.103 --> 00:56:35.050
但是导航点 30 60 90 米以外就是 d

00:56:35.050 --> 00:56:38.178
等于二 样条线将拟合

00:56:38.178 --> 00:56:42.195
从零开始的多项式 不过会转向

00:56:42.195 --> 00:56:44.240
车道线是平滑和连续的

00:56:44.240 --> 00:56:47.090
并且这种平滑和连续也源自于间距

00:56:47.090 --> 00:56:49.520
如果你将这个间距从 30 米开始减少

00:56:49.520 --> 00:56:52.640
这个车道线变化可能会大得多

00:56:52.640 --> 00:56:54.045
明白 我可不希望那样

00:56:54.045 --> 00:56:56.345
没错

00:56:56.345 --> 00:57:02.115
所以这非常好 我们现在想出了如何进行一个基本的车道改变

00:57:02.115 --> 00:57:05.030
我们在行为规划课上看到的

00:57:05.030 --> 00:57:08.150
一些有限状态机的东西呢？

00:57:08.150 --> 00:57:10.400
我们将如何合并？

00:57:10.400 --> 00:57:14.670
我们正在做一些非常简单的事情 来完成我们的换道

00:57:14.670 --> 00:57:19.520
很好 我们可能实际上想要考虑先在该车道上查看其他车辆

00:57:19.520 --> 00:57:25.265
然后使用类似的逻辑来查看我们面前是否有汽车

00:57:25.265 --> 00:57:27.375
回到 Frenet

00:57:27.375 --> 00:57:31.475
我们可以核对一辆车是否在那条车道上

00:57:31.475 --> 00:57:36.020
然后可以核对它是否在某个间隔范围 s 内 如果是

00:57:36.020 --> 00:57:38.005
那么变换车道线不安全

00:57:38.005 --> 00:57:40.280
但是或许左转并不安全

00:57:40.280 --> 00:57:43.070
我们可以尝试右转 好的

00:57:43.070 --> 00:57:46.100
因此你可以左转车道

00:57:46.100 --> 00:57:47.660
右转车道 保持车道

00:57:47.660 --> 00:57:51.260
并且永远不会进入车道线左转之类

00:57:51.260 --> 00:57:55.520
如果你看见另外一辆车在 30 米范围内

00:57:55.520 --> 00:57:58.930
或许 100 米 又或者在你后面 50 米 如此这样

00:57:58.930 --> 00:58:01.115
如果你已经在最左边车道线

00:58:01.115 --> 00:58:02.545
你不想离开这条公路

00:58:02.545 --> 00:58:05.120
好的 因此 当你在有限状态机内转到每个状态时

00:58:05.120 --> 00:58:08.290
你开始添加一些逻辑

00:58:08.290 --> 00:58:09.670
明白

00:58:09.670 --> 00:58:14.460
这看起来很好

00:58:14.460 --> 00:58:16.805
我觉得这种方式

00:58:16.805 --> 00:58:20.535
让我们很好地了解如何开始这个项目

00:58:20.535 --> 00:58:26.730
我的意思是 我认为这将是该项目的通过实施

00:58:26.730 --> 00:58:29.005
某些车道线变化可能最终会以撞车结束

00:58:29.005 --> 00:58:31.660
因此你需要小心

00:58:31.660 --> 00:58:34.200
没有撞车是运气太好 因为实际上距离非常近了

00:58:34.200 --> 00:58:37.055
或许我们转到

00:58:37.055 --> 00:58:40.490
回答学员提出的问题上来

00:58:40.490 --> 00:58:44.270
与此同时

00:58:44.270 --> 00:58:53.870
或许只看汽车的行驶

00:58:53.870 --> 00:58:58.140
这很糟 为什么会突然改变车道线？

00:58:58.140 --> 00:59:01.565
汽车是否看见了前面的东西？我想知道

00:59:01.565 --> 00:59:07.380
或许有辆车在后面 可能会撞上去

00:59:07.380 --> 00:59:11.460
我的意思是这不是一条死路 因为后面有一辆车

00:59:11.460 --> 00:59:15.240
我觉得可能是因为我们没有在 C++ 程序上进行重置

00:59:15.240 --> 00:59:16.955
应该是真的

00:59:16.955 --> 00:59:22.870
现在我们到了最左边的车道线 我们动弹不了

00:59:22.870 --> 00:59:25.090
被卡住了 因为我们只知道向左边变换车道

00:59:25.090 --> 00:59:27.650
如果左边有车道线

00:59:27.650 --> 00:59:32.600
是的 因此我们需要一个更好的有限状态机

00:59:32.600 --> 00:59:34.390
一个很好的代价函数

00:59:34.390 --> 00:59:37.680
很好的代价函数 是的

00:59:37.680 --> 00:59:45.300
让我们学会预测 看五秒钟内什么是最好的车道线

00:59:45.300 --> 00:59:46.645
很好 让我们回到问题

00:59:46.645 --> 00:59:50.035
好多人提的问题类似

00:59:50.035 --> 00:59:55.130
第一个多次提到的类似问题来自意大利的 Sebastiano

00:59:55.130 --> 00:59:56.780
Jason 以及 Chris Edwards

00:59:56.780 --> 00:59:58.970
纽约的 Nadia

00:59:58.970 --> 01:00:01.640
意大利的 Francesco Fantause

01:00:01.640 --> 01:00:03.640
纽约的 Michael

01:00:03.640 --> 01:00:08.045
这些问题在某种程度上是对项目的审视

01:00:08.045 --> 01:00:11.888
貌似这个课程和项目缺乏联系

01:00:11.888 --> 01:00:16.115
即使在课程中 我们也忽略了重要部分 和具体例子

01:00:16.115 --> 01:00:19.280
我对这次课程的结构很失望

01:00:19.280 --> 01:00:21.930
期望很多 错觉也很多

01:00:21.930 --> 01:00:28.795
不要说我们没有给你说过来自优达学城的最直白的大实话

01:00:28.795 --> 01:00:32.110
我们对这种失望感到很遗憾

01:00:32.110 --> 01:00:34.890
但是我们觉得这是比较有趣的项目

01:00:34.890 --> 01:00:37.940
为了将课程与实战项目联系起来

01:00:37.940 --> 01:00:42.915
可能还有一些工作需要做

01:00:42.915 --> 01:00:46.790
不过 路径规划就是无人驾驶车中

01:00:46.790 --> 01:00:48.500
最难的一个部分

01:00:48.500 --> 01:00:51.065
如果不能被称为最难的部分

01:00:51.065 --> 01:00:52.585
所以路径规划需要进行很多工作

01:00:52.585 --> 01:00:55.025
我们试着将这个部分连接起来 并使其更简单一些

01:00:55.025 --> 01:00:57.500
希望我们刚才说的话

01:00:57.500 --> 01:01:00.800
能够为你提供实施本项目的一种思维方式

01:01:00.800 --> 01:01:04.165
实施本项目的方式多种多样

01:01:04.165 --> 01:01:05.870
当我做这个项目时

01:01:05.870 --> 01:01:08.125
我的处理方式就与 Aaron 有所不同

01:01:08.125 --> 01:01:11.560
Aaron 在 N 和 D 的处理上与我截然不同

01:01:11.560 --> 01:01:13.460
因此我尝试了一种不同的方式

01:01:13.460 --> 01:01:18.005
但是我考虑采用一种更高的等级

01:01:18.005 --> 01:01:20.660
至少当我第一次得到这个项目时

01:01:20.660 --> 01:01:23.343
我想要做的就是让汽车动起来

01:01:23.343 --> 01:01:25.964
而你可以采用教室里学到的代码

01:01:25.964 --> 01:01:27.680
然后使汽车在车道线行驶

01:01:27.680 --> 01:01:30.013
这就变成一个非常难的问题

01:01:30.013 --> 01:01:34.370
你可以只用 Frenet 坐标就可以使汽车在车道线很好地驾驶

01:01:34.370 --> 01:01:38.503
然后一个更难的问题在于清除道路障碍

01:01:38.503 --> 01:01:40.610
我觉得这里就出现了一个关于清除道路的问题

01:01:40.610 --> 01:01:43.100
因此我们会在这里更详细地讨论

01:01:43.100 --> 01:01:48.230
但是这是我们采用样条线 在这个特殊的检查中进行的

01:01:48.230 --> 01:01:53.375
然后 一旦你开车在车道上行驶

01:01:53.375 --> 01:01:56.000
你会进入一个看起来像行为规划课程结束时

01:01:56.000 --> 01:02:00.614
有点像测验的世界

01:02:00.614 --> 01:02:03.290
你已经将车开到了一条车道以及其他几条车道上

01:02:03.290 --> 01:02:08.770
并且你正在考虑如何在这些车道之间切换

01:02:08.770 --> 01:02:10.730
其中一种处理方式

01:02:10.730 --> 01:02:12.795
或许是最好的方式 就是建立一个代价函数

01:02:12.795 --> 01:02:13.995
不过我们在这里并不是这样处理

01:02:13.995 --> 01:02:15.800
我们只进行了一个非常基本的操作

01:02:15.800 --> 01:02:18.560
如果你看见前面有汽车 转向左边

01:02:18.560 --> 01:02:22.160
不过总的来说 你可能需要一些代价函数

01:02:22.160 --> 01:02:25.748
考虑每条车道线的成本

01:02:25.748 --> 01:02:29.400
然后如果你追溯到预测课程

01:02:29.400 --> 01:02:31.925
你可以尝试并预测未来

01:02:31.925 --> 01:02:35.390
所有这些赛车将在未来不同时间点的位置

01:02:35.390 --> 01:02:42.295
以及未来在不同的州和不同的车道上的成本

01:02:42.295 --> 01:02:44.720
这就是你可能要考虑的

01:02:44.720 --> 01:02:47.030
就像使汽车运动起来

01:02:47.030 --> 01:02:49.765
这只是轨迹生成

01:02:49.765 --> 01:02:51.710
然后你需要考虑

01:02:51.710 --> 01:02:54.720
行为计划 以及你想要变换车道的方式

01:02:54.720 --> 01:02:55.820
是向左 还是向右

01:02:55.820 --> 01:02:59.062
又或者是保持当前车道 然后如果你做到这一点

01:02:59.062 --> 01:03:00.830
预测未来

01:03:00.830 --> 01:03:02.920
试图找出其他车辆将会在哪里

01:03:02.920 --> 01:03:06.710
假设高斯朴素贝叶斯分类器或不同类型的分类器

01:03:06.710 --> 01:03:12.617
并用它来决定你将来想要的位置

01:03:12.617 --> 01:03:14.290
因此 采用实际路径规划器

01:03:14.290 --> 01:03:16.763
数据流向的方式就是你会获得数据

01:03:16.763 --> 01:03:18.875
并预测未来的数据走向

01:03:18.875 --> 01:03:22.370
然后在行为规划中做决策

01:03:22.370 --> 01:03:24.245
最后生成一个轨迹

01:03:24.245 --> 01:03:26.750
在本实战项目中 你可能还想反向推导

01:03:26.750 --> 01:03:29.360
开始建立一个轨迹 假设没有其他车辆

01:03:29.360 --> 01:03:31.790
再假设有其他车辆

01:03:31.790 --> 01:03:35.123
并建立一种行为计划 不担心未来

01:03:35.123 --> 01:03:38.360
再担心未来

01:03:38.360 --> 01:03:39.740
并开始预测未来其他车辆的位置

01:03:39.740 --> 01:03:41.930
我认为这就是你想做的

01:03:41.930 --> 01:03:44.010
这就是我的感想

01:03:44.010 --> 01:03:45.480
你有其他想法吗 Aaron?

01:03:45.480 --> 01:03:49.345
我觉得你刚才说得很好

01:03:49.345 --> 01:03:52.580
目前 我们确实只是在处理轨迹

01:03:52.580 --> 01:03:56.090
不过采用代价函数

01:03:56.090 --> 01:03:59.480
对于变更车道线更好

01:03:59.480 --> 01:04:03.620
而做测验是一个开始采用代价函数的很好方式

01:04:03.620 --> 01:04:07.100
Frenet 坐标很好

01:04:07.100 --> 01:04:09.650
帮我们查看公路上的所有其他汽车

01:04:09.650 --> 01:04:13.775
并确定其 s、n、d 值

01:04:13.775 --> 01:04:16.130
不过 当我们在建立纯粹的轨道时

01:04:16.130 --> 01:04:18.620
Frenet 坐标就变得有点棘手

01:04:18.620 --> 01:04:21.650
因此 我还引入了样条线

01:04:21.650 --> 01:04:25.400
好棒 下面这个问题来自新泽西的 Tim Tobi

01:04:25.400 --> 01:04:28.470
请复习一下样条线的实现

01:04:28.470 --> 01:04:33.565
好的 我们在讲到样条线的概念时 略微讲了一下

01:04:33.565 --> 01:04:35.780
样条线就是一种分段多项式函数

01:04:35.780 --> 01:04:37.880
在样条线上 多个分段通过锚点连接

01:04:37.880 --> 01:04:40.860
有时 被称为节点

01:04:40.860 --> 01:04:44.790
这里已经应用了某些数学知识 将这些分段连接起来

01:04:44.790 --> 01:04:47.220
这个节点的连接比较平滑

01:04:47.220 --> 01:04:51.070
因此样条线轨迹看起来也很平滑

01:04:51.070 --> 01:04:54.060
我认为 从本课的角度来看

01:04:54.060 --> 01:04:56.215
我们并不知道如何实施

01:04:56.215 --> 01:05:00.130
我们真的在使用 因为代码就写在这里

01:05:00.130 --> 01:05:01.445
用起来真的很简单

01:05:01.445 --> 01:05:04.050
关于如何做 你实际上需要知道的是 应用代码

01:05:04.050 --> 01:05:06.655
你想快速浏览它的不同部分

01:05:06.655 --> 01:05:09.630
运行这个代码大概只有三个指令

01:05:09.630 --> 01:05:12.694
首先 初始化

01:05:12.694 --> 01:05:17.640
让我们来到代码 快速浏览

01:05:17.640 --> 01:05:17.774
当然

01:05:17.774 --> 01:05:19.380
如何使用样条线

01:05:19.380 --> 01:05:20.200
是的

01:05:20.200 --> 01:05:22.830
这是你在声明的时候

01:05:22.830 --> 01:05:24.553
Tk 样条线 s

01:05:24.553 --> 01:05:29.790
所以我们包括标题脉冲 现在我们可以声明样条线

01:05:29.790 --> 01:05:31.410
s.set_points

01:05:31.410 --> 01:05:32.880
你正在设置这些点 因此这些是

01:05:32.880 --> 01:05:33.900
X 和 y

01:05:33.900 --> 01:05:40.080
锚点指的是样条线连接起来的结点

01:05:40.080 --> 01:05:46.470
然后这里是 S 和一些 x 值

01:05:46.470 --> 01:05:47.892
明白

01:05:47.892 --> 01:05:51.380
因此你给这条样条线一个 x 值 并得到相应的 y 值

01:05:51.380 --> 01:05:52.220
是的

01:05:52.220 --> 01:05:53.663
很好

01:05:53.663 --> 01:05:55.530
处理样条线 你需要非常小心的一点是

01:05:55.530 --> 01:05:57.450
你需要非常小心

01:05:57.450 --> 01:06:03.450
处理五次多项式或其他任何东西

01:06:03.450 --> 01:06:07.020
如果样条线开始走向垂直

01:06:07.020 --> 01:06:11.400
你可能会得到多个 x 值 或者对于相同的 x 值 你会得到多个 y值

01:06:11.400 --> 01:06:13.470
这打破了一切

01:06:13.470 --> 01:06:18.060
因此这就是  Aaron 为什么这样做的原因

01:06:18.060 --> 01:06:20.010
双重聚合变换？

01:06:20.010 --> 01:06:20.650
没错

01:06:20.650 --> 01:06:21.590
是的

01:06:21.590 --> 01:06:25.500
因此你正在水平移动

01:06:25.500 --> 01:06:28.000
使数学运算简单一些

01:06:28.000 --> 01:06:32.565
如果你移动样条线 样条线会水平而非垂直运行

01:06:32.565 --> 01:06:36.420
从而使一个 x 不会对应多个 y 值

01:06:36.420 --> 01:06:39.862
一旦你从样条线中抽出你需要的导航点 你就可以将这些导航点后移

01:06:39.862 --> 01:06:40.039
是的

01:06:40.039 --> 01:06:42.069
所有一切都会正常运行

01:06:42.069 --> 01:06:45.885
现在收到来自雷德伍德城的 Doug

01:06:45.885 --> 01:06:47.910
慕尼黑的 Juan Pedro

01:06:47.910 --> 01:06:49.670
旧金山的  Konstantin

01:06:49.670 --> 01:06:53.825
以及亚特兰大的 Oliver Hagger 的一个问题

01:06:53.825 --> 01:06:55.895
你可以谈谈有没有什么策略

01:06:55.895 --> 01:06:58.630
可以清除计算之间的轨迹？

01:06:58.630 --> 01:07:00.930
通过创建一条基于我周围导航点的样条曲线

01:07:00.930 --> 01:07:03.535
我能够生成一条平滑的轨迹

01:07:03.535 --> 01:07:06.630
然而 当我在下一个计算中创建一条新的轨迹时

01:07:06.630 --> 01:07:10.950
我的抖动通常会超越阈值 很好 那你为什么不说-

01:07:10.950 --> 01:07:13.850
我想说 前个导航点是

01:07:13.850 --> 01:07:18.940
一个很好的办法 真的可以帮助你们避免任何不连续

01:07:18.940 --> 01:07:24.555
当你纯粹只是在每一帧创建一条新路径时 你必须小心

01:07:24.555 --> 01:07:27.150
有这些前导航点真的很有帮助

01:07:27.150 --> 01:07:29.830
可以给你一个锚点或者参考点

01:07:29.830 --> 01:07:33.390
我发现 当我的抖动有问题时

01:07:33.390 --> 01:07:37.760
我必须更多地依赖于前导航点

01:07:37.760 --> 01:07:41.520
明白 因此确保路径平滑的一个技巧是

01:07:41.520 --> 01:07:43.965
前导航点或者利用前导航点

01:07:43.965 --> 01:07:46.640
从而使新路径和老路径之间存在更多的连续性

01:07:46.640 --> 01:07:47.130
是的

01:07:47.130 --> 01:07:49.815
使用样条曲线本身并沿着样条曲线选取导航点

01:07:49.815 --> 01:07:53.620
因为这些路线需要确保平滑

01:07:53.620 --> 01:07:58.220
你可以做五次多项式生成

01:07:58.220 --> 01:08:02.988
就像它在轨迹生成课程中所涵盖的那样

01:08:02.988 --> 01:08:05.535
涉及更多的数学运算

01:08:05.535 --> 01:08:10.390
如果你是一个懒惰的工程师 头文件变得非常诱人

01:08:10.390 --> 01:08:14.435
在我的实例中 我也会使用样条线

01:08:14.435 --> 01:08:20.700
此外 除了利用 Aaron 对 DNN 的三角法处理

01:08:20.700 --> 01:08:27.695
并将样条线投射到三角形以外

01:08:27.695 --> 01:08:30.175
我一般会在创建后

01:08:30.175 --> 01:08:32.970
从样条线上取下 50 个导航点后

01:08:32.970 --> 01:08:36.990
浏览并确保没有一个导航点

01:08:36.990 --> 01:08:41.335
在创建太高的速度时距离太远

01:08:41.335 --> 01:08:43.350
如果是这样 我就把它们拉回来

01:08:43.350 --> 01:08:46.599
这种做法或许要比 Aaron 采用的数学方式效率低一些

01:08:46.599 --> 01:08:48.300
但我可以更轻松地将我的头围绕在它周围

01:08:48.300 --> 01:08:51.405
而它会--我觉得是要简单一点

01:08:51.405 --> 01:08:53.220
能够保证更好一些

01:08:53.220 --> 01:08:53.520
是的

01:08:53.520 --> 01:08:55.375
不过我还不确信是否能够保证

01:08:55.375 --> 01:08:56.650
貌似看起来可以

01:08:56.650 --> 01:08:57.060
是的

01:08:57.060 --> 01:09:00.330
应该有 90% 的可能性

01:09:00.330 --> 01:09:00.872
干得好

01:09:00.872 --> 01:09:02.625
我必须坐下来 浏览数学

01:09:02.625 --> 01:09:05.480
只是为了说服我自己 是否能保证

01:09:05.480 --> 01:09:08.175
来自加利福尼亚雷德伍德城的 Doug

01:09:08.175 --> 01:09:10.200
当我使用实时帮助功能时

01:09:10.200 --> 01:09:12.420
一位导师说我应该将导航点地图坐标转换为车辆坐标

01:09:12.420 --> 01:09:15.870
并将其用于所有的计算

01:09:15.870 --> 01:09:17.361
你们认为这是一个好办法吗？

01:09:17.361 --> 01:09:20.157
我不清楚如何进行这种变换

01:09:20.157 --> 01:09:22.140
我觉得应该是一个很好的办法

01:09:22.140 --> 01:09:25.135
如果你在谈论本地变换

01:09:25.135 --> 01:09:27.450
这正是我们在复习中做过的

01:09:27.450 --> 01:09:29.330
我们能看看这里的代码吗？

01:09:29.330 --> 01:09:32.170
是的 来吧

01:09:32.170 --> 01:09:33.390
首先 我们变换回来

01:09:33.390 --> 01:09:35.630
我知道这种情况会很低

01:09:35.630 --> 01:09:37.845
是的 变换回来

01:09:37.845 --> 01:09:43.380
不过如果采用数学知识 那么就是进行移动和旋转

01:09:43.380 --> 01:09:45.690
我相信 当我们初次处理的时候

01:09:45.690 --> 01:09:48.560
我们首先移动 然后旋转

01:09:48.560 --> 01:09:52.943
我们可以在这里向上滚动并查看

01:09:52.943 --> 01:09:54.625
是的

01:09:54.625 --> 01:09:58.435
因此 我们首先在这里移动 然后旋转

01:09:58.435 --> 01:10:03.330
因为如下几个原因 我发现这很有用

01:10:03.330 --> 01:10:07.405
首先 我们在 MPC 中进行部署

01:10:07.405 --> 01:10:10.280
这就使得数学处理简单得多

01:10:10.280 --> 01:10:13.260
同时也确保你不会获得任何接近垂直的函数

01:10:13.260 --> 01:10:16.750
并可能引爆

01:10:16.750 --> 01:10:19.560
我正在试着将导航点拟合到

01:10:19.560 --> 01:10:25.005
样条线 从而使计算简单

01:10:25.005 --> 01:10:27.720
因为我只是在 x 轴处理

01:10:27.720 --> 01:10:31.020
我没有必要创建一些单独的 具有某个角度的样条线

01:10:31.020 --> 01:10:34.882
然后再继续处理

01:10:34.882 --> 01:10:38.025
来自台湾的 Hsin-Cheng

01:10:38.025 --> 01:10:42.990
在本实战项目中 有限状态机如何处理混合编程*的？

01:10:42.990 --> 01:10:45.905
在本实战项目中 有限状态机如何处理混合编程*的？

01:10:45.905 --> 01:10:49.280
我想我们早就进行了辩论

01:10:49.280 --> 01:10:51.140
我觉得我还赢了那场辩论 是不是？

01:10:51.140 --> 01:10:52.110
我觉得是

01:10:52.110 --> 01:10:54.896
我赢了 混合编程*也是

01:10:54.896 --> 01:10:57.415
在本实战项目中和 混合编程*有意义吗？

01:10:57.415 --> 01:11:02.995
没有 混合编程*在停车场环境中更有意义

01:11:02.995 --> 01:11:05.400
不过在这种高速路上

01:11:05.400 --> 01:11:09.095
代价函数更有意义

01:11:09.095 --> 01:11:12.685
是的 不过高速公路这种情况很少

01:11:12.685 --> 01:11:15.570
所以实际上很多不同的策略

01:11:15.570 --> 01:11:19.260
但是你只是想选择最低成本的策略

01:11:19.260 --> 01:11:23.100
而混合编程*在密度更高的环境中处理会更好一些

01:11:23.100 --> 01:11:28.061
因为你的选择更有限

01:11:28.061 --> 01:11:32.130
还有离散化的选择

01:11:32.130 --> 01:11:35.520
这更多是一个连续的环境

01:11:35.520 --> 01:11:39.405
你可能喜欢将网格映射到高速公路并使用混合星形

01:11:39.405 --> 01:11:40.876
也许有效

01:11:40.876 --> 01:11:44.490
但使用代价函数或有限状态机似乎是更好的选择

01:11:44.490 --> 01:11:46.710
我认为也许更广泛的一点是

01:11:46.710 --> 01:11:49.425
你通常会将有限状态机和混合星形联用

01:11:49.425 --> 01:11:52.360
这我不确定

01:11:52.360 --> 01:11:53.880
或许这样处理有比较有趣的方式

01:11:53.880 --> 01:11:55.860
不过有一些研究论文可以处理

01:11:55.860 --> 01:11:58.740
我不知道你为什么不假思索地做这件事情

01:11:58.740 --> 01:12:03.220
如果确实有人会采用这种策略 我会感到很有趣

01:12:03.220 --> 01:12:09.440
Highway_map.txt 文件中 来自圣地亚哥的Chris Edwards
为什么“s”不是多余的？

01:12:09.440 --> 01:12:11.700
计算起来很简单 是吧？

01:12:11.700 --> 01:12:14.400
为了以防万一 请将它包括在内

01:12:14.400 --> 01:12:19.110
此外 还有那些我们一开始就在提取的地图路标

01:12:19.110 --> 01:12:21.530
因此 这用在了辅助函数中

01:12:21.530 --> 01:12:25.765
这在我看来 似乎可能是要花费一点点工作来计算

01:12:25.765 --> 01:12:28.150
当然可以 不过你必须做一些矢量数学

01:12:28.150 --> 01:12:31.360
或者你可以使用其中一个辅助函数来获取 s

01:12:31.360 --> 01:12:33.190
好的 现在给你辅助函数

01:12:33.190 --> 01:12:35.310
在各个地方都有 s

01:12:35.310 --> 01:12:35.364
是啊 说得好 说得好

01:12:35.364 --> 01:12:36.885
定位数据中有 s

01:12:36.885 --> 01:12:38.820
地图导航点中也有 s

01:12:38.820 --> 01:12:41.460
来自伦敦的 Ivan Danov

01:12:41.460 --> 01:12:45.795
我们可以使用 Frenet 进行轨迹生成和行为规划吗？

01:12:45.795 --> 01:12:49.410
何时转换回全球笛卡尔坐标

01:12:49.410 --> 01:12:54.325
以及如何避免由转换中的不准确引起的抖动？

01:12:54.325 --> 01:13:02.515
我觉得你可以使用 Frenet 进行轨迹生成和行为规划

01:13:02.515 --> 01:13:05.220
对于轨迹生成 你最终必须

01:13:05.220 --> 01:13:08.520
返回到 XY 全球坐标中

01:13:08.520 --> 01:13:12.570
你如何准确避免抖动

01:13:12.570 --> 01:13:17.250
就回到了我们之前刚谈过的内容 平滑操作

01:13:17.250 --> 01:13:20.775
你如何准确读取样条线

01:13:20.775 --> 01:13:27.210
以及你如何尽量减少导航点和样条线之间的颠簸

01:13:27.210 --> 01:13:29.295
来自慕尼黑的 Juan Pedro

01:13:29.295 --> 01:13:34.185
如何处理来自模拟器的精确加速度读数的缺失？

01:13:34.185 --> 01:13:38.190
从轨迹的一组连续点进行推断

01:13:38.190 --> 01:13:42.680
或测量模拟器更新之间的时间 并使用速度变化 可以吗？

01:13:42.680 --> 01:13:46.710
或者当我们计算轨迹时只是迫使结束/使开始加速度为零

01:13:46.710 --> 01:13:52.140
并且只在它们的末端将轨迹缝合在一起 这样能得到更好的结果吗？

01:13:52.140 --> 01:13:56.115
检出代码中的加速度值可能非常有用

01:13:56.115 --> 01:14:01.090
在模拟器中 实际上只是将它从某个时间平均分配

01:14:01.090 --> 01:14:03.635
或许 一秒钟的间隔

01:14:03.635 --> 01:14:07.565
因此 是一些平均值

01:14:07.565 --> 01:14:12.765
但是 如果你喜欢这种轨迹生成本身

01:14:12.765 --> 01:14:16.365
比如五次多项式求解器

01:14:16.365 --> 01:14:21.670
一般情况下 你在开始和结束时都使用零加速

01:14:21.670 --> 01:14:28.080
是的  一般来说 如果你想保证你不会超过加速限制

01:14:28.080 --> 01:14:35.830
那么计算它并验证你的代码很有用

01:14:35.830 --> 01:14:36.443
是的

01:14:36.443 --> 01:14:40.290
但正如你所看到的 对样条线进行假设的Aaron 的代码很有效果

01:14:40.290 --> 01:14:44.800
起到了作用

01:14:44.800 --> 01:14:46.215
来自奥地利的 Oleg

01:14:46.215 --> 01:14:49.590
我们如何在状态转移函数中生成轨迹

01:14:49.590 --> 01:14:53.490
（当我们想要计算每个可能的下一个状态的成本时）？

01:14:53.490 --> 01:14:59.580
如果状态是 PLCL 并且我们生成了水平线 5 的轨迹

01:14:59.580 --> 01:15:02.600
哪些状态应该采取下一步措施？

01:15:02.600 --> 01:15:05.010
如果要更换车道

01:15:05.010 --> 01:15:08.280
可以使用不同的锚点计算几个不同的候选样条线

01:15:08.280 --> 01:15:11.348
并且可以计算每个样条线的抖动

01:15:11.348 --> 01:15:14.400
然后选择最小抖动的样条线

01:15:14.400 --> 01:15:20.545
这是轨迹生成课程中提到过的

01:15:20.545 --> 01:15:23.925
你可以使用抖动最小化轨迹

01:15:23.925 --> 01:15:25.770
在 JMT 中提到过

01:15:25.770 --> 01:15:27.900
那节课也提到过

01:15:27.900 --> 01:15:32.430
虽然采用五次多项式不一样

01:15:32.430 --> 01:15:35.520
对于如何生成轨迹第一状态转换函数

01:15:35.520 --> 01:15:39.925
你有任何更好的答案吗？

01:15:39.925 --> 01:15:43.560
是的 我是说 我喜欢采用不同锚点的想法

01:15:43.560 --> 01:15:48.610
然后试着计算每个锚点的加速度变化

01:15:48.610 --> 01:15:50.460
真的很有趣

01:15:50.460 --> 01:15:53.040
从我们在这里做的事情来看

01:15:53.040 --> 01:15:56.190
我们只有几米的距离

01:15:56.190 --> 01:15:58.620
我们可以利用这种距离进行调整

01:15:58.620 --> 01:16:02.630
这实际上会改变我们的车道突兀变化的问题

01:16:02.630 --> 01:16:05.480
这个结果对我来说很好

01:16:05.480 --> 01:16:08.550
不过 一旦在低水平情况起作用

01:16:08.550 --> 01:16:12.260
那么可以创建和定义更高水平

01:16:12.260 --> 01:16:16.455
如保持车道 并准备变道左

01:16:16.455 --> 01:16:19.200
然后 你正在谈论

01:16:19.200 --> 01:16:22.410
行为计划测验

01:16:22.410 --> 01:16:27.095
并且对这个状态以及水平线采用了代价函数

01:16:27.095 --> 01:16:27.541
明白

01:16:27.541 --> 01:16:29.781
来自奥地利的 Oleg

01:16:29.781 --> 01:16:32.130
在状态PLCL / PLCR（准备变道左/准备变道右）

01:16:32.130 --> 01:16:35.715
后面应该执行什么逻辑?

01:16:35.715 --> 01:16:40.500
如果目标车道速度更高

01:16:40.500 --> 01:16:43.515
那么我们是否应该先增加速度或者跟踪间隔？

01:16:43.515 --> 01:16:46.455
要是我们增加速度 然后迎头碰上一辆车呢？

01:16:46.455 --> 01:16:49.080
如果目标车道速度更低

01:16:49.080 --> 01:16:53.340
那么我们是否应该在变换车道或移动前减速 然后再减速？

01:16:53.340 --> 01:16:54.620
选择很多

01:16:54.620 --> 01:16:57.810
我觉得最安全的的是减速

01:16:57.810 --> 01:17:00.600
如果你试图在这条车道上过关

01:17:00.600 --> 01:17:04.270
你会选择一辆你想要在后面合并的汽车

01:17:04.270 --> 01:17:10.950
所以你使用准备变道的主要原因在于

01:17:10.950 --> 01:17:14.040
如果你想左转但是却不能 因为-

01:17:14.040 --> 01:17:17.800
或者如果你想右转但是却不能 因为正好有汽车

01:17:17.800 --> 01:17:22.410
因此预测未来并采用

01:17:22.410 --> 01:17:24.630
预测课中的技巧很有帮助

01:17:24.630 --> 01:17:27.310
因为你发现了这辆汽车

01:17:27.310 --> 01:17:30.690
正在左边 造成你无法变更车道

01:17:30.690 --> 01:17:32.295
那辆汽车加速了吗？

01:17:32.295 --> 01:17:35.010
在这种情况下 如果你保持匀速

01:17:35.010 --> 01:17:37.845
那么两辆车之间会不知不觉产生距离间隔

01:17:37.845 --> 01:17:44.410
又或者这辆车在减速 或许你想加速 如果可以 并超过它

01:17:44.410 --> 01:17:48.540
但是 基本上说来 你要预测未来

01:17:48.540 --> 01:17:58.255
并在产生间隔时想出解决办法 以及弥补这种间隔的最佳方式是什么

01:17:58.255 --> 01:18:01.680
因此有不少不同的解决方案

01:18:01.680 --> 01:18:05.760
是的 这是本实战项目的精髓 并且非常有趣

01:18:05.760 --> 01:18:07.628
是的 来自 Clio 的问题

01:18:07.628 --> 01:18:12.075
对于 int NextWaypoint 函数的 main.cpp代码 我有些困惑

01:18:12.075 --> 01:18:18.165
我不知道角度变量代表什么

01:18:18.165 --> 01:18:20.890
或者这个角度为什么要大于 pi/4？

01:18:20.890 --> 01:18:22.875
如果你可以少做点拨 我将不胜感激

01:18:22.875 --> 01:18:25.110
下一个导航点函数如何发挥作用？

01:18:25.110 --> 01:18:30.495
好的 对于这个问题 这个角度实际上是汽车的角度 正在告诉你

01:18:30.495 --> 01:18:35.450
汽车正在看哪个导航点

01:18:35.450 --> 01:18:38.220
我们想避免碰到一个很接近汽车

01:18:38.220 --> 01:18:42.210
汽车却没有发现的导航点

01:18:42.210 --> 01:18:50.450
而这个 pi/4 即 45 度角是你看问题的距离

01:18:50.450 --> 01:18:55.050
确认那个导航点是否与那个角度对齐

01:18:55.050 --> 01:18:59.670
有一点棘手

01:18:59.670 --> 01:19:02.220
来自于底特律的 Chris Chan

01:19:02.220 --> 01:19:05.065
本实战项目中使用的主要软件是什么？

01:19:05.065 --> 01:19:08.430
例如 JMT 代价函数 FSM?

01:19:08.430 --> 01:19:11.040
我们需要特别注意

01:19:11.040 --> 01:19:14.455
避免违反加速度和抖动限制？

01:19:14.455 --> 01:19:19.025
因此 我们使用的重要工具为

01:19:19.025 --> 01:19:25.020
Frenet 坐标 以及一些路径规划器

01:19:25.020 --> 01:19:28.900
无论是否是五次多项式 样条线 等等

01:19:28.900 --> 01:19:38.220
然后采用有限状态机搞清楚要采取的策略

01:19:38.220 --> 01:19:43.200
所以我认为这可能是你需要采取的最少步骤

01:19:43.200 --> 01:19:46.260
但你可能会遇到一些非常复杂的事情

01:19:46.260 --> 01:19:49.170
特别是增加状态并试着尽可能快地导航交通

01:19:49.170 --> 01:19:51.940
来自于旧金山的  Konstantin

01:19:51.940 --> 01:19:53.715
Jean-FranÃ§ois 我念对名字了吧？

01:19:53.715 --> 01:19:55.920
我希望是 在圣何塞市

01:19:55.920 --> 01:19:59.950
你可以说一下 为了求解 如何使用 JMT 和样条线吗？

01:19:59.950 --> 01:20:01.480
我觉得应该是 如何使用 JMT  或者 样条线 你觉得呢？

01:20:01.480 --> 01:20:03.500
是的 我也这么认为

01:20:03.500 --> 01:20:04.960
如果你想清除一条路的障碍

01:20:04.960 --> 01:20:07.588
那么可以使用 JMT 或样条线来进行

01:20:07.588 --> 01:20:10.610
来自德国的 Frank Schneider

01:20:10.610 --> 01:20:14.660
请问在 getFrenetMethod 中 采用什么当数据？

01:20:14.660 --> 01:20:20.560
当转换更远距离的坐标时 汽车的航向会产生 s 值

01:20:20.560 --> 01:20:23.240
这可能是由于变换的非线性

01:20:23.240 --> 01:20:27.680
我们在轨道的某些边缘下看到了这种情况

01:20:27.680 --> 01:20:31.560
如果我们具有这种 S 和 D 值

01:20:31.560 --> 01:20:36.235
那么当汽车位于该边缘时它们的计算接近

01:20:36.235 --> 01:20:38.690
可能有点离题了

01:20:38.690 --> 01:20:42.760
明白 我没有执行这个计划 Aaron

01:20:42.760 --> 01:20:44.870
你一直能改变

01:20:44.870 --> 01:20:51.260
来自 Friederich 如何计算 s_dot_dot？

01:20:51.260 --> 01:20:54.585
S将是 Frenet 坐标中我们的位置

01:20:54.585 --> 01:20:57.025
S_Dot 将是速度无限坐标

01:20:57.025 --> 01:21:01.310
S_dot_dot 将是我们的加速无限坐标

01:21:01.310 --> 01:21:05.210
如果你在思考如何计算作为速度的 S_dot

01:21:05.210 --> 01:21:09.920
你需要搞清楚一个点和另外一个点

01:21:09.920 --> 01:21:13.130
然后 我们知道汽车车速为

01:21:13.130 --> 01:21:17.060
50 点每秒 而模拟器速度为 50点每秒

01:21:17.060 --> 01:21:19.477
因此如果你划分距离

01:21:19.477 --> 01:21:22.880
一个点与另外一个点之间的距离 抱歉刚才说错了

01:21:22.880 --> 01:21:27.635
然后将这个距离

01:21:27.635 --> 01:21:34.890
除以0.02 就是 50 点每秒 就得到速度

01:21:34.890 --> 01:21:37.335
就是 S_dot 为了计算

01:21:37.335 --> 01:21:42.565
S_dot_dot 你要做的就是计算速度变化

01:21:42.565 --> 01:21:44.900
因此你要计算一对点之间的速度

01:21:44.900 --> 01:21:48.305
以及另外一对点之间的速度

01:21:48.305 --> 01:21:53.390
然后 再除以经过所有这些点所需的时间

01:21:53.390 --> 01:21:59.775
就能得到 S_dot_dot

01:21:59.775 --> 01:22:02.390
与 XY 坐标相同

01:22:02.390 --> 01:22:04.395
只是一个坐标变换

01:22:04.395 --> 01:22:07.190
非常感谢加入我们 复习路径规划项目

01:22:07.190 --> 01:22:09.795
这真的是一个很挑战的项目

01:22:09.795 --> 01:22:11.270
也是一个非常有趣的项目

01:22:11.270 --> 01:22:14.105
你可以做很多事情

01:22:14.105 --> 01:22:17.810
Aaron 为建立本项目模拟器以及其他项目所做的工作

01:22:17.810 --> 01:22:22.240
真的很棒

01:22:22.240 --> 01:22:25.010
它使得该项目比仅在终端屏幕上

01:22:25.010 --> 01:22:29.030
显示小数点的情况更有趣

01:22:29.030 --> 01:22:31.910
所以我希望你们喜欢这个项目 也希望我们

01:22:31.910 --> 01:22:36.905
能够为你提供实施本项目的一种思维 或多种方案

01:22:36.905 --> 01:22:39.860
我们回头在 Slack 见吧

01:22:39.860 --> 01:22:44.210
如果你有任何问题 可以在论坛提问 我们将尽量回答

01:22:44.210 --> 01:22:46.480
所以有问题就尽管问吧

01:22:46.480 --> 01:22:49.600
好的 太好了！大家再见！

