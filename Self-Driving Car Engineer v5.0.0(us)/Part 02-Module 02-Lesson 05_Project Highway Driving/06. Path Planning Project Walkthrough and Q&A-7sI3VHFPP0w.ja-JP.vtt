WEBVTT
Kind: captions
Language: ja-JP

00:00:00.000 --> 00:00:03.740
こんにちはデイビッド シルバーです

00:00:03.740 --> 00:00:06.720
Udacity Nanodegree プログラムの自動運転車のチームリーダーです

00:00:06.720 --> 00:00:09.880
こんにちは アーロン ブラウンです

00:00:09.880 --> 00:00:12.440
わたしはコンテンツ開発者です

00:00:12.440 --> 00:00:16.040
今日 皆さんと見ていくパスプランニングプロジェクトの構築に携わりました 

00:00:16.040 --> 00:00:19.395
そうですこれがパスプランニングプロジェクトのウォークスルーになります

00:00:19.395 --> 00:00:21.160
Term 2 最初のプロジェクトです

00:00:21.160 --> 00:00:26.090
自動運転車プログラムのパスプランニングモジュールでは唯一のプロジェクトになります

00:00:26.090 --> 00:00:28.220
それでは始めましょう

00:00:28.220 --> 00:00:30.290
アーロン 君が作ったんですよね

00:00:30.290 --> 00:00:31.615
どこから始めればいいですか?

00:00:31.615 --> 00:00:33.830
クラスムールから始ますか?

00:00:33.830 --> 00:00:38.859
そうですねでは まず プロジェクトのリポジトリをチェックアウトするところから始めましょう

00:00:38.859 --> 00:00:42.030
OKわかりました

00:00:42.030 --> 00:00:43.173
Windisk

00:00:43.173 --> 00:00:50.320
Udacity パスプランニングプロジェクト これで Google 検索できるかなあった

00:00:50.320 --> 00:00:51.340
あった先頭に出てきましたね

00:00:51.340 --> 00:00:52.140
最初に出てきましたねOK

00:00:52.140 --> 00:00:55.480
よし いいですね

00:00:55.480 --> 00:00:57.020
ここには始めるにあたって必要なコードがすべてあります

00:00:57.020 --> 00:01:01.110
シミュレーターをダウンロードするリンクもあります

00:01:01.110 --> 00:01:03.495
OKそれでは

00:01:03.495 --> 00:01:05.815
シミュレーター 私は既にダウンロードしておきました

00:01:05.815 --> 00:01:08.480
そう シミュレーターをダウンロードします

00:01:08.480 --> 00:01:09.717
次は何をすればいいですか?

00:01:09.717 --> 00:01:12.830
では このリポジトリのクローンを作成しましょう

00:01:12.830 --> 00:01:13.711
OK

00:01:13.711 --> 00:01:17.175
それから パスプランナー用のコードを作成し始めましょう

00:01:17.175 --> 00:01:20.080
了解リポジトリのクローン作成ですね

00:01:20.080 --> 00:01:21.320
これもやっておきましたよ

00:01:21.320 --> 00:01:26.045
これが私のターミナルです

00:01:26.045 --> 00:01:31.545
現在 CarND-Path-Planning-Project のディレクトリにいます

00:01:31.545 --> 00:01:32.770
実際にはソース内

00:01:32.770 --> 00:01:34.400
このプロジェクトのサブディレクトリにいます

00:01:34.400 --> 00:01:35.030
了解

00:01:35.030 --> 00:01:36.656
では 次は?

00:01:36.656 --> 00:01:42.071
ソース内のメインコードは main.cpp からのコードを使用します

00:01:42.071 --> 00:01:42.525
了解

00:01:42.525 --> 00:01:44.930
また Read Me にも開始する上での説明や

00:01:44.930 --> 00:01:47.480
シミュレーターから C++ コードに移行する場合に考慮すべき

00:01:47.480 --> 00:01:53.217
ことが記載されています

00:01:53.217 --> 00:01:56.740
了解ここですね リポジトリのクローンを作成する

00:01:56.740 --> 00:02:01.250
リポジトリをビルドする コードを実行する それぞれを見ていくことにします

00:02:01.250 --> 00:02:02.390
了解

00:02:02.390 --> 00:02:04.850
オリジナルの状態

00:02:04.850 --> 00:02:08.300
にいることを

00:02:08.300 --> 00:02:09.410
確認します

00:02:09.410 --> 00:02:13.395
リポジトリから main.cpp をチェックアウトしますこちらに移動します

00:02:13.395 --> 00:02:16.790
cmake は実行済みなので

00:02:16.790 --> 00:02:19.160
プロジェクトをそのまま make します

00:02:19.160 --> 00:02:20.510
正常にコンパイルしていることを確認してくださいね

00:02:20.510 --> 00:02:21.740
正常にコンパイルが行われたことを確認します

00:02:21.740 --> 00:02:24.340
バイナリを実行します

00:02:24.340 --> 00:02:26.440
これで パスプランニングのバイナリが実行しています

00:02:26.440 --> 00:02:29.870
こっちの画面にスワイプしてシミュレーターを動かしてみます

00:02:29.870 --> 00:02:29.871
了解

00:02:29.871 --> 00:02:31.220
何が起きるのですか?

00:02:31.220 --> 00:02:33.095
車は停止したまま動きません

00:02:33.095 --> 00:02:35.450
xy ポイントのリストが空のためです

00:02:35.450 --> 00:02:36.720
がっかりですね

00:02:36.720 --> 00:02:39.575
そうですねそのため xy ポイントをプランナーに追加する必要があります

00:02:39.575 --> 00:02:43.065
了解では どうしたらいいですか?

00:02:43.065 --> 00:02:45.460
クラスムールに行きますか?別の方法がありますか?

00:02:45.460 --> 00:02:49.892
main.cpp を開いてみましょう

00:02:49.892 --> 00:02:52.896
初めて main.cpp を開くと

00:02:52.896 --> 00:02:56.896
自由に使えるヘルパー関数が表示されます

00:02:56.896 --> 00:02:59.790
OKこのヘルパー関数を見てみることにしましょう

00:02:59.790 --> 00:03:05.275
このヘルパー関数を見てみます

00:03:05.275 --> 00:03:07.900
hasData ヘルパー関数というのがあります

00:03:07.900 --> 00:03:09.280
この関数は必要ですか?

00:03:09.280 --> 00:03:11.891
これは uWebSocket テンプレートからの関数ですね

00:03:11.891 --> 00:03:15.220
別のプロジェクトでも見たことがありますね

00:03:15.220 --> 00:03:16.070
了解

00:03:16.070 --> 00:03:17.260
distance があります

00:03:17.260 --> 00:03:18.580
役に立ちそうですね

00:03:18.580 --> 00:03:21.240
2 点のユークリッド距離を計算します

00:03:21.240 --> 00:03:23.998
了解このプロジェクトではたくさんの幾何学を使用します

00:03:23.998 --> 00:03:24.157
了解

00:03:24.157 --> 00:03:25.690
ClosestWaypoint

00:03:25.690 --> 00:03:29.046
幹線道路付近のすべてのウェイポイントを含む地図があります

00:03:29.046 --> 00:03:29.185
了解

00:03:29.185 --> 00:03:30.958
一番近いウェイポイントを確認することができます

00:03:30.958 --> 00:03:31.109
了解

00:03:31.109 --> 00:03:33.368
どれが NextWaypoint になるかも確認できます

00:03:33.368 --> 00:03:35.680
ClosestWaypoint と NextWaypoint の違いは何ですか

00:03:35.680 --> 00:03:39.505
ウェイポイントのちょうど前にいるとします

00:03:39.505 --> 00:03:44.350
角度が 近いけれど現在の地点より後ろにあるウェイポイントではなく

00:03:44.350 --> 00:03:46.930
少し遠いけれど向かうのはこっちのウェイポイントだと示している場合です

00:03:46.930 --> 00:03:50.140
そういうことですね飛行機に乗ったときに 一番近い出口が後方にある可能性があるのと似ていますね

00:03:50.140 --> 00:03:50.598
そのとおりです

00:03:50.598 --> 00:03:52.535
了解しましたOK

00:03:52.535 --> 00:03:54.833
では

00:03:54.833 --> 00:03:55.716
getFrenet

00:03:55.716 --> 00:03:59.200
そうですねパスプランニングのレッスンでは

00:03:59.200 --> 00:04:01.900
frenet 座標についていろいろと見てきました

00:04:01.900 --> 00:04:05.105
また frenet 座標が特に幹線道路で非常に役立つことも説明しました

00:04:05.105 --> 00:04:09.850
これらの転換は frenet 座標から xy 座標への移行で行っています

00:04:09.850 --> 00:04:11.305
了解引数についてはどうですか

00:04:11.305 --> 00:04:12.986
引数は 5 つありますどのような引数ですか?

00:04:12.986 --> 00:04:16.395
x と y など皆さんが期待するような引数のほか

00:04:16.395 --> 00:04:19.240
theta もあります

00:04:19.240 --> 00:04:22.225
地図を見ている場合 実際に変換を行う際に便利です

00:04:22.225 --> 00:04:25.780
また x と y のウェイポイントのリストもあります

00:04:25.780 --> 00:04:30.180
ウェイポイントは最初に計算します

00:04:30.180 --> 00:04:37.210
OKでは この中のどれに注目する必要がありますか

00:04:37.210 --> 00:04:40.400
また あまり気にする必要のないものはありますか

00:04:40.400 --> 00:04:41.290
x y と theta です

00:04:41.290 --> 00:04:41.465
OK

00:04:41.465 --> 00:04:45.835
あとは 基本的に 最初に maps_x とmaps_y

00:04:45.835 --> 00:04:50.720
に計算したものを使用します

00:04:50.720 --> 00:04:51.598
了解

00:04:51.598 --> 00:04:54.829
ファイルから地図へ出力されます

00:04:54.829 --> 00:04:57.430
getFrenet 内で起こっていることを

00:04:57.430 --> 00:05:00.345
実際に理解しておく必要がありますか?

00:05:00.345 --> 00:05:01.645
あるいはブラックボックスと理解してそのまま使用するだけでいいですか?

00:05:01.645 --> 00:05:03.370
特に理解しなくても使用できます

00:05:03.370 --> 00:05:06.395
ただし コードには実際にアクセスすることができ 修正することも可能です

00:05:06.395 --> 00:05:09.025
コードを改善することも可能です

00:05:09.025 --> 00:05:12.954
変換方法に別のアイデアを取り入れることもできます

00:05:12.954 --> 00:05:13.076
OK

00:05:13.076 --> 00:05:15.040
本当に さまざまな修正や変更を行うことができます

00:05:15.040 --> 00:05:19.200
OK 見てみましょう

00:05:19.200 --> 00:05:22.544
getFrenet は見たので 今度は getXY です

00:05:22.544 --> 00:05:23.040
そうですね

00:05:23.040 --> 00:05:25.540
これは逆変換のはずです ただし、

00:05:25.540 --> 00:05:27.612
Frenet と xy は正確には

00:05:27.612 --> 00:05:31.315
線形変換ではありません

00:05:31.315 --> 00:05:34.960
わかりましたx と y を渡す代わりに

00:05:34.960 --> 00:05:37.000
s と d を渡します Frenet の座標です

00:05:37.000 --> 00:05:38.215
また theta に渡す代わりに

00:05:38.215 --> 00:05:42.170
このベクターの maps_s に渡します

00:05:42.170 --> 00:05:42.760
はい

00:05:42.760 --> 00:05:44.295
そして maps_x と maps_y にも渡します

00:05:44.295 --> 00:05:46.450
maps_s で何か注意する必要はありますか?最初の計算のままでいいですか?

00:05:46.450 --> 00:05:49.620
これは最初に計算されるので それを与えるだけで

00:05:49.620 --> 00:05:53.140
関数内の地図にそのまま使用されます

00:05:53.140 --> 00:05:55.055
わかりましたOKでは main を見ていきます

00:05:55.055 --> 00:05:56.646
これはすべてヘルパー関数ですこれが main です

00:05:56.646 --> 00:05:56.673
そうですね

00:05:56.673 --> 00:06:03.370
かなり多くの変数が宣言されているように見えます

00:06:03.370 --> 00:06:04.810
定数がいくつかあります

00:06:04.810 --> 00:06:06.500
CSV ファイルがあります

00:06:06.500 --> 00:06:09.280
トラックのリンクがあります

00:06:09.280 --> 00:06:11.570
これはラップアラウンドする際に便利です

00:06:11.570 --> 00:06:12.985
OK

00:06:12.985 --> 00:06:16.210
先に進んで地図のテキストファイルを開き

00:06:16.210 --> 00:06:19.750
x, y, s, dx, dyからなる

00:06:19.750 --> 00:06:22.525
ベクターをロードします

00:06:22.525 --> 00:06:27.510
dx および dy は単にそのウェイポイントに対する通常の成分です

00:06:27.510 --> 00:06:30.579
わかりましたCSV ファイルはどこで開きますか?

00:06:30.579 --> 00:06:36.985
実際にはデータから取得します highwaymap.csv と呼ばれています

00:06:36.985 --> 00:06:42.130
stringstream を使用してロードします

00:06:42.130 --> 00:06:43.990
了解これも実行済みです

00:06:43.990 --> 00:06:47.480
そうですねでは それをプログラムでは使用していきましょう

00:06:47.480 --> 00:06:52.135
了解では えっと

00:06:52.135 --> 00:06:53.618
メッセージが渡されていますね

00:06:53.618 --> 00:06:58.020
何が起きているんですか

00:06:58.020 --> 00:07:01.075
いつもの uWebSocket テンプレートを渡したら

00:07:01.075 --> 00:07:03.610
ローカライゼーションデータが得られます

00:07:03.610 --> 00:07:04.017
了解

00:07:04.017 --> 00:07:06.875
シミュレーターは Frenet の sd と xy で

00:07:06.875 --> 00:07:11.380
車両の正確な位置を示しています

00:07:11.380 --> 00:07:12.025
了解

00:07:12.025 --> 00:07:15.390
車両の角度と速度についても示しています

00:07:15.390 --> 00:07:17.204
了解

00:07:17.204 --> 00:07:18.955
ここなんですが

00:07:18.955 --> 00:07:22.360
if (event == "telemetry") があって

00:07:22.360 --> 00:07:24.370
ここがアクションを発生させている箇所ですか？

00:07:24.370 --> 00:07:27.970
はいエンジニアリング的に重要な部分を

00:07:27.970 --> 00:07:32.290
どのようにするか決定するために使用する全ての変数がここにあります

00:07:32.290 --> 00:07:36.055
了解わかりました一連の変数がここで指定され

00:07:36.055 --> 00:07:39.393
JSON も指定されていますね

00:07:39.393 --> 00:07:41.780
センサーフュージョンも重要です

00:07:41.780 --> 00:07:43.435
ローカライゼーションについて説明しました

00:07:43.435 --> 00:07:47.015
センサーフュージョンは路上にある他の全車両です

00:07:47.015 --> 00:07:48.625
これらの車両とぶつかりたくないですよね

00:07:48.625 --> 00:07:52.270
できればよけたいですよね

00:07:52.270 --> 00:07:55.030
了解ここ ここに TODO があります こう書いてあります

00:07:55.030 --> 00:07:57.610
(日本語訳: 「車が .02 秒ごと連続的に

00:07:57.610 --> 00:08:00.565
進む (x,y) ポイントで構成されるパスを定義します 」)

00:08:00.565 --> 00:08:02.840
この TODO の下に

00:08:02.840 --> 00:08:07.960
JSON 変数を設定しています

00:08:07.960 --> 00:08:09.455
x vals と y vals または next_x_vals と next_y_vals と同等のようですね

00:08:09.455 --> 00:08:11.561
それがパスプランナーを構成しています

00:08:11.561 --> 00:08:11.575
了解

00:08:11.575 --> 00:08:13.680
x と y ポイントです

00:08:13.680 --> 00:08:15.210
車両を前進させるには

00:08:15.210 --> 00:08:17.410
これらの next_x_vals や next_y_vals に

00:08:17.410 --> 00:08:20.160
何かを設定しないといけないわけですね

00:08:20.160 --> 00:08:22.055
現在は この状態のまま使用しているわけですね

00:08:22.055 --> 00:08:24.333
そのとおりですさっき見たように 私たちの車が停止したままなのは これが原因です

00:08:24.333 --> 00:08:26.800
わかりましたベクターに何もないから

00:08:26.800 --> 00:08:27.970
車はどこにも行かないわけですね

00:08:27.970 --> 00:08:29.087
そのとおりです

00:08:29.087 --> 00:08:30.860
OKでは どうしたら車を動かすことができますか?

00:08:30.860 --> 00:08:34.940
クラスルームに開始コードがあります

00:08:34.940 --> 00:08:38.170
そう言ってくれると思ってましたよ了解

00:08:38.170 --> 00:08:42.795
では これがクラスルームの最初のコンセプトです

00:08:42.795 --> 00:08:45.420
ここには便利な GIF があります

00:08:45.420 --> 00:08:47.815
時速 50 マイルの速度制限について書かれています

00:08:47.815 --> 00:08:50.553
はい理想的なコントローラーの例が示されています

00:08:50.553 --> 00:08:53.110
車は与えたポイントに正確に移動しています

00:08:53.110 --> 00:08:56.203
角度もポイントで示されています

00:08:56.203 --> 00:08:57.280
了解どうでもいいんだけど

00:08:57.280 --> 00:08:59.487
とにかく自分の車が動いてほしいな

00:08:59.487 --> 00:09:00.880
幸運なことに必要なのは

00:09:00.880 --> 00:09:02.490
6 行のコードだけなんですよ

00:09:02.490 --> 00:09:04.240
OKこの 6 行のことですか?

00:09:04.240 --> 00:09:04.817
はい そうです

00:09:04.817 --> 00:09:09.820
この 6 行ですね了解では これを入力して どうなるか見てみましょう

00:09:09.820 --> 00:09:11.500
はいさっそくコピーしてみます

00:09:11.500 --> 00:09:14.016
これをコピーして

00:09:14.016 --> 00:09:16.630
ここに置きます

00:09:16.630 --> 00:09:22.600
END をここにします

00:09:22.600 --> 00:09:38.090
見やすいように整えます

00:09:38.090 --> 00:09:41.210
できましたでは これを見ていきます

00:09:41.210 --> 00:09:43.340
double dist_inc = 0.5 とありますが

00:09:43.340 --> 00:09:45.630
0.5 は 0.5 メートルですね

00:09:45.630 --> 00:09:49.910
はいポイントとポイントの間隔になります

00:09:49.910 --> 00:09:52.215
了解なぜ 0.5 にしているのですか?

00:09:52.215 --> 00:09:54.770
速度制限が時速 50 マイルになっているからですか?

00:09:54.770 --> 00:09:58.335
そうですね 結果 時速 50 マイルにかなり近くなりましたね

00:09:58.335 --> 00:10:01.875
了解ループを 50 回繰り返していますね?

00:10:01.875 --> 00:10:06.220
はいパスプランナーに対して 50 ポイントの固定サイズを使用しています

00:10:06.220 --> 00:10:08.570
了解next_x_vals ベクターと next_y_vals ベクターには

00:10:08.570 --> 00:10:12.630
それぞれ 50個の数値を持たせ

00:10:12.630 --> 00:10:16.160
ベクターを結合したときに合計 50 ポイントになるようにしているわけですね

00:10:16.160 --> 00:10:21.110
毎回 ちょっと変わった計算 (car_x+(dist_ inc*i)*cos(deg2rad(car_yaw)

00:10:21.110 --> 00:10:26.590
を push_back していますが これは何をしているんですか?

00:10:26.590 --> 00:10:30.110
それはちょっとしたトリガーですね 車に角度があるためです

00:10:30.110 --> 00:10:32.955
一定速度の直線で常に

00:10:32.955 --> 00:10:35.650
その角度を維持するためです

00:10:35.650 --> 00:10:36.310
了解

00:10:36.310 --> 00:10:39.920
先ほどの dist_inc を使用しているため一定速度になります

00:10:39.920 --> 00:10:43.365
了解では make して実行すると

00:10:43.365 --> 00:10:44.780
車は直線を進むわけですね?

00:10:44.780 --> 00:10:45.160
はい

00:10:45.160 --> 00:10:46.430
本当に?

00:10:46.430 --> 00:10:56.550
はい

00:10:56.550 --> 00:11:00.210
やってみましょう おっと 事前に準備しておくべきでした よし

00:11:00.210 --> 00:11:05.725
ではパスプランナーを実行してみます

00:11:05.725 --> 00:11:06.150
はい

00:11:06.150 --> 00:11:06.356
直線いいですね

00:11:06.356 --> 00:11:09.800
しかし 赤色の警告がいくつか表示されますねわかりますか?

00:11:09.800 --> 00:11:12.100
大丈夫 木は通り抜けちゃうからね 大丈夫

00:11:12.100 --> 00:11:14.660
OK 最初に

00:11:14.660 --> 00:11:19.650
車は時速 0 マイルから一瞬で 50 マイルになりました

00:11:19.650 --> 00:11:21.770
たくさんのジャークを作り出しています

00:11:21.770 --> 00:11:25.675
そうですねOK では次はどうしますか?

00:11:25.675 --> 00:11:29.465
そうですね 車線から外れないように走るというのは?

00:11:29.465 --> 00:11:32.540
いいと思いませんか?

00:11:32.540 --> 00:11:33.830
車線から外れない いいですね

00:11:33.830 --> 00:11:36.770
では見てみましょう Frenet 座標を使用してみるというのは?

00:11:36.770 --> 00:11:37.340
いいですね

00:11:37.340 --> 00:11:41.200
今はこんな状態ですね

00:11:41.200 --> 00:11:46.440
コンセプトリストは 50 ポイントになっています

00:11:46.440 --> 00:11:48.200
このリストは 50 ポイントになっていますね

00:11:48.200 --> 00:11:49.955
しかし これは x, y 座標です

00:11:49.955 --> 00:11:53.120
代わりに s, d 座標を使うというのはどうですか?

00:11:53.120 --> 00:11:58.845
OK やってみましょう

00:11:58.845 --> 00:12:05.055
新しい xy 座標をベクターにプッシュして

00:12:05.055 --> 00:12:08.690
車線から外れないように走行させます

00:12:08.690 --> 00:12:13.230
そうですね車線を外れないよう走行させる場合に Frenet は非常に便利です

00:12:13.230 --> 00:12:19.110
了解こんな感じかな double next_s それから get で

00:12:19.110 --> 00:12:20.840
あるいは double ごめん

00:12:20.840 --> 00:12:23.290
cars_s で開始できますよ

00:12:23.290 --> 00:12:24.560
OK了解

00:12:24.560 --> 00:12:28.340
では double getXY

00:12:28.340 --> 00:12:34.330
getXY はもう少しあとで使います

00:12:34.330 --> 00:12:35.130
了解

00:12:35.130 --> 00:12:40.460
getXY は実際 next_s next_d を使用します

00:12:40.460 --> 00:12:49.169
了解では car_s+i*dist_inc

00:12:49.169 --> 00:12:53.310
car_s で特定の

00:12:53.310 --> 00:12:55.560
s 座標と Frenet 座標を得ます

00:12:55.560 --> 00:12:57.150
そして このループを繰り返して

00:12:57.150 --> 00:13:01.390
毎回 別の dist_inc に進んでいきますそうですよね?

00:13:01.390 --> 00:13:05.430
はい ただし i だけではなく i+1 にしてください

00:13:05.430 --> 00:13:05.431
どうしてですか?

00:13:05.431 --> 00:13:08.955
i+1 にしないと 最初のポイントが現在の車の位置になるので

00:13:08.955 --> 00:13:10.730
遷移していきません

00:13:10.730 --> 00:13:11.180
了解

00:13:11.180 --> 00:13:13.505
停止したままになってしまうんですね

00:13:13.505 --> 00:13:17.203
了解i+1 にします

00:13:17.203 --> 00:13:19.320
OK

00:13:19.320 --> 00:13:23.400
そうですねnext_d はどうしますか?

00:13:23.400 --> 00:13:27.748
double next_d

00:13:27.748 --> 00:13:30.585
私の記憶が正しければ

00:13:30.585 --> 00:13:32.532
真ん中の車線にいましたよね

00:13:32.532 --> 00:13:37.720
ウェイポイントは道路中央の黄色い二重線から測定されます

00:13:37.720 --> 00:13:41.310
とすると ウェイポイントから 1.5 車線のあたりにいるということですね?

00:13:41.310 --> 00:13:42.480
はい そのとおりです

00:13:42.480 --> 00:13:47.440
クラスルームで車線の幅は 4 メートルと読み上げたと思います

00:13:47.440 --> 00:13:52.880
ですから ウェイポイントから 1.5 車線ということは

00:13:52.880 --> 00:13:56.120
1.5 x 4 メートル = 6 になります

00:13:56.120 --> 00:13:56.180
はい

00:13:56.180 --> 00:13:58.290
では 6 を設定しますね

00:13:58.290 --> 00:14:00.440
はい この数値が非常に役に立ちます

00:14:00.440 --> 00:14:04.890
一定の車線 d_cons に留まらせておくことができます

00:14:04.890 --> 00:14:06.840
わかりましたOK

00:14:06.840 --> 00:14:12.160
これで x, y のベクターを作成する準備ができました

00:14:12.160 --> 00:14:12.670
了解

00:14:12.670 --> 00:14:15.330
getXY 関数がここで役に立ちます

00:14:15.330 --> 00:14:15.810
了解

00:14:15.810 --> 00:14:17.705
ベクターですね

00:14:17.705 --> 00:14:18.955
はい 戻ってちょっと見てみます

00:14:18.955 --> 00:14:22.240
ベクター getXY 関数のシグネチャ―を忘れてしまいました

00:14:22.240 --> 00:14:22.630
大丈夫ですよ

00:14:22.630 --> 00:14:24.364
上へ 上へスクロール

00:14:24.364 --> 00:14:29.970
していき getXY を見つけます

00:14:29.970 --> 00:14:31.717
getXY は s

00:14:31.717 --> 00:14:32.910
d をとり maps_s

00:14:32.910 --> 00:14:36.865
maps_x maps_y をとって ベクター double に渡すのですね

00:14:36.865 --> 00:14:38.720
はい その 2 つの double を見ました

00:14:38.720 --> 00:14:40.380
はい X と Y です

00:14:40.380 --> 00:14:42.520
X が 1 つ Y が 1 つですね OK

00:14:42.520 --> 00:14:43.398
では やってみましょう

00:14:43.398 --> 00:14:54.080
ですから vector&amp;lt;double&amp;gt;

00:14:54.080 --> 00:15:02.690
xy = getXY

00:15:02.690 --> 00:15:11.630
(next_s, next_d, maps_s, maps_

00:15:11.630 --> 00:15:16.252
当然 すべて違うものを呼び出すので maps_s ではないですよね

00:15:16.252 --> 00:15:17.930
トリッキーですね

00:15:17.930 --> 00:15:21.818
はい短縮形でしたね

00:15:21.818 --> 00:15:24.150
そこにあります map_waypoints_s

00:15:24.150 --> 00:15:25.940
どこだろう

00:15:25.940 --> 00:15:27.390
195 行目

00:15:27.390 --> 00:15:30.020
宣言したところを見ています

00:15:30.020 --> 00:15:32.343
map_waypoints_x

00:15:32.343 --> 00:15:36.940
map_waypoints_y と maps_waypoints_s と宣言していますOK

00:15:36.940 --> 00:15:40.340
関数は短縮ハンドルを使用していました

00:15:40.340 --> 00:15:51.800
了解map_waypoints_s

00:15:51.800 --> 00:16:01.742
map_waypoints_x map_waypoints_y

00:16:01.742 --> 00:16:06.420
OK これで X と Y がわかりました

00:16:06.420 --> 00:16:07.400
素晴らしい

00:16:07.400 --> 00:16:11.895
ここでプッシュします next_x_vals は

00:16:11.895 --> 00:16:16.725
xy の 1 番目の要素になり next y_vals が

00:16:16.725 --> 00:16:23.280
2 番目の要素になります

00:16:23.280 --> 00:16:25.310
(xy[1])

00:16:25.310 --> 00:16:26.200
はい

00:16:26.200 --> 00:16:28.650
これを保存します

00:16:28.650 --> 00:16:30.493
ここまでは問題ありませんね

00:16:30.493 --> 00:16:32.190
次は make ですよね

00:16:32.190 --> 00:16:39.480
ああ ドキドキします

00:16:39.480 --> 00:16:41.190
OKpath_planning

00:16:41.190 --> 00:16:44.970
よし 実行してみましょう

00:16:44.970 --> 00:16:45.860
やってみましょう

00:16:45.860 --> 00:16:49.670
今回は車線内で走行してくれることを期待しています

00:16:49.670 --> 00:16:51.050
車線内を走行しています

00:16:51.050 --> 00:16:54.490
まだ赤い表示は出ますが 車線内を走行しています

00:16:54.490 --> 00:16:57.135
はい そうなんです 何が起きているのか説明しますね

00:16:57.135 --> 00:17:01.273
車線内に留まらせるためだけにコードを書いたので それほど行数は多くありませんでしたが

00:17:01.273 --> 00:17:05.400
ポイントの表示がかなり雑です

00:17:05.400 --> 00:17:07.040
getXY 関数にかなり依存しているので

00:17:07.040 --> 00:17:14.075
境界の問題以外はうまく動いています

00:17:14.075 --> 00:17:23.345
地図は少量のウェイポイントで構成されているため こうしたコーナーや線分ができます

00:17:23.345 --> 00:17:26.900
こうしたコーナーでは ポイントが集まって

00:17:26.900 --> 00:17:30.250
加速とジャークの原因になります

00:17:30.250 --> 00:17:32.200
わかりました制限速度を違反しているようです

00:17:32.200 --> 00:17:34.790
これは 制限速度が時速 55 マイルなのに 私たちは

00:17:34.790 --> 00:17:38.015
まだ 0.5 を使っているためです

00:17:38.015 --> 00:17:40.650
0.4 にすれば修正できますが

00:17:40.650 --> 00:17:42.890
それを試してみましょう

00:17:42.890 --> 00:17:45.410
どうやら他の車にかなり嫌がらせをしているみたいですしね

00:17:45.410 --> 00:17:48.300
運転はうまくないみたいですね

00:17:48.300 --> 00:17:52.834
OK では見ていきましょう

00:17:52.834 --> 00:18:01.320
距離の増分を 0.3 あたりに短くしたら

00:18:01.320 --> 00:18:03.680
制限速度違反の問題を解決できますか?

00:18:03.680 --> 00:18:08.285
平均速度の役に立つでしょう

00:18:08.285 --> 00:18:10.190
かなり低くすべきですが

00:18:10.190 --> 00:18:12.650
まだ時間もありますし コーナーの問題もあります

00:18:12.650 --> 00:18:15.530
コーナーではポイントが集まって

00:18:15.530 --> 00:18:18.080
その転換時に間隔が少しおかしくなります

00:18:18.080 --> 00:18:22.645
これは正確には直線ではないためです

00:18:22.645 --> 00:18:24.945
わかりました平均速度がかなり遅くなりました

00:18:24.945 --> 00:18:26.920
現在 時速 33 マイルで走行しています

00:18:26.920 --> 00:18:27.560
はい

00:18:27.560 --> 00:18:30.405
また それほど頻繁に制限速度を違反しているわけでもないのに

00:18:30.405 --> 00:18:34.100
ときどき 制限速度を違反していると警告されます

00:18:34.100 --> 00:18:38.385
はい 警告はコーナーのときに見えます

00:18:38.385 --> 00:18:40.535
ポイントは ほとんどの部分で

00:18:40.535 --> 00:18:43.875
このエッジを除いて すべてうまく間隔をとっているようです

00:18:43.875 --> 00:18:48.636
了解つまり 車は車線内をゆっくり走行しているのに

00:18:48.636 --> 00:18:53.740
屈折か所があって その屈折か所で突然 ジャークになり

00:18:53.740 --> 00:18:55.400
また 制限速度違反も起こしてしまうということですね

00:18:55.400 --> 00:18:59.120
ここで必要なことはパスを滑らかにすることです

00:18:59.120 --> 00:19:01.300
パスを滑らかにする必要がある

00:19:01.300 --> 00:19:03.020
トラジェクトリーを生成するレッスンにおいて、ジャークを最小化するレッスンを行いました。

00:19:03.020 --> 00:19:10.325
角度が 近いけれど現在の地点より後ろにあるウェイポイントではなく

00:19:10.325 --> 00:19:12.800
しかし それはクラスルームで見ました

00:19:12.800 --> 00:19:14.720
スプラインについて触れていましたよね

00:19:14.720 --> 00:19:17.330
スプラインライブラリという素晴らしいライブラリがあり

00:19:17.330 --> 00:19:20.205
その利点を利用することができます

00:19:20.205 --> 00:19:23.000
ウェイポイントに合う多項式を使用する MPC など 前回のプロジェクトで行ったことと

00:19:23.000 --> 00:19:26.150
それほどかけ離れているわけではありません

00:19:26.150 --> 00:19:26.930
OK

00:19:26.930 --> 00:19:29.330
スプラインには多項式に勝る利点があります

00:19:29.330 --> 00:19:32.375
スプラインを使用すると必ずすべてのポイントを通過します

00:19:32.375 --> 00:19:38.130
多項式の関数の方が手間がかかります

00:19:38.130 --> 00:19:43.300
了解これがクラスルームのスプラインライブラリです

00:19:43.300 --> 00:19:45.620
大学時代

00:19:45.620 --> 00:19:48.945
数値解析の全クラスをとったのを憶えています

00:19:48.945 --> 00:19:52.110
私の記憶では その 3 分の 1 がスプラインについてでした

00:19:52.110 --> 00:19:52.940
そうだったんですね

00:19:52.940 --> 00:19:56.120
スプラインを計算する変な方法があって

00:19:56.120 --> 00:19:59.096
ポイントを通過する区分的関数で計算するんですよね

00:19:59.096 --> 00:20:02.875
多項式フィッティングのようなものだけれど

00:20:02.875 --> 00:20:05.240
すべてのポイントを通過するという点と

00:20:05.240 --> 00:20:08.120
滑らかなポイント遷移が確実に得られるという点が多項式フィッティングと異なるんですよね

00:20:08.120 --> 00:20:10.240
そうです 第 1 および第 2 微分係数です

00:20:10.240 --> 00:20:13.160
そうですねなぜ 多項式フィッティングではなくスプラインを使うのですか?

00:20:13.160 --> 00:20:19.290
ライブラリがここに用意されているため 私たちとって非常に楽なんですね

00:20:19.290 --> 00:20:20.690
了解誰かがコードを書いたので

00:20:20.690 --> 00:20:23.990
多項式フィッティングではなくスプラインを使用するということですね

00:20:23.990 --> 00:20:24.860
シングルヘッダーファイルです

00:20:24.860 --> 00:20:26.065
シングルヘッダーファイル

00:20:26.065 --> 00:20:29.425
OKここにヘッダーファイルがあります これをダウンロードします

00:20:29.425 --> 00:20:32.110
たしか 既にダウンロードしたと思います

00:20:32.110 --> 00:20:37.037
ソースファイルを見てみましょう

00:20:37.037 --> 00:20:40.360
ソース スプライン

00:20:40.360 --> 00:20:42.568
ありました

00:20:42.568 --> 00:20:45.690
ここまできたら

00:20:45.690 --> 00:20:51.470
コードの上の方の include リストにスプラインを追加する必要があります

00:20:51.470 --> 00:20:53.730
そうです include spline.h です

00:20:53.730 --> 00:20:55.128
了解

00:20:55.128 --> 00:20:57.870
けれど 多項式フィッティングを使用することもできるんですよ

00:20:57.870 --> 00:21:01.230
パスプランナーを構築する場合はかなり自由なんです

00:21:01.230 --> 00:21:04.190
OKでも 私は誰かが自分のために書いてくれたコードがいいです

00:21:04.190 --> 00:21:05.970
はい 親切ですよね

00:21:05.970 --> 00:21:09.320
では見てみることにしますspines.h がここのどこかにありますか?

00:21:09.320 --> 00:21:11.950
ありません インクルードする必要があります

00:21:11.950 --> 00:21:14.417
OK #include

00:21:14.417 --> 00:21:17.611
spline.h だったか splines.h だったか覚えていますか?

00:21:17.611 --> 00:21:20.888
spline.h だったと思います

00:21:20.888 --> 00:21:33.110
Spline.h OKbash 履歴を消さなければよかった

00:21:33.110 --> 00:21:35.510
ll_source_spline.h OK これで spline.h をインクルードしました

00:21:35.510 --> 00:21:40.475
spline.h の使用目的は シミュレーターで車が走行する

00:21:40.475 --> 00:21:46.115
ガタガタしたパスを滑らかにすることです

00:21:46.115 --> 00:21:49.676
はいとても良いソリューションだと思うのですが

00:21:49.676 --> 00:21:52.900
私だったら少し違う方法を試してみます

00:21:52.900 --> 00:21:54.000
何を試すのですか?

00:21:54.000 --> 00:21:58.150
ポイントを作ろうと思います

00:21:58.150 --> 00:22:01.130
2 つか 3 つだけで 間隔をかなり広くとります

00:22:01.130 --> 00:22:02.820
おそらく 30 メートルくらいかな

00:22:02.820 --> 00:22:05.480
次にスプラインを使ってフィットさせて

00:22:05.480 --> 00:22:09.030
そのスプラインの中にポイントを入れます

00:22:09.030 --> 00:22:11.340
了解

00:22:11.340 --> 00:22:13.340
OKでは やってみましょう

00:22:13.340 --> 00:22:17.110
OKこれを行うコードを送っておきましたよ

00:22:17.110 --> 00:22:22.900
え そうなんですかOKそちらのファイルに切り替えます

00:22:22.900 --> 00:22:30.375
確かソースディレクトリの aaron.cpp に保存したと思います

00:22:30.375 --> 00:22:41.390
なんで cd しようとしちゃったんだろう cp ../src/aaron.cpp

00:22:41.390 --> 00:22:43.860
コードを main にコピーします

00:22:43.860 --> 00:22:45.908
これで main.cpp ファイルにコードがコピーされました

00:22:45.908 --> 00:22:49.840
spline.h も既にすべてに含ませています

00:22:49.840 --> 00:22:53.045
OKずいぶん 先に行っていますね

00:22:53.045 --> 00:22:56.760
OKスクロールダウンしていきます

00:22:56.760 --> 00:23:00.760
どのようになっているのか説明してもらえますか

00:23:00.760 --> 00:23:01.520
はい もちろんです

00:23:01.520 --> 00:23:04.570
...TODO はどこかな 検索してみましょう

00:23:04.570 --> 00:23:05.280
もうすぐです int main まできたから

00:23:05.280 --> 00:23:06.960
 あと少し

00:23:06.960 --> 00:23:08.670
もうそこです

00:23:08.670 --> 00:23:14.130
OK最後に行っていたこと行い すべての地図のウェイポイントを収集しています

00:23:14.130 --> 00:23:15.823
見てみましょう

00:23:15.823 --> 00:23:17.220
if telemetry があって

00:23:17.220 --> 00:23:19.620
一部 コードがコメントされています

00:23:19.620 --> 00:23:21.135
はい これについては後で説明します

00:23:21.135 --> 00:23:22.440
OK

00:23:22.440 --> 00:23:25.965
では ここではできるだけシンプルにしていきます

00:23:25.965 --> 00:23:29.280
車線内を走行すること

00:23:29.280 --> 00:23:33.360
一定の速度で走行すること 滑らかに走行することがここでの目的です

00:23:33.360 --> 00:23:33.880
OK

00:23:33.880 --> 00:23:35.970
速度制限およびジャーク制限に違反しないこと

00:23:35.970 --> 00:23:37.880
了解ここでは 何を行っているのですか?

00:23:37.880 --> 00:23:42.530
まず初めに

00:23:42.530 --> 00:23:46.430
ここで 2 つの変数を指定します

00:23:46.430 --> 00:23:47.450
OK

00:23:47.450 --> 00:23:49.805
2 つの変数は車線です

00:23:49.805 --> 00:23:52.165
車線 1 から始めます

00:23:52.165 --> 00:23:55.955
これを使うと必要な時に素早く別の車線に切り替えることができます

00:23:55.955 --> 00:23:58.050
車線 0 は左端の車線です

00:23:58.050 --> 00:23:59.805
車線 1 は真ん中の車線 車線 2 は右端の車線ですね?

00:23:59.805 --> 00:24:02.520
はい そのとおりです次に

00:24:02.520 --> 00:24:05.440
参照速度を伝えます

00:24:05.440 --> 00:24:08.965
ここでは できるだけ制限速度に近い速度で走行させようと思っています

00:24:08.965 --> 00:24:12.300
制限速度は超えないようにしたいので 49.5 にします

00:24:12.300 --> 00:24:13.825
OK

00:24:13.825 --> 00:24:19.360
ここから先の変数は少し飛ばして

00:24:19.360 --> 00:24:22.660
prev_size を設定します

00:24:22.660 --> 00:24:25.535
このサイズは前のパスサイズです

00:24:25.535 --> 00:24:27.220
この前のポイントリストを使用します

00:24:27.220 --> 00:24:30.580
変更する場合に非常に便利です

00:24:30.580 --> 00:24:33.685
これは車が追いかけていた最後のパスですね?

00:24:33.685 --> 00:24:38.260
このあと さらにポイントを計算し これらを行うわけですね

00:24:38.260 --> 00:24:42.400
そうです実際にはシミュレーターで前のパスの情報が提示されます

00:24:42.400 --> 00:24:43.770
OK

00:24:43.770 --> 00:24:47.410
では スクロールダウンします

00:24:47.410 --> 00:24:50.260
パスは常に50 ポイントだから 50 になりますか?

00:24:50.260 --> 00:24:53.415
100 でもできますし 1,000 でもできますよ

00:24:53.415 --> 00:24:58.330
パスプランナーでは好きなだけ自由にポイントを設けることができます

00:24:58.330 --> 00:24:58.810
了解

00:24:58.810 --> 00:25:01.650
これには長所と短所があります

00:25:01.650 --> 00:25:02.000
OK

00:25:02.000 --> 00:25:06.030
1,000 で行き詰った場合に前のポイントを使用していると

00:25:06.030 --> 00:25:09.110
環境に突然の変更が発生し

00:25:09.110 --> 00:25:10.990
時間内に反応できなくなる可能性があります

00:25:10.990 --> 00:25:13.250
前のポイントで引っかかってしまうためです

00:25:13.250 --> 00:25:14.565
OK

00:25:14.565 --> 00:25:20.620
ウェイポイントの間隔をかなりとって配置すると言ったのはこのためです

00:25:20.620 --> 00:25:25.525
ですから ベクター double のリストを作って そこからビルドしようと思います

00:25:25.525 --> 00:25:29.190
また リファレンスの状態を追跡しようと思います

00:25:29.190 --> 00:25:32.110
車の現在位置か この前のパスのエンドポイント

00:25:32.110 --> 00:25:36.010
のいずれかになります

00:25:36.010 --> 00:25:38.945
このリファレンス x y yaw を定義しました

00:25:38.945 --> 00:25:41.575
x y と角度ですね

00:25:41.575 --> 00:25:45.460
前のパスサイズを確認します

00:25:45.460 --> 00:25:47.110
かなり空に近いか

00:25:47.110 --> 00:25:52.370
利用できるポイントがあるかのいずれかです

00:25:52.370 --> 00:25:53.650
空に近い場合は

00:25:53.650 --> 00:25:55.730
車の状態を使用します

00:25:55.730 --> 00:25:58.630
ここに 車の角度に対してタンジェントとなる

00:25:58.630 --> 00:26:03.510
このパスを作ろうかと思っています

00:26:03.510 --> 00:26:08.290
車の位置を探し

00:26:08.290 --> 00:26:11.620
角度に基づいて時間を戻り

00:26:11.620 --> 00:26:17.335
ポイントを 2 つ生成してそのパスがタンジェントとなるようにします

00:26:17.335 --> 00:26:22.860
開始したばかりで前のパスポイントがない場合はこうなります

00:26:22.860 --> 00:26:25.000
前のパスポイントがある場合は

00:26:25.000 --> 00:26:29.140
それが必ずタンジェントとなるよう その前のパスの最後のポイントと

00:26:29.140 --> 00:26:34.180
最後から 2 番目のポイントを使用して同じことを行います

00:26:34.180 --> 00:26:37.775
これをポイント x とポイント y に追加します

00:26:37.775 --> 00:26:42.430
また このリファレンス x とリファレンス y を

00:26:42.430 --> 00:26:46.225
前のパスの最後の要素に変更して

00:26:46.225 --> 00:26:50.800
タンジェントを使って計算します

00:26:50.800 --> 00:26:51.992
了解

00:26:51.992 --> 00:26:54.790
基本的に何をしているかというと 車が追いかけていた

00:26:54.790 --> 00:27:00.940
前のパスの最後のいくつかのポイントに注目し

00:27:00.940 --> 00:27:08.115
そのポイントを使って車の進行方向の角度を計算しているんですよね

00:27:08.115 --> 00:27:08.237
はい

00:27:08.237 --> 00:27:11.675
そうですよね?次に前のポイントのリストにそれをプッシュしているんですよね

00:27:11.675 --> 00:27:15.940
はい そのとおりですこれまでのところ x を 2 つと y を 2 つプッシュしました

00:27:15.940 --> 00:27:21.630
了解では 基本的にはこのベクターの組み合わせには 2 つのポイントがあるのですね?

00:27:21.630 --> 00:27:23.220
はい

00:27:23.220 --> 00:27:26.640
そして これが開始レファレンスです

00:27:26.640 --> 00:27:28.155
これが他のポイントです

00:27:28.155 --> 00:27:30.570
Frenet を使用しています

00:27:30.570 --> 00:27:32.863
前回 行ったことですが

00:27:32.863 --> 00:27:36.025
今回はポイントの間隔をかなり広くとっています

00:27:36.025 --> 00:27:40.106
了解ひとつの距離増分ではなく

00:27:40.106 --> 00:27:45.140
30 60 90 にしているんですね

00:27:45.140 --> 00:27:46.860
また ループして 50 ポイント作るのではなく

00:27:46.860 --> 00:27:48.830
3 ポイントだけ作っているのですね

00:27:48.830 --> 00:27:49.610
そうです

00:27:49.610 --> 00:27:49.703
OK

00:27:49.703 --> 00:27:51.860
あと 3 ポイント プッシュするのですが

00:27:51.860 --> 00:27:54.600
間隔を 0.5 メートルではなく

00:27:54.600 --> 00:27:56.120
30 メートルにしようと思います

00:27:56.120 --> 00:28:01.468
了解私は d 座標に 6 を設定しましたが あなたのコードでは 2+4*lane になっています

00:28:01.468 --> 00:28:03.100
ここの車線は 1 だから

00:28:03.100 --> 00:28:05.260
2+4*1 は 6 になるわけですね

00:28:05.260 --> 00:28:05.348
はい

00:28:05.348 --> 00:28:07.915
ただし lane の変数を変更すると走行車線も変わるのですね

00:28:07.915 --> 00:28:09.660
非常に便利です

00:28:09.660 --> 00:28:10.695
OK

00:28:10.695 --> 00:28:14.350
はいでは これらのポイントをプッシュします

00:28:14.350 --> 00:28:17.155
これは何ですか?このベクターのポイントは何になりますか?

00:28:17.155 --> 00:28:19.350
前の 2 ポイント足す

00:28:19.350 --> 00:28:25.690
30 メートルの位置 次に 60 メートル 90 メートルになるのですね?

00:28:25.690 --> 00:28:26.190
はい

00:28:26.190 --> 00:28:28.590
つまり 今回は 5 ポイントになるのですね?

00:28:28.590 --> 00:28:29.060
そのとおりです

00:28:29.060 --> 00:28:32.370
OK

00:28:32.370 --> 00:28:36.230
OKこれは実際 非常に便利なことがわかりました

00:28:36.230 --> 00:28:42.180
このローカルの車の座標への変換を行ってくれます

00:28:42.180 --> 00:28:44.965
MPC でやったことと同じようなものです

00:28:44.965 --> 00:28:48.395
それをシフトして 車または

00:28:48.395 --> 00:28:52.128
前のパスの最後のポイントが 0, 0 の起点に

00:28:52.128 --> 00:28:56.020
その角度がゼロ度になるようにします

00:28:56.020 --> 00:28:57.830
これはあとで登場します

00:28:57.830 --> 00:28:59.480
もう少し待ってください

00:28:59.480 --> 00:29:01.245
もう少し待ちます OK

00:29:01.245 --> 00:29:04.145
車がこの方向へ進んでいる場合

00:29:04.145 --> 00:29:05.888
xy 座標の方向ですね

00:29:05.888 --> 00:29:09.020
これをシフトさせる つまり車のリファレンスフレームを参照するんですね

00:29:09.020 --> 00:29:12.000
45 度ではなく直進する

00:29:12.000 --> 00:29:15.750
常に 0 度にしておくということですね

00:29:15.750 --> 00:29:17.350
計算が簡単になります

00:29:17.350 --> 00:29:19.270
計算が簡単になるんですねOK

00:29:19.270 --> 00:29:21.730
OKでは ここでその変換を行います

00:29:21.730 --> 00:29:23.330
回転のシフトです

00:29:23.330 --> 00:29:23.580
OK

00:29:23.580 --> 00:29:26.330
MPC で見たような数学です

00:29:26.330 --> 00:29:27.690
OK

00:29:27.690 --> 00:29:32.660
これは私たちが構築していたスプラインです

00:29:32.660 --> 00:29:34.000
spline に戻るんですね OK

00:29:34.000 --> 00:29:37.580
はいスプラインを定義して

00:29:37.580 --> 00:29:41.570
ポイント x とポイント y をスプラインに設定します

00:29:41.570 --> 00:29:41.770
OK

00:29:41.770 --> 00:29:46.400
そしてここで

00:29:46.400 --> 00:29:51.250
前回 作業していた next_x_vals と next_y_vals をビルドしています

00:29:51.250 --> 00:29:54.055
これがパスプランナーが使用する実際のポイントです

00:29:54.055 --> 00:29:58.850
OKこの x ポイントと y ポイントのセットを 1 つ設定しました

00:29:58.850 --> 00:30:05.000
もう 1 セットあり そちらは現時点では空白で将来のパスをそこにビルドする必要があるわけですね

00:30:05.000 --> 00:30:08.395
はいこれをすべて設定します

00:30:08.395 --> 00:30:12.020
前のパスについていろいろと話しましたが ここでそれが登場します

00:30:12.020 --> 00:30:12.620
OK

00:30:12.620 --> 00:30:15.590
前のパスからのポイントがある場合は

00:30:15.590 --> 00:30:19.640
そのポイントをそのままパスプランナーに追加します

00:30:19.640 --> 00:30:19.835
了解

00:30:19.835 --> 00:30:21.905
これは遷移の際 役に立ちます

00:30:21.905 --> 00:30:28.445
毎回 ゼロからパスを再作成するのではなく

00:30:28.445 --> 00:30:33.710
ポイントを追加して 残っているものを再利用することができます

00:30:33.710 --> 00:30:36.320
了解では 前のパスが 50 ポイントなら

00:30:36.320 --> 00:30:41.105
常に 50 ポイントになるわけですね?

00:30:41.105 --> 00:30:44.270
はいそのとおりです

00:30:44.270 --> 00:30:47.760
50-previous_path_x.size です

00:30:47.760 --> 00:30:51.162
了解この 50-previous_path_x.size は常に 0 になるとは限らないのですか?

00:30:51.162 --> 00:30:53.930
previous_path_x.size は 50 ですか?

00:30:53.930 --> 00:30:58.735
前のパスサイズは 50 より少なくなります

00:30:58.735 --> 00:31:00.560
反復を実行しているとして

00:31:00.560 --> 00:31:02.485
50 ポイントを生成します

00:31:02.485 --> 00:31:05.105
おそらくシミュレーターはその 3 ポイントを走行します

00:31:05.105 --> 00:31:09.757
ですから 47 ポイント残っていて それが次回 報告されます

00:31:09.757 --> 00:31:11.300
だから 47 ポイント

00:31:11.300 --> 00:31:16.700
previous_path_x. または previous_path_x はフルパスではなく

00:31:16.700 --> 00:31:18.725
パックマンのナゲットのように

00:31:18.725 --> 00:31:23.020
車がすべてのポイントを消費してしまうわけではないんですね

00:31:23.020 --> 00:31:23.810
はい そのとおりです

00:31:23.810 --> 00:31:27.320
車が前回 50 ポイントのうち 3 ポイントを消費したとすると

00:31:27.320 --> 00:31:30.160
前のパスには 47 ポイントが残っているわけですね

00:31:30.160 --> 00:31:32.090
だから 生成する必要があるのは 3 ポイントだけなんですね

00:31:32.090 --> 00:31:37.950
了解また 車が 40 ポイント消費したとしたら 前のパスには 10ポイント残るということですね

00:31:37.950 --> 00:31:38.440
そのとおりです

00:31:38.440 --> 00:31:39.760
OK

00:31:39.760 --> 00:31:41.140
わかりました

00:31:41.140 --> 00:31:47.290
前のパスのポイントを足します

00:31:47.290 --> 00:31:51.370
ここから 少し面白くなってきます

00:31:51.370 --> 00:31:57.650
このポイントをスプラインに追加しましたが

00:31:57.650 --> 00:32:00.140
このポイントをスプラインに沿って

00:32:00.140 --> 00:32:04.770
配置する間隔を計算し 目的の速度にしたいわけです

00:32:04.770 --> 00:32:06.950
ちょっと待ってください どこに追加したんですか?

00:32:06.950 --> 00:32:09.450
ここですべて追加されています

00:32:09.450 --> 00:32:13.600
ptsx と ptsy を s に追加しました

00:32:13.600 --> 00:32:17.030
了解では これらは 5 アンカーポイントであって 前のパスのポイントではないのですね

00:32:17.030 --> 00:32:20.915
そのとおりです ここでは 2 セットを処理しています

00:32:20.915 --> 00:32:21.190
OK

00:32:21.190 --> 00:32:27.945
同様にするのであれば スプラインを構成するウェイポイントの間隔を広く配置し

00:32:27.945 --> 00:32:30.760
そしてパスプランニングのポイントを処理します

00:32:30.760 --> 00:32:34.365
OK1つ目のセットはわかりやすいようアンカーポイントと呼びますね 

00:32:34.365 --> 00:32:39.160
そして 2 つ目のセットは next x ファイルまたは未来のパスと呼びますね

00:32:39.160 --> 00:32:39.416
はい

00:32:39.416 --> 00:32:41.930
OKこの真ん中あたりでアンカーポイントを

00:32:41.930 --> 00:32:44.010
スプラインに追加したのですね

00:32:44.010 --> 00:32:48.560
そして未来のパスを前のパスの残りと一緒に読み込んでいます

00:32:48.560 --> 00:32:49.220
そのとおりです

00:32:49.220 --> 00:32:51.515
だから連続性が生じるわけですね

00:32:51.515 --> 00:32:55.870
そして ここでスプラインとアンカーポイントに戻ってくるわけですね これで正しいですか？

00:32:55.870 --> 00:32:56.470
はい

00:32:56.470 --> 00:32:56.830
OK

00:32:56.830 --> 00:32:59.530
このあたりで視覚資料を見てみます

00:32:59.530 --> 00:33:01.480
OK視覚資料を見てみましょう

00:33:01.480 --> 00:33:02.110
はい

00:33:02.110 --> 00:33:05.340
これがそうですか?

00:33:05.340 --> 00:33:06.280
そうです

00:33:06.280 --> 00:33:08.230
OKすごいですね自分で作ったんですか?

00:33:08.230 --> 00:33:13.002
もちろんです本物のアーティストだな

00:33:13.002 --> 00:33:17.260
これがローカル座標系内の車です

00:33:17.260 --> 00:33:17.780
OK

00:33:17.780 --> 00:33:20.100
見てわかるように 0 度です

00:33:20.100 --> 00:33:20.830
OK

00:33:20.830 --> 00:33:23.690
これはスプラインです

00:33:23.690 --> 00:33:24.090
OK

00:33:24.090 --> 00:33:28.580
ここでしたいことは これらのポイントをスプラインに沿って

00:33:28.580 --> 00:33:33.705
配置する しかも車が目的の速度で走行する間隔で配置したいわけです

00:33:33.705 --> 00:33:36.530
了解つまり 車が時速 50 マイルあるいは

00:33:36.530 --> 00:33:38.625
49.5 マイルで走行する場合

00:33:38.625 --> 00:33:41.745
ポイントを正確に正しい距離間隔で配置する必要があるわけですね

00:33:41.745 --> 00:33:42.410
そうです

00:33:42.410 --> 00:33:44.690
了解どこかに参照できる数値があるんですか?

00:33:44.690 --> 00:33:47.565
計算しないといけません

00:33:47.565 --> 00:33:51.890
OK線形化すると

00:33:51.890 --> 00:33:53.160
うまくいきました

00:33:53.160 --> 00:33:54.040
OK

00:33:54.040 --> 00:33:57.760
水平値を見つけます

00:33:57.760 --> 00:33:59.130
30 メートルとしましょう

00:33:59.130 --> 00:33:59.660
OK

00:33:59.660 --> 00:34:03.765
これでスプラインにポイントを配置する場所を計算できます

00:34:03.765 --> 00:34:08.755
この s 関数があり この関数は x のうちの f だからです

00:34:08.755 --> 00:34:12.225
スプラインに x を与えると y が得られます

00:34:12.225 --> 00:34:18.470
車から設定している目的のポイントまでの距離を計算します

00:34:18.470 --> 00:34:21.850
これが d で これが計算です

00:34:21.850 --> 00:34:22.850
OK

00:34:22.850 --> 00:34:26.250
これを n 個のピースに分けたいと思います

00:34:26.250 --> 00:34:29.645
ですから n ピース x 0.02 に

00:34:29.645 --> 00:34:34.540
なります 車は各ポイントまでそれぞれ 0.02 秒かけて走行します

00:34:34.540 --> 00:34:35.100
OK

00:34:35.100 --> 00:34:39.035
これに目的の速度をかけると

00:34:39.035 --> 00:34:40.490
d になります

00:34:40.490 --> 00:34:41.330
OKOK

00:34:41.330 --> 00:34:44.170
これが秒単位であるのに対し

00:34:44.170 --> 00:34:46.590
こちらは秒あたりのメートル単位です

00:34:46.590 --> 00:34:49.310
これが 2 番目を打ち消すのでメートルになります

00:34:49.310 --> 00:34:52.130
ピースを通過するごとメートル数が出ます

00:34:52.130 --> 00:34:53.495
すべてのピースに到達すると

00:34:53.495 --> 00:34:54.770
全距離が得られます

00:34:54.770 --> 00:34:57.785
了解それが速度になるのですね

00:34:57.785 --> 00:34:58.320
そうです

00:34:58.320 --> 00:35:03.500
最初 なんて書いてあるのかよくわからなかったのですが OKvelocity (速度) の vel なんですね?

00:35:03.500 --> 00:35:06.110
わかりましたここで覚えておくべき点は何ですか?

00:35:06.110 --> 00:35:10.115
これを行うとき

00:35:10.115 --> 00:35:12.695
n を計算することができます

00:35:12.695 --> 00:35:16.055
これは単純な三角形で

00:35:16.055 --> 00:35:19.160
その斜辺を n 個に分割するため

00:35:19.160 --> 00:35:23.150
x 軸も n 個に分割されます

00:35:23.150 --> 00:35:23.300
OK

00:35:23.300 --> 00:35:26.585
この x 値がわかれば

00:35:26.585 --> 00:35:28.280
スプラインに「この x の y 値は

00:35:28.280 --> 00:35:30.380
何になる?」と聞けばいいわけです

00:35:30.380 --> 00:35:32.090
するとポイント数が得られます

00:35:32.090 --> 00:35:33.799
スプラインに

00:35:33.799 --> 00:35:35.300
「これが x 値だよ

00:35:35.300 --> 00:35:38.715
これに該当する y 値を教えて?」と聞くんですね

00:35:38.715 --> 00:35:39.440
そのとおりです

00:35:39.440 --> 00:35:39.790
了解

00:35:39.790 --> 00:35:41.810
これを行って必要なポイント数を得て

00:35:41.810 --> 00:35:44.720
スプラインに沿った XY を得ます

00:35:44.720 --> 00:35:46.800
了解コードで見せてもらえますか?

00:35:46.800 --> 00:35:49.680
はい もちろんです

00:35:49.680 --> 00:35:50.294
OK

00:35:50.294 --> 00:35:52.605
これです

00:35:52.605 --> 00:35:55.940
水平値 30 はここです

00:35:55.940 --> 00:35:56.562
了解ここですね失礼

00:35:56.562 --> 00:35:58.920
OK

00:35:58.920 --> 00:36:01.250
話していた目的つまりターゲット

00:36:01.250 --> 00:36:04.190
スプラインにこの x 値に対する y 値を聞いています

00:36:04.190 --> 00:36:07.790
アーロン これは vim なのでマウスは使いません

00:36:07.790 --> 00:36:09.680
そのとおり次に

00:36:09.680 --> 00:36:11.510
ターゲットの距離を得ます

00:36:11.510 --> 00:36:15.770
前のパスの最後のポイント

00:36:15.770 --> 00:36:18.620
または車自体からターゲットまでの

00:36:18.620 --> 00:36:21.680
距離を計算するだけです

00:36:21.680 --> 00:36:21.920
OK

00:36:21.920 --> 00:36:25.795
x_add_on これはゼロで開始します

00:36:25.795 --> 00:36:29.390
これは 以前に行った 2 つのローカル遷移で行う必要があります

00:36:29.390 --> 00:36:30.680
起点から開始していました

00:36:30.680 --> 00:36:33.569
OKここ

00:36:33.569 --> 00:36:38.090
target_x は 30 で y 値を得ます

00:36:38.090 --> 00:36:41.990
スプラインは宣言したので ここですべきことは target_x を

00:36:41.990 --> 00:36:46.245
スプライン s に渡すだけです 上の方でスプラインを宣言していますね

00:36:46.245 --> 00:36:48.945
どの様にすればいいですか?

00:36:48.945 --> 00:36:53.470
つまり 30 を s に渡すと y 値が得られます

00:36:53.470 --> 00:36:56.040
このスプラインライブラリの使い方は非常に簡単ですよね

00:36:56.040 --> 00:36:58.740
誰かが簡単なコードを書いてくれるのがいいな

00:36:58.740 --> 00:37:03.920
スプラインに沿ってポイントを追加していきます

00:37:03.920 --> 00:37:04.730
OK

00:37:04.730 --> 00:37:07.600
前のスライドでお見せした計算です

00:37:07.600 --> 00:37:09.600
n の数を計算しています

00:37:09.600 --> 00:37:11.500
これがターゲットの距離

00:37:11.500 --> 00:37:13.270
これがリファレンス速度です

00:37:13.270 --> 00:37:17.290
2.24 で割っています これは1 時間当たりのマイル数だとお伝えしたと思いますが

00:37:17.290 --> 00:37:19.010
1 秒あたりのメートル数にしなければならないためです

00:37:19.010 --> 00:37:22.090
次にこの x ポイントを得ます

00:37:22.090 --> 00:37:24.760
x_add_on+(target_x)/N

00:37:24.760 --> 00:37:27.935
 です

00:37:27.935 --> 00:37:34.270
OK Nは図で見せてくれたものですね

00:37:34.270 --> 00:37:41.640
x ポイントは視覚資料で見た x 軸上の

00:37:41.640 --> 00:37:43.897
小さなハッシュマークですね

00:37:43.897 --> 00:37:47.605
視覚資料の x 軸です  OK  x_add_on は開始点で

00:37:47.605 --> 00:37:48.895
ゼロになります

00:37:48.895 --> 00:37:54.580
target_x を足して N で割っています これがハッシュマークの数です

00:37:54.580 --> 00:37:54.927
はい

00:37:54.927 --> 00:37:57.082
了解　OK　次に

00:37:57.082 --> 00:38:02.795
y ポイントを得るため x ポイントで得られる y ポイントを聞いています

00:38:02.795 --> 00:38:05.550
了解これで スプラインでの各ウェイポイント

00:38:05.550 --> 00:38:11.015
パール状のパックマンのナゲットみたいなやつの位置を指示し

00:38:11.015 --> 00:38:13.960
また車が適切な速度で走行するよう十分な間隔をあけて配置するよう指示しているのですね

00:38:13.960 --> 00:38:14.580
はい

00:38:14.580 --> 00:38:16.870
OKわかりました

00:38:16.870 --> 00:38:21.680
そして ここでは時速 49.5 マイルで走行させたいと思います

00:38:21.680 --> 00:38:21.930
了解

00:38:21.930 --> 00:38:23.785
このため ループさせます

00:38:23.785 --> 00:38:28.210
最後に忘れずに行わなければならないことがあります 今 ローカル座標にいるですが

00:38:28.210 --> 00:38:28.267
OK

00:38:28.267 --> 00:38:30.460
グローバル座標に戻さなければなりません

00:38:30.460 --> 00:38:32.020
基底変換のようなものですね

00:38:32.020 --> 00:38:35.000
はい以前に行ったことの逆を行います

00:38:35.000 --> 00:38:39.220
つまり ここでシフトしてから回転します

00:38:39.220 --> 00:38:40.280
OK

00:38:40.280 --> 00:38:44.170
そして 最後に これを next_x_vals と

00:38:44.170 --> 00:38:48.690
next_y_vals にプッシュバックして完了です

00:38:48.690 --> 00:38:51.360
やりましたね 前よりいい走りになると思いますか?かなり作業が多かったですよね

00:38:51.360 --> 00:38:53.410
そうですね やってみましょう

00:38:53.410 --> 00:38:56.130
OK

00:39:03.400 --> 00:39:05.970
たしか

00:39:05.970 --> 00:39:08.113
保存したよな

00:39:08.113 --> 00:39:10.250
あれ 保存し忘れたかな?

00:39:10.250 --> 00:39:11.030
わかりません

00:39:11.030 --> 00:39:12.610
まあ やってみましょう

00:39:12.610 --> 00:39:14.310
すぐにわかるでしょう

00:39:14.310 --> 00:39:17.050
たぶんほら 出てきました

00:39:17.050 --> 00:39:18.167
出てきましたねやりました

00:39:18.167 --> 00:39:20.835
少し滑らかになりましたね

00:39:20.835 --> 00:39:23.740
赤色のあれが冒頭に出てましたね 最大ジャークを超えていました

00:39:23.740 --> 00:39:30.580
はい 車は時速 0 マイルで開始 0.02 秒で約 50 マイルに達したためです

00:39:30.580 --> 00:39:33.700
了解では 絶対に 50 マイル以上は出ないようにしないといけないですね

00:39:33.700 --> 00:39:34.413
はい

00:39:34.413 --> 00:39:41.520
OKこの車は私がいつも運転しているやつじゃないからね

00:39:41.520 --> 00:39:41.825
はい

00:39:41.825 --> 00:39:43.865
OKでは 衝突するとどうなりますか

00:39:43.865 --> 00:39:45.550
衝突しますか 衝突したら停止しますか?

00:39:45.550 --> 00:39:48.610
現在のところ 他の車両が前に出現するかはチェックしていません

00:39:48.610 --> 00:39:50.890
だから 後ろから追突します

00:39:50.890 --> 00:39:51.970
うわぁいやいや

00:39:51.970 --> 00:39:53.530
見れますか?

00:39:53.530 --> 00:39:55.760
はい衝突の赤字が表示されます

00:39:55.760 --> 00:39:57.970
OKいくつか問題を発見したので ここで解決していきます

00:39:57.970 --> 00:40:01.952
1 つ目はコールドスタートです

00:40:01.952 --> 00:40:05.270
ゴールドスタートで加速パラメーターを突破しています

00:40:05.270 --> 00:40:07.830
2 つ目は前方に現れる車両のチェックです

00:40:07.830 --> 00:40:08.020
はい

00:40:08.020 --> 00:40:09.815
では どう処理したらいいですかね?

00:40:09.815 --> 00:40:11.170
第一に

00:40:11.170 --> 00:40:13.340
前方に出現した車に追突しないというのがいいですね

00:40:13.340 --> 00:40:14.600
OKいいですね

00:40:14.600 --> 00:40:17.830
追突を避けられるかやってみましょう

00:40:17.830 --> 00:40:20.787
OK

00:40:20.787 --> 00:40:24.040
これを見てください 一部のコードを

00:40:24.040 --> 00:40:25.480
コメントアウトしていたのを憶えていますか

00:40:25.480 --> 00:40:25.860
はい

00:40:25.860 --> 00:40:27.120
そのコードの出番です

00:40:27.120 --> 00:40:30.000
コメントアウトされていたコードについてはすっかり忘れていました

00:40:30.000 --> 00:40:38.620
はいセンサーフュージョンについて説明します

00:40:38.620 --> 00:40:39.898
OK

00:40:39.898 --> 00:40:41.870
センサーフュージョンについてですね

00:40:41.870 --> 00:40:48.480
シミュレーターは路上の他のすべての車両を含むリストを報告します

00:40:48.480 --> 00:40:55.590
これら他の車両はすべて d, x, y, vx, vy の値に s を持っています

00:40:55.590 --> 00:40:55.753
OK

00:40:55.753 --> 00:41:00.120
それらを使って他の車両の位置や

00:41:00.120 --> 00:41:04.320
走行速度を計算し それによって私たちの車にどのような動きをさせるか計算します

00:41:04.320 --> 00:41:04.960
OK

00:41:04.960 --> 00:41:11.630
前方に出現する車両への追突を避ける場合

00:41:11.630 --> 00:41:13.610
このセンサーフュージョンのリストを使用して

00:41:13.610 --> 00:41:19.245
私たちの車が走行している車線に他の車がいるかどうかをチェックする必要があります

00:41:19.245 --> 00:41:21.500
次に その車との距離を計算します

00:41:21.500 --> 00:41:21.714
OK

00:41:21.714 --> 00:41:23.540
距離が近すぎる場合は何らかのアクションを起こします

00:41:23.540 --> 00:41:24.320
OK

00:41:24.320 --> 00:41:30.300
それをこれからやっていきます

00:41:30.300 --> 00:41:31.880
前のサイズまたは前のパスサイズを

00:41:31.880 --> 00:41:34.990
見て 作業するポイントがあれば

00:41:34.990 --> 00:41:37.785
car_s を変更します これは

00:41:37.785 --> 00:41:41.550
前のパスのラップポイント s を表しています

00:41:41.550 --> 00:41:41.806
OK

00:41:41.806 --> 00:41:45.135
これを Frenet で行おうと思います

00:41:45.135 --> 00:41:48.735
こうした論理の作業を行う場合 Frenet で作業する方が簡単です

00:41:48.735 --> 00:41:52.400
OKわかりました では やってみせてください

00:41:52.400 --> 00:41:55.290
OKたとえば

00:41:55.290 --> 00:41:58.190
ここの d 値に注目してください

00:41:58.190 --> 00:42:02.550
d 他の車がどの車線にいるかを考えてみます

00:42:02.550 --> 00:42:03.768
了解

00:42:03.768 --> 00:42:05.235
センサーフュージョンを引っ張ってくるわけですね

00:42:05.235 --> 00:42:09.963
どのベクターでしたっけ?

00:42:09.963 --> 00:42:12.810
double のベクターです

00:42:12.810 --> 00:42:18.300
了解そして 外側のベクターは

00:42:18.300 --> 00:42:21.515
道路上の各車両のパラメーターリストを格納していて

00:42:21.515 --> 00:42:23.640
内側のベクターがその各パラメーターになるわけですね

00:42:23.640 --> 00:42:28.435
sensor_fusion[i] は道路上の if の車になるんですね?

00:42:28.435 --> 00:42:30.700
はいまた readme にも 異なるデータ

00:42:30.700 --> 00:42:35.100
すべてにアクセスする方法を記述したこのテンプレートがあります

00:42:35.100 --> 00:42:39.453
了解sensor_fusion[i][6] は

00:42:39.453 --> 00:42:42.180
道路上を走行する if の車の

00:42:42.180 --> 00:42:45.045
6 番目の値になるということですね

00:42:45.045 --> 00:42:49.560
6 番目の値は Frenet 座標の d 値になるのではないですか

00:42:49.560 --> 00:42:51.050
はい 最終的に d 値になります

00:42:51.050 --> 00:42:54.255
OKd 値があって

00:42:54.255 --> 00:42:56.600
これらのすべての車両に 4 ループを実行します

00:42:56.600 --> 00:42:57.810
基本的には それぞれの車両に対して

00:42:57.810 --> 00:43:03.210
その車両の d 値によってループ内のコードのブロックを開始するのですね

00:43:03.210 --> 00:43:03.737
そうです

00:43:03.737 --> 00:43:04.100
OK

00:43:04.100 --> 00:43:06.940
d 値はその車両が走行している車線を示します

00:43:06.940 --> 00:43:07.473
了解

00:43:07.473 --> 00:43:08.580
この場合 車両が

00:43:08.580 --> 00:43:10.380
私たちの車が走行する車線にいるか いないかです

00:43:10.380 --> 00:43:11.680
了解

00:43:11.680 --> 00:43:17.975
これが私たちの車線です そして その車両がこの範囲内にいるかどうかを確認しようとしています

00:43:17.975 --> 00:43:23.000
d の値が 2+4*lane+2 より小さいかどうか

00:43:23.000 --> 00:43:27.755
また 2+4*lane-2 より大きいかどうかを確認します

00:43:27.755 --> 00:43:30.770
範囲に +2 と -2 の差があります

00:43:30.770 --> 00:43:33.815
これは各車線が 4 メートルのためです

00:43:33.815 --> 00:43:36.605
たとえば その車両が

00:43:36.605 --> 00:43:37.940
中央の車線にいないかどうか

00:43:37.940 --> 00:43:40.690
つまり 4 から 8 の間にいないか確認しています

00:43:40.690 --> 00:43:44.782
了解つまり 6 の値を指定することもできるけれど そうすると

00:43:44.782 --> 00:43:47.060
認識できるのは真ん中の車線にいる車両のみになるわけですね

00:43:47.060 --> 00:43:47.890
はい

00:43:47.890 --> 00:43:52.060
2+4*lane の値を指定すると

00:43:52.060 --> 00:43:55.705
いずれの車線にいても認識できるけれど 車両がその車線の中央にいる場合のみになるわけですね

00:43:55.705 --> 00:43:59.099
了解車両がその車線にいるけれど中心を外れている場合

00:43:59.099 --> 00:44:02.980
このように範囲を使って車両の位置を認識する必要があるということですね

00:44:02.980 --> 00:44:05.130
必要に応じて狭いカーブにすることもできます

00:44:05.130 --> 00:44:05.252
必要に応じて狭くすることもできるのですね

00:44:05.252 --> 00:44:06.830
はい

00:44:06.830 --> 00:44:09.445
まいった すごい勢いで進みますね

00:44:09.445 --> 00:44:12.133
車両が自分の車線にいる場合は

00:44:12.133 --> 00:44:15.220
その車両の速度を確認します

00:44:15.220 --> 00:44:16.130
OK

00:44:16.130 --> 00:44:18.505
3 番目と 4 番目の要素になる

00:44:18.505 --> 00:44:21.110
vx と vy から引っ張ってきて

00:44:21.110 --> 00:44:22.850
速度をチェックします

00:44:22.850 --> 00:44:26.290
そして速度の大きさを計算します

00:44:26.290 --> 00:44:29.581
OK x の速度と y の速度を引っ張てきて

00:44:29.581 --> 00:44:35.873
距離式を実行するんですね

00:44:35.873 --> 00:44:37.290
ん 少し違うかな

00:44:37.290 --> 00:44:39.440
距離式で得られるのは

00:44:39.440 --> 00:44:40.950
そう そのベクターの大きさですね

00:44:40.950 --> 00:44:41.693
このベクターの大きさを得るのですね

00:44:41.693 --> 00:44:44.330
vx があり そのベクターの x と y の成分はありますが

00:44:44.330 --> 00:44:47.210
ここではその大きさを得ようとしています

00:44:47.210 --> 00:44:48.995
わかりました

00:44:48.995 --> 00:44:54.290
check_car_s = sensor_fusion[i][5] を行います

00:44:54.290 --> 00:44:58.020
この 5 番目の要素と車の s 値は

00:44:58.020 --> 00:44:59.810
車両と私たちの車との距離がかなり近いのかどうかを

00:44:59.810 --> 00:45:01.970
識別する際に非常に重要になります

00:45:01.970 --> 00:45:03.500
了解ここで各車両に対して

00:45:03.500 --> 00:45:06.560
その車両が私たちの車が走行している車線にいる場合

00:45:06.560 --> 00:45:09.170
さらにその車両の速度と

00:45:09.170 --> 00:45:13.705
Frenet 座標での座標を取得します

00:45:13.705 --> 00:45:14.520
はい

00:45:14.520 --> 00:45:14.714
OK

00:45:14.714 --> 00:45:17.180
速度の部分は実際

00:45:17.180 --> 00:45:20.690
その車の今後の位置を予測する際に役立ちます

00:45:20.690 --> 00:45:22.320
OK

00:45:22.320 --> 00:45:28.040
この行は何をしているのでしょうか?

00:45:28.040 --> 00:45:31.597
check_car_s+= の行ですか?

00:45:31.597 --> 00:45:31.842
はい

00:45:31.842 --> 00:45:33.553
前のポイントを使用すると

00:45:33.553 --> 00:45:36.920
s 値を時間内に投影させることができます

00:45:36.920 --> 00:45:39.935
OKわかりました

00:45:39.935 --> 00:45:42.590
なぜ s 値を投影させるのですか?

00:45:42.590 --> 00:45:47.120
前のパスのポイントを使用する場合

00:45:47.120 --> 00:45:50.090
そこにはまだ到達していないからです

00:45:50.090 --> 00:45:50.230
OK 了解

00:45:50.230 --> 00:45:54.880
私たちの車はそれより少し手前にいます

00:45:54.880 --> 00:45:55.174
OK

00:45:55.174 --> 00:45:58.985
このため その車両が未来のどこにいるかを知りたいわけです

00:45:58.985 --> 00:46:01.325
前のパスのポイントを使用すると

00:46:01.325 --> 00:46:03.620
パスは未来を表しますが

00:46:03.620 --> 00:46:08.965
私たちは私たちの車とその他の車両の現在の位置を示すスナップショットを見ています

00:46:08.965 --> 00:46:11.315
このため 前のパスの観点から

00:46:11.315 --> 00:46:14.985
その他の車両の未来の位置を知りたいわけです

00:46:14.985 --> 00:46:15.680
OK

00:46:15.680 --> 00:46:16.140
はい

00:46:16.140 --> 00:46:18.720
わかりました未来の車両の位置を探しているんですね

00:46:18.720 --> 00:46:19.275
はい

00:46:19.275 --> 00:46:20.400
OK

00:46:20.400 --> 00:46:24.080
ここでも少し論理を展開して

00:46:24.080 --> 00:46:29.220
私たちの車 s が他の車両 s に近づいていないかどうかをチェックします

00:46:29.220 --> 00:46:35.290
車両が私たちの前にいるときに check_car_s が car_s より大きく

00:46:35.290 --> 00:46:39.080
またそのギャップが 30 メートル未満の場合

00:46:39.080 --> 00:46:42.905
措置を講じる必要があります

00:46:42.905 --> 00:46:46.070
了解未来で 私たちの車と特定の車両との

00:46:46.070 --> 00:46:49.505
車間が 30 メートル以内になった場合は

00:46:49.505 --> 00:46:50.945
措置を講じる必要があるということですね

00:46:50.945 --> 00:46:51.650
はい

00:46:51.650 --> 00:46:52.130
了解

00:46:52.130 --> 00:46:54.305
つまり ここで論理を展開する必要があるわけですね

00:46:54.305 --> 00:46:56.315
速度を落とすといいですよね

00:46:56.315 --> 00:46:59.330
車線変更を促すフラグを設定することもできますね

00:46:59.330 --> 00:47:00.446
OK

00:47:00.446 --> 00:47:02.810
シンプルな例ですので

00:47:02.810 --> 00:47:07.960
リファレンス速度を 29.5 に設定してみようと思います

00:47:07.960 --> 00:47:10.230
OK いいですねいいですねやってみましょう

00:47:10.230 --> 00:47:14.900
了解では保存しましょう

00:47:14.900 --> 00:47:25.500
ああ 保存して

00:47:25.500 --> 00:47:26.860
なかったように思います

00:47:26.860 --> 00:47:34.320
保存し直します

00:47:34.320 --> 00:47:37.650
素晴らしいありがとう デイビッド

00:47:37.650 --> 00:47:40.300
どういたしまして

00:47:45.390 --> 00:47:56.720
OKビルドできました実行します

00:47:56.720 --> 00:47:59.735
行きますよOK

00:47:59.735 --> 00:48:04.040
OKまだ冒頭で最大ジャークを超えていますね

00:48:04.040 --> 00:48:07.580
まだコールドスタートから時速 50 マイルになりますが いいでしょう

00:48:07.580 --> 00:48:09.230
今 解決しようとしている問題ではありませんでしたから

00:48:09.230 --> 00:48:11.190
今 解決しようとしている問題は

00:48:11.190 --> 00:48:14.470
例の黄色の車両に追突する前に停止できるかということです

00:48:14.470 --> 00:48:17.740
了解衝突の警告が表示されましたね

00:48:17.740 --> 00:48:19.970
はい 見えました

00:48:19.970 --> 00:48:22.665
しかし衝突はしなかったようですね OK

00:48:22.665 --> 00:48:25.660
黄色の車両に追い付いて そのあと速度を落としたようですね

00:48:25.660 --> 00:48:25.960
はい

00:48:25.960 --> 00:48:29.820
黄色の車両が 30 メートル先または 30 メートル以内に見えたので

00:48:29.820 --> 00:48:31.385
速度を落としました

00:48:31.385 --> 00:48:33.170
はい 黄色の車両を認識しましたね

00:48:33.170 --> 00:48:37.160
私たちの車には時速 29 マイルの指示は出しましたが 速度を元に戻す指示はしていませんでした

00:48:37.160 --> 00:48:38.576
OK

00:48:38.576 --> 00:48:43.195
ということは 認識できたわけですね

00:48:43.195 --> 00:48:47.275
OKはいOK では

00:48:47.275 --> 00:48:51.030
コールドスタートの問題も解決したいのですが

00:48:51.030 --> 00:48:51.780
OK

00:48:51.780 --> 00:48:53.140
どうしたらいいですか?

00:48:53.140 --> 00:48:57.610
では そちらも見ていきましょう

00:48:57.610 --> 00:48:59.540
ここでは

00:48:59.540 --> 00:49:04.700
速度を設定するか すぐにこの車線に変更するかのいずれかの指定になります

00:49:04.700 --> 00:49:06.530
実際に行いたいと考えているのは

00:49:06.530 --> 00:49:10.790
「徐々に速度を変更できないか?」です

00:49:10.790 --> 00:49:11.855
OK

00:49:11.855 --> 00:49:15.140
たとえば 5 メートル毎秒毎秒で

00:49:15.140 --> 00:49:18.590
加速させたいとすると

00:49:18.590 --> 00:49:24.100
リファレンス速度を追加するかデクリメントさせる必要があります

00:49:24.100 --> 00:49:28.545
そのため 29.5 と指定する代わりに

00:49:28.545 --> 00:49:31.460
コメントアウトして ここに too_close を指定する

00:49:31.460 --> 00:49:34.950
フラグを設定します

00:49:34.950 --> 00:49:36.300
次に ここで

00:49:36.300 --> 00:49:39.070
そのフラグをチェックします

00:49:39.070 --> 00:49:40.715
接近しすぎている (too close)

00:49:40.715 --> 00:49:43.965
場合は固定値の 0.224 を

00:49:43.965 --> 00:49:47.030
リファレンス速度から引きます

00:49:47.030 --> 00:49:49.694
この数値は特に意味があるわけではありません

00:49:49.694 --> 00:49:52.890
おおよそ 5 メートル毎秒毎秒になる数値で

00:49:52.890 --> 00:49:55.880
要件 10 に記載されています

00:49:55.880 --> 00:49:57.370
了解

00:49:57.370 --> 00:50:04.538
この設定でどのように車が冒頭で速度を落とすのかよくわからないのですが

00:50:04.538 --> 00:50:07.035
別の車が前方に接近してきた場合に

00:50:07.035 --> 00:50:10.185
減速するだけのように見えます

00:50:10.185 --> 00:50:14.855
はい そのために もう一つやらなければならないことがあります

00:50:14.855 --> 00:50:17.270
ここで開始速度を

00:50:17.270 --> 00:50:20.520
時速 0 マイルにします

00:50:20.520 --> 00:50:22.785
了解これで 速度ゼロでスタートするわけですね

00:50:22.785 --> 00:50:25.808
どのように加速するか見てみます

00:50:25.808 --> 00:50:29.060
実際にコードに含まれています

00:50:29.060 --> 00:50:31.070
了解

00:50:31.070 --> 00:50:33.910
リファレンス速度が 49.5 より小さい場合

00:50:33.910 --> 00:50:36.550
ここで加算します

00:50:36.550 --> 00:50:38.164
わかりました開始点では

00:50:38.164 --> 00:50:39.280
前方に何もないため

00:50:39.280 --> 00:50:41.590
if(too_close) の設定では接近しすぎ (too_close) にはなりません

00:50:41.590 --> 00:50:46.090
コールドスタートで走り出しますが

00:50:46.090 --> 00:50:50.230
else if でリファレンス速度が目的の速度以下の場合は

00:50:50.230 --> 00:50:53.050
ゆっくりと加速するよう設定している ということですね

00:50:53.050 --> 00:50:54.577
そのとおりです

00:50:54.577 --> 00:50:57.960
これによりサイクルごとに増分が行われるようになります

00:50:57.960 --> 00:51:00.485
これをもう少し効率よくすることができます

00:51:00.485 --> 00:51:03.610
パスプランナーを見てみると

00:51:03.610 --> 00:51:08.090
ポイントを通過するごとに参照速度を変更しています

00:51:08.090 --> 00:51:10.870
了解ここのリファレンス速度は

00:51:10.870 --> 00:51:14.475
後で計算されるウェイポイントにどのように影響するのですか?

00:51:14.475 --> 00:51:19.140
はい 最終値に影響します 下の方を見てみると

00:51:19.140 --> 00:51:21.960
ここで渡しています

00:51:21.960 --> 00:51:23.850
ここです

00:51:23.850 --> 00:51:25.828
リファレンス速度を使用しています

00:51:25.828 --> 00:51:27.380
これはトリッキーでしたね気付きもしませんでした

00:51:27.380 --> 00:51:32.765
はいこのループ内でリファレンス速度の足し算や引き算を行う方が

00:51:32.765 --> 00:51:35.280
ずっと効率的になります

00:51:35.280 --> 00:51:37.170
OKわかりました

00:51:37.170 --> 00:51:39.300
では 実行して実際に確認しますか?

00:51:39.300 --> 00:51:39.790
はい

00:51:39.790 --> 00:51:43.060
OK

00:51:45.870 --> 00:51:52.570
OK見てみましょう

00:51:54.280 --> 00:51:57.200
行きますよ

00:51:57.200 --> 00:51:59.230
いやあ 一瞬 動かないのかと思いましたよ

00:51:59.230 --> 00:51:59.463
ええ

00:51:59.463 --> 00:52:00.560
OK見ていきましょう

00:52:00.560 --> 00:52:02.990
バッテリー切れなのかな

00:52:02.990 --> 00:52:05.080
OK進み始めましたどうかな

00:52:05.080 --> 00:52:11.680
うまくいきましたね 49.5 まで行きました

00:52:11.680 --> 00:52:12.350
やったやりましたね

00:52:12.350 --> 00:52:14.820
開始の時にも赤字の最大ジャークの

00:52:14.820 --> 00:52:18.095
超過警告は表示されませんでした

00:52:18.095 --> 00:52:19.920
しかし ここが重要な部分です

00:52:19.920 --> 00:52:24.850
ゆっくりと減速できるでしょうか?

00:52:24.850 --> 00:52:25.610
OK

00:52:25.610 --> 00:52:26.440
そして 減速していますね

00:52:26.440 --> 00:52:29.150
私たちの車がかなり白い車両に接近していきますが

00:52:29.150 --> 00:52:31.340
車は 黒い車は

00:52:31.340 --> 00:52:34.140
私たちの車なんですけど 自車は

00:52:34.140 --> 00:52:36.725
白い車に追突しませんでした

00:52:36.725 --> 00:52:38.358
そして ほら 再び減速しています

00:52:38.358 --> 00:52:41.010
OK やりましたね素晴らしいです15 分待っていたら

00:52:41.010 --> 00:52:42.520
車はトラックを一周しますか?

00:52:42.520 --> 00:52:44.700
はい します

00:52:44.700 --> 00:52:46.110
素晴らしいしかし

00:52:46.110 --> 00:52:48.525
この白い車を追い越せたらもっといいですよね

00:52:48.525 --> 00:52:52.240
そうなんですでは 車線変更について考えてみることにしましょう

00:52:52.240 --> 00:52:55.010
はい 車線変更について考えてみましょう

00:52:55.010 --> 00:52:59.105
ここでまた 私の好きなスプラインライブラリの登場です

00:52:59.105 --> 00:53:05.088
OK失礼よし では

00:53:05.088 --> 00:53:06.430
車線変更についてどうしたらいいでしょうか?

00:53:06.430 --> 00:53:07.930
いつ車線変更させたいですか?

00:53:07.930 --> 00:53:15.270
前の車の速度が遅過ぎで 車線変更をしても安全なときです

00:53:15.270 --> 00:53:19.355
車を減速させるかどうかをチェックする論理がありましたよね?

00:53:19.355 --> 00:53:21.450
ありました私たちの車を減速させていますこれは先ほどやりました

00:53:21.450 --> 00:53:23.875
車間が 30 メートル以内になる場合

00:53:23.875 --> 00:53:27.685
私たちの車を減速させます

00:53:27.685 --> 00:53:30.580
OK ではそこで何らかのコードを実行します

00:53:30.580 --> 00:53:33.220
了解未来に 私たちの車と

00:53:33.220 --> 00:53:36.965
任意の車両との車間が 30 メートル以内になる場合 車線を変更するんですね

00:53:36.965 --> 00:53:37.570
はい

00:53:37.570 --> 00:53:38.390
OKどうしたらいいですか?

00:53:38.390 --> 00:53:48.320
 ここで lane が 0 より大きい場合は

00:53:48.320 --> 00:53:49.844
lane 1 で走り始める とします

00:53:49.844 --> 00:53:51.500
あの中央の車線です

00:53:51.500 --> 00:53:56.825
中央の車線はゼロ とします

00:53:56.825 --> 00:53:58.700
これでどうなるのですか?

00:53:58.700 --> 00:54:03.455
これで実際には私たちの車は左折します

00:54:03.455 --> 00:54:07.270
つまり 中央の車線または右車線にいる場合は

00:54:07.270 --> 00:54:11.780
ささっと素早く左車線に移動するということですね

00:54:11.780 --> 00:54:13.270
これでうまくいくはずです

00:54:13.270 --> 00:54:16.450
この場合 やみくもに左に行きます

00:54:16.450 --> 00:54:16.810
了解

00:54:16.810 --> 00:54:19.355
他の車両が左にいても いなくても行きますはい

00:54:19.355 --> 00:54:20.590
OKわかりましたでは やってみましょう

00:54:20.590 --> 00:54:31.150
make でビルドします

00:54:34.180 --> 00:54:38.490
OK また動かないと思ってしまいます

00:54:38.490 --> 00:54:42.580
まったくOK 見てみましょう

00:54:42.580 --> 00:54:46.620
この車は まだドラッグレースには絶対に出したくないな

00:54:46.620 --> 00:54:49.260
まだですねOK うまいところ走っていますね

00:54:49.260 --> 00:54:50.735
ここは前回確認しました

00:54:50.735 --> 00:54:53.880
車線内を走行しています

00:54:53.880 --> 00:54:55.380
また白い車の後ろにつくのでしょうか

00:54:55.380 --> 00:54:57.630
それとも今回は別の車になるのでしょうか?

00:54:57.630 --> 00:54:58.860
あの赤い車のようです

00:54:58.860 --> 00:55:00.570
赤い車ですか?

00:55:00.570 --> 00:55:03.480
はいおお OKどうなるか見てみましょう

00:55:03.480 --> 00:55:08.880
赤い車が近づいてきましたよ すごい かなり近かったですね

00:55:08.880 --> 00:55:11.175
しかし かなりみごとな車線変更でしたよね

00:55:11.175 --> 00:55:14.389
ジャークの制限も違反しませんでした

00:55:14.389 --> 00:55:17.340
シフトした感じでしたねスプラインがかなり役立っていました

00:55:17.340 --> 00:55:22.860
車がいた位置と 30 メートル先の左車線のあいだに入り込んでいました

00:55:22.860 --> 00:55:24.655
了解車線変更が起きた部分のコードを見せてもらえますか

00:55:24.655 --> 00:55:28.470
スプラインでは正確にはどこに車線変更を挿入していたんですか?

00:55:28.470 --> 00:55:35.030
もちろんです車線はここで更しています

00:55:35.120 --> 00:55:39.450
下の方へ下がっていくと

00:55:39.450 --> 00:55:48.160
あの車線はこのコードの一部で スプラインに足したところです

00:55:48.160 --> 00:55:51.530
車線を 6 とせずに

00:55:51.530 --> 00:55:54.395
2+4*lane にしたため

00:55:54.395 --> 00:55:58.240
車線 6 から 車線 2 に移動するとき

00:55:58.240 --> 00:56:02.720
中央の 0 番目の車線はウェイポイントから 2 メートル離れているため

00:56:02.720 --> 00:56:05.920
車線は 2 になる

00:56:05.920 --> 00:56:12.530
2+4*0 は 2 ということですね

00:56:12.530 --> 00:56:19.640
d 座標によって 2 になるわけですね

00:56:19.640 --> 00:56:21.110
そのとおりです了解

00:56:21.110 --> 00:56:24.320
OKスプラインのウェイポイントが設定されていて

00:56:24.320 --> 00:56:30.103
車の現在のウェイポイントは d = 6 の位置だけれど

00:56:30.103 --> 00:56:35.050
ウェイポイント 30 60 90 メートルと進んでいくと

00:56:35.050 --> 00:56:38.178
d = 2 の位置になり スプラインは

00:56:38.178 --> 00:56:42.195
ゼロから開始する多項式に合わせ  次にシフトするわけですね

00:56:42.195 --> 00:56:44.240
滑らかで連続的になります

00:56:44.240 --> 00:56:47.090
はい また滑らかで連続的なのは間隔の配置のおかげもあります

00:56:47.090 --> 00:56:49.520
30 メートルより少なくすると

00:56:49.520 --> 00:56:52.640
先ほどの車線変更もかなり急激な車線変更になります

00:56:52.640 --> 00:56:54.045
了解それはやめておきます

00:56:54.045 --> 00:56:56.345
そうですねOK 素晴らしい

00:56:56.345 --> 00:57:02.115
とてもよくできましたこれで基本的な車線変更の計算ができました

00:57:02.115 --> 00:57:05.030
行動プランニングのレッスンで見た

00:57:05.030 --> 00:57:08.150
有限状態機械についてはどうですか?

00:57:08.150 --> 00:57:10.400
そうですねどのように組み込むことができますか?

00:57:10.400 --> 00:57:14.670
車線変更はかなりシンプルなコードで行っています

00:57:14.670 --> 00:57:19.520
はい実際には 最初に その車線にいる他の車を確認する方法を

00:57:19.520 --> 00:57:25.265
考えたいと思います 似た論理を使用して 前方に車両がいるかどうかを確認します

00:57:25.265 --> 00:57:27.375
Frenet に戻って

00:57:27.375 --> 00:57:31.475
その車線に車両がいるかどうかをチェックして

00:57:31.475 --> 00:57:36.020
次にその車両が s のギャップ範囲にいるかをチェックすることができます

00:57:36.020 --> 00:57:38.005
範囲にいる場合は 車線変更を行うのは安全ではないということになります

00:57:38.005 --> 00:57:40.280
また 左が安全ではない場合は

00:57:40.280 --> 00:57:43.070
右への変更を試みることができます了解

00:57:43.070 --> 00:57:46.100
左への車線変更 右への

00:57:46.100 --> 00:57:47.660
車線変更 現在の車線の維持をすることができて

00:57:47.660 --> 00:57:51.260
また左への車線変更の際に

00:57:51.260 --> 00:57:55.520
前方 30 メートルか 100 メートル以内に別の車両が見える場合や

00:57:55.520 --> 00:57:58.930
後方 50 メートルに別の車両が見える場合は車線変更を行わないというようなことですね

00:57:58.930 --> 00:58:01.115
あるいは 既に一番左の車線にいる場合は

00:58:01.115 --> 00:58:02.545
道路から外れない

00:58:02.545 --> 00:58:05.120
そう OK有限状態機械でこれらの各状態に

00:58:05.120 --> 00:58:08.290
シフトするときのコードに論理を追加するところから始めるのですね

00:58:08.290 --> 00:58:09.670
そのとおりです了解

00:58:09.670 --> 00:58:14.460
OKいいね いいねいいですね

00:58:14.460 --> 00:58:16.805
このプロジェクトをどうやって開始するかという点で

00:58:16.805 --> 00:58:20.535
いいヒントになると思います

00:58:20.535 --> 00:58:26.730
プロジェクトに合格できる実装になるだろうという意味です

00:58:26.730 --> 00:58:29.005
車線変更によっては衝突する可能性があるため

00:58:29.005 --> 00:58:31.660
そのあたりに注意する必要があるかもしれません

00:58:31.660 --> 00:58:34.200
さっきのはただのまぐれですかなり近かったです

00:58:34.200 --> 00:58:37.055
ここで そろそろ

00:58:37.055 --> 00:58:40.490
生徒の方からの質問に答えていきたいと思います

00:58:40.490 --> 00:58:44.270
そうですねそのあいだ

00:58:44.270 --> 00:58:53.870
ドライビングを見ることにします

00:58:53.870 --> 00:58:58.140
あれ変ですねなぜ突然 車線が変更しているんだろう?

00:58:58.140 --> 00:59:01.565
前方に何かありましたか?なぜだろう

00:59:01.565 --> 00:59:07.380
後方に車両がいて 衝突しそうだったからかも

00:59:07.380 --> 00:59:11.460
真後ろに車両がいたため 完全停止していなかったからかも

00:59:11.460 --> 00:59:15.240
私は C++ 側でリセットしなかったからじゃないかと思います

00:59:15.240 --> 00:59:16.955
たぶん そうかもしれません

00:59:16.955 --> 00:59:22.870
私たちは一番左の車線にいるため これ以上何もできません

00:59:22.870 --> 00:59:25.090
行き詰ってしまいましたね ここでできるのは

00:59:25.090 --> 00:59:27.650
左側に車線があれば左に車線変更することです

00:59:27.650 --> 00:59:32.600
そうですねそう ですから解決できる有限状態機械が必要です

00:59:32.600 --> 00:59:34.390
適切なコスト関数ですね

00:59:34.390 --> 00:59:37.680
適切なコスト関数 はい そうですね

00:59:37.680 --> 00:59:45.300
未来に注目して 5 秒後あたりに走行していると最適な車線はどれかを探してみてください

00:59:45.300 --> 00:59:46.645
そうですねでは 質問に行ってみましょう

00:59:46.645 --> 00:59:50.035
似たような質問を複数の方からいただいています

00:59:50.035 --> 00:59:55.130
最初の質問は イタリアにお住いのセバスティアーノさん

00:59:55.130 --> 00:59:56.780
ニューヨークにお住いのジェイソンさん

00:59:56.780 --> 00:59:58.970
クリス・エドワードさん ナディアさん

00:59:58.970 --> 01:00:01.640
イタリアにお住いのフランチェスコさん

01:00:01.640 --> 01:00:03.640
ニューヨークにお住いのマイケルさん

01:00:03.640 --> 01:00:08.045
 表現は違いますがいろいろな方からプロジェクトを開始するにあたってウォークスルーに対する質問がきています

01:00:08.045 --> 01:00:11.888
レッスンとプロジェクトがうまくつながっていないようです

01:00:11.888 --> 01:00:16.115
レッスンでも重要な部分が見過ごされていて 具体的な例が示されていません

01:00:16.115 --> 01:00:19.280
今回のコースの構成にはがっかりしました

01:00:19.280 --> 01:00:21.930
期待が大きく だまされたかんじです

01:00:21.930 --> 01:00:28.795
本当のことを示していないというわけではないんですが

01:00:28.795 --> 01:00:32.110
がっかりさせてしまったことは申し訳なく思います

01:00:32.110 --> 01:00:34.890
私たちは非常に楽しいプロジェクトだと思っています

01:00:34.890 --> 01:00:37.940
レッスン部分とプロジェクトをうまくつなげるための努力が

01:00:37.940 --> 01:00:42.915
必要かもしれませんね

01:00:42.915 --> 01:00:46.790
ただし 一般的にパスプランニングは最も重要な部分の 1 つであり

01:00:46.790 --> 01:00:48.500
自律型自動車の開発において

01:00:48.500 --> 01:00:51.065
最重要部分になります

01:00:51.065 --> 01:00:52.585
ですから 非常に多くの作業があるため 皆さんの言っていることはよくわかります

01:00:52.585 --> 01:00:55.025
私たちも皆さんに理解いただけるよう努力したいと思います

01:00:55.025 --> 01:00:57.500
先ほど終えたウォークスルーで プロジェクトへの取り組み方

01:00:57.500 --> 01:01:00.800
の感覚を得ていただけたらと思います

01:01:00.800 --> 01:01:04.165
プロジェクトへの取り組み方は ひとつだけではなく いろいろあります

01:01:04.165 --> 01:01:05.870
私がやったときは

01:01:05.870 --> 01:01:08.125
アーロンのやり方とはちょっと違っていました

01:01:08.125 --> 01:01:11.560
アーロンの描いていた n と d は私にはちょっと重かったので

01:01:11.560 --> 01:01:13.460
別のやり方にしました

01:01:13.460 --> 01:01:18.005
思い返してみると

01:01:18.005 --> 01:01:20.660
私が初めてプロジェクトに取り組んだ時にやりたかったことは

01:01:20.660 --> 01:01:23.343
少なくとも車を動かすことだけでした

01:01:23.343 --> 01:01:25.964
そして これはクラスルームのコードで達成することができます

01:01:25.964 --> 01:01:27.680
次に 車を車線内で走行させること

01:01:27.680 --> 01:01:30.013
これはやってみると驚くほど難しい課題でした

01:01:30.013 --> 01:01:34.370
車を車線内で走行させるのは Frenet 座標だけで行うことができます

01:01:34.370 --> 01:01:38.503
さらに難しいのはパスを滑らかにすることです

01:01:38.503 --> 01:01:40.610
これについては質問が来ているようなので

01:01:40.610 --> 01:01:43.100
その時に詳しく説明することにしますが

01:01:43.100 --> 01:01:48.230
今回のウォークスルーではスプラインを使ってパスを滑らかにしました

01:01:48.230 --> 01:01:53.375
車線内で車をうまく走行させることができると

01:01:53.375 --> 01:01:56.000
行動プランニングのレッスンの終わりにある

01:01:56.000 --> 01:02:00.614
ちょっとクイズのような世界に入っていくことになります

01:02:00.614 --> 01:02:03.290
基本的には 任意の車線を走行させる

01:02:03.290 --> 01:02:08.770
別の車線で走行させる そして車線を変更させる方法を探していくことになります

01:02:08.770 --> 01:02:10.730
これを行う方法の 1 つが

01:02:10.730 --> 01:02:12.795
コスト関数を構築する方法で おそらく やりやすい方法になると思います

01:02:12.795 --> 01:02:13.995
これは今回 使用した方法とは異なります

01:02:13.995 --> 01:02:15.800
今回は非常に基本的な方法を用いました

01:02:15.800 --> 01:02:18.560
前方に車が見えたら 左に進路を変える方法です

01:02:18.560 --> 01:02:22.160
ただし 全体的に見ると おそらくコスト関数を使用するのがよいでしょう

01:02:22.160 --> 01:02:25.748
コスト関数では各車線でのコストを考慮に入れ

01:02:25.748 --> 01:02:29.400
予測レッスンまで逆行して作業していきます

01:02:29.400 --> 01:02:31.925
すべての車両が異なるポイントで走行する未来や

01:02:31.925 --> 01:02:35.390
異なる状態 異なる車線でのコスト計算など

01:02:35.390 --> 01:02:42.295
その未来を試行しながら予測することができます

01:02:42.295 --> 01:02:44.720
つまり どう考えるかです

01:02:44.720 --> 01:02:47.030
まず車を動かすところから始めます

01:02:47.030 --> 01:02:49.765
これは基本的にはトラジェクトリーの生成です

01:02:49.765 --> 01:02:51.710
次に 行動プランニング

01:02:51.710 --> 01:02:54.720
どの状態を入れ替えたいのか

01:02:54.720 --> 01:02:55.820
左へ車線変更するのか 右へ変更するのか

01:02:55.820 --> 01:02:59.062
現在の車線を維持するのかなどを考え ここまで到達したら

01:02:59.062 --> 01:03:00.830
未来を予測し

01:03:00.830 --> 01:03:02.920
他の車両の進路計算を試みます

01:03:02.920 --> 01:03:06.710
ガウスナイーブベイズ分類器や他の種類の分類器を使って

01:03:06.710 --> 01:03:12.617
未来で走行させる位置を決定していきます

01:03:12.617 --> 01:03:14.290
実際のパスプランナーでは

01:03:14.290 --> 01:03:16.763
データの流入に合わせてデータを取得し

01:03:16.763 --> 01:03:18.875
物体の未来での位置を予測

01:03:18.875 --> 01:03:22.370
そして行動プランニングで自分なりの決定をして

01:03:22.370 --> 01:03:24.245
最終的にトラジェクトリーを生成します

01:03:24.245 --> 01:03:26.750
このプロジェクトの場合 逆向きに作業するとよいでしょう

01:03:26.750 --> 01:03:29.360
トラジェクトリーの構築から開始して 他には車両がいないと仮定します

01:03:29.360 --> 01:03:31.790
次に 他の車両も想定して 行動プランを構築

01:03:31.790 --> 01:03:35.123
します ここでは未来を気にする必要はありません

01:03:35.123 --> 01:03:38.360
そのあと 未来を想定に入れ 他の車両が

01:03:38.360 --> 01:03:39.740
未来で走行している位置の予測を開始します

01:03:39.740 --> 01:03:41.930
おそらく この順序で考えていくとよいでしょう

01:03:41.930 --> 01:03:44.010
というのが私からのアドバイスです

01:03:44.010 --> 01:03:45.480
アーロン あなたからは何かありますか?

01:03:45.480 --> 01:03:49.345
いいえ そんな感じでとてもいいと思います

01:03:49.345 --> 01:03:52.580
トラジェクトリーについてずっと説明してきましたが

01:03:52.580 --> 01:03:56.090
コスト関数は 車線を変更したり

01:03:56.090 --> 01:03:59.480
クイズを解いたりする場合に

01:03:59.480 --> 01:04:03.620
非常に便利だと思います

01:04:03.620 --> 01:04:07.100
また Frenet もとても役に立ちます

01:04:07.100 --> 01:04:09.650
道路上の他の車両すべてを

01:04:09.650 --> 01:04:13.775
観察し その s, n, d の位置を確認することができます

01:04:13.775 --> 01:04:16.130
Frenet はトラジェクトリーを作成するだけの

01:04:16.130 --> 01:04:18.620
場合は少し厄介ですので スプラインを

01:04:18.620 --> 01:04:21.650
登場させました

01:04:21.650 --> 01:04:25.400
了解いいですねニュージャージーにお住いのティム・トビィさんからの質問です

01:04:25.400 --> 01:04:28.470
スプライン実装について説明してください

01:04:28.470 --> 01:04:33.565
ウォークスルーでスプラインについて少し触れました

01:04:33.565 --> 01:04:35.780
スプラインは基本的に区分的な多項式の関数になります

01:04:35.780 --> 01:04:37.880
そのアンカーポイントまたは Knots と

01:04:37.880 --> 01:04:40.860
呼ばれるところで複数のピースが束ねられます

01:04:40.860 --> 01:04:44.790
そしてそこで何らかの計算を行いピース同士を

01:04:44.790 --> 01:04:47.220
結び付けます これにより 結び目 (knot) の付いた連結が

01:04:47.220 --> 01:04:51.070
スムースになります スプラインのトラジェクトリーが滑らかになるのはこのためです

01:04:51.070 --> 01:04:54.060
このレッスンの観点からいうと

01:04:54.060 --> 01:04:56.215
実装方法は知らなくても構いません

01:04:56.215 --> 01:05:00.130
記述されたコードが用意されているので 単純にそれを利用してください

01:05:00.130 --> 01:05:01.445
使い方は非常に簡単ですので

01:05:01.445 --> 01:05:04.050
覚えるのは使い方だけです

01:05:04.050 --> 01:05:06.655
使い方の違いも非常に簡単に素早く学ぶことができます

01:05:06.655 --> 01:05:09.630
使うときに実行するコマンドは 3 種類のみだからです

01:05:09.630 --> 01:05:12.694
そうです 初期化するだけです

01:05:12.694 --> 01:05:17.640
実際にコード内のスプラインをちょっと見てみましょう

01:05:17.640 --> 01:05:17.774
そうですね

01:05:17.774 --> 01:05:19.380
スプラインの使い方について見てみます

01:05:19.380 --> 01:05:20.200
はい

01:05:20.200 --> 01:05:22.830
tk::spline s; を宣言している

01:05:22.830 --> 01:05:24.553
か所です

01:05:24.553 --> 01:05:29.790
ヘッダーパルスを含めて スプラインを宣言します

01:05:29.790 --> 01:05:31.410
s.set_points です

01:05:31.410 --> 01:05:32.880
ポイントを設定しています

01:05:32.880 --> 01:05:33.900
x と y ですね

01:05:33.900 --> 01:05:40.080
Knots に対するアンカーポイントで スプラインが構成されています

01:05:40.080 --> 01:05:46.470
そして ここからは s と x 値です

01:05:46.470 --> 01:05:47.892
了解

01:05:47.892 --> 01:05:51.380
スプラインに x 値を与え これに該当する y 値をスプラインで受け取ります

01:05:51.380 --> 01:05:52.220
はい

01:05:52.220 --> 01:05:53.663
素晴らしい

01:05:53.663 --> 01:05:55.530
スプラインで気を付けなければならないこ

01:05:55.530 --> 01:05:57.450
との 1 つは 五次多項式やその他で

01:05:57.450 --> 01:06:03.450
注意すべき事項と同様

01:06:03.450 --> 01:06:07.020
スプラインが垂直になり始めたら 同じ x 値の複数の y 値

01:06:07.020 --> 01:06:11.400
や複数の x 値で終了することです

01:06:11.400 --> 01:06:13.470
ここから壊れ始めます

01:06:13.470 --> 01:06:18.060
このため アーロンはあの基礎を作ったのです

01:06:18.060 --> 01:06:20.010
二重の重合転換?

01:06:20.010 --> 01:06:20.650
そうです

01:06:20.650 --> 01:06:21.590
はい

01:06:21.590 --> 01:06:25.500
水平にシフトしています

01:06:25.500 --> 01:06:28.000
計算が簡単になります

01:06:28.000 --> 01:06:32.565
はいそうすると スプラインをシフトする場合に垂直ではなく水平に走るようになります

01:06:32.565 --> 01:06:36.420
1 つの x に対して複数の y 値にならないので

01:06:36.420 --> 01:06:39.862
スプラインから必要なウェイポイントを引っ張ってきたら そのウェイポイントをシフトバックすることができます

01:06:39.862 --> 01:06:40.039
はい

01:06:40.039 --> 01:06:42.069
これですべてうまく動作します

01:06:42.069 --> 01:06:45.885
レッドウッドシティにお住いのダグさん

01:06:45.885 --> 01:06:47.910
ミュンヘンにお住いのフアン・ペドロさん

01:06:47.910 --> 01:06:49.670
サンフランシスコにお住いのコンスタンティンさん

01:06:49.670 --> 01:06:53.825
アトランタにお住いのオリバー・ハッガーさんからの質問です

01:06:53.825 --> 01:06:55.895
複数の計算で作成した複数のトラジェクトリーを滑らかにする

01:06:55.895 --> 01:06:58.630
戦略を教えてください

01:06:58.630 --> 01:07:00.930
ウェイポイントをベースにしたスプラインを作成することで

01:07:00.930 --> 01:07:03.535
滑らかなトラジェクトリーは生成できます

01:07:03.535 --> 01:07:06.630
ところが 次の計算で新しいトラジェクトリーを作成すると

01:07:06.630 --> 01:07:10.950
ジャークがしきい値を頻繁に超えてしまいますわかりました

01:07:10.950 --> 01:07:13.850
前のパスのポイントを使用するのがいいと思います

01:07:13.850 --> 01:07:18.940
前のパスのポイントを使用すると途切れを避けることができます

01:07:18.940 --> 01:07:24.555
単一フレームにそれぞれ新しいパスを作成している場合は注意が必要です

01:07:24.555 --> 01:07:27.150
前のパスのポイントは

01:07:27.150 --> 01:07:29.830
作業の元となるアンカーやリファレンスに再利用できます

01:07:29.830 --> 01:07:33.390
また 私自身 ジャークの問題が発生したときに もっと前のパスのポイントに

01:07:33.390 --> 01:07:37.760
依存させないといけなかったんだと気付きました

01:07:37.760 --> 01:07:41.520
了解トラジェクトリーを滑らかにするテクニックの 1 つとして

01:07:41.520 --> 01:07:43.965
前のパスのポイントを使用すると

01:07:43.965 --> 01:07:46.640
新しいパスと古いパス間の連続性を得ることができます

01:07:46.640 --> 01:07:47.130
はい

01:07:47.130 --> 01:07:49.815
スプライン自体を使用して スプラインに沿って

01:07:49.815 --> 01:07:53.620
ウェイポイントを拾い出します こうすると必ず滑らかになります

01:07:53.620 --> 01:07:58.220
五次多項式の生成リンクでもできます

01:07:58.220 --> 01:08:02.988
トラジェクトリー生成のレッスンで説明しています

01:08:02.988 --> 01:08:05.535
この場合 計算がもう少し増えます

01:08:05.535 --> 01:08:10.390
面倒くさがりなエンジニアの方には スプラインヘッダーファイルが断然お勧めです

01:08:10.390 --> 01:08:14.435
私の場合もスプラインを使用しました

01:08:14.435 --> 01:08:20.700
また 私の場合 アーロンが DNN およびスプラインから

01:08:20.700 --> 01:08:27.695
三角形への投影で行った三角法は使用しませんでした

01:08:27.695 --> 01:08:30.175
代わりに スプラインから

01:08:30.175 --> 01:08:32.970
50 ウェイポイントを引っ張り出したら

01:08:32.970 --> 01:08:36.990
速度が速くなり過ぎないよう 離れすぎている

01:08:36.990 --> 01:08:41.335
ポイントがないか確認を行いました

01:08:41.335 --> 01:08:43.350
離れすぎている場合は元に戻します

01:08:43.350 --> 01:08:46.599
アーロンの行った計算に比べ効率性には欠けるかもしれませんが

01:08:46.599 --> 01:08:48.300
こちらのやり方で少しだけ簡単に

01:08:48.300 --> 01:08:51.405
できました 少しだけね

01:08:51.405 --> 01:08:53.220
それでもうまくいったと思いますよ

01:08:53.220 --> 01:08:53.520
ええ 成功してましたよ

01:08:53.520 --> 01:08:55.375
本当に保証できるかというと実は確信がないんですが

01:08:55.375 --> 01:08:56.650
うまくいっていたように見えました

01:08:56.650 --> 01:08:57.060
はい

01:08:57.060 --> 01:09:00.330
90% はうまくいったと思います

01:09:00.330 --> 01:09:00.872
勉強になりました

01:09:00.872 --> 01:09:02.625
本当に保証できるコードなのかどうかについては

01:09:02.625 --> 01:09:05.480
確信が持てるまで腰を落ち着けて計算を見直さないといけないと思います

01:09:05.480 --> 01:09:08.175
カリフォルニア州レッドウッドシティにお住いのダグさんからの質問です

01:09:08.175 --> 01:09:10.200
 ライブヘルプ機能を使用したとき

01:09:10.200 --> 01:09:12.420
1 人のメンターの方からウェイポイントの地図座標を

01:09:12.420 --> 01:09:15.870
車の座標に転換して それをすべての計算に使用する必要があると指摘されました

01:09:15.870 --> 01:09:17.361
これが適切な方法なのでしょうか?

01:09:17.361 --> 01:09:20.157
この転換のやり方がわかりません

01:09:20.157 --> 01:09:22.140
はい私は素晴らしい方法だと思いますよ

01:09:22.140 --> 01:09:25.135
ローカルの転換に関しては 実際 今回のウォークスルーでも

01:09:25.135 --> 01:09:27.450
まったく同じ方法を用いています

01:09:27.450 --> 01:09:29.330
ではここで確認できますか?

01:09:29.330 --> 01:09:32.170
ええ もちろん見てみましょう。

01:09:32.170 --> 01:09:33.390
まずここで転換していますね

01:09:33.390 --> 01:09:35.630
そして下の方へ行きます

01:09:35.630 --> 01:09:37.845
はい そこで再転換しています

01:09:37.845 --> 01:09:43.380
ただ シフトと回転を行うだけの計算になります

01:09:43.380 --> 01:09:45.690
最初に行ったのはシフトが先で

01:09:45.690 --> 01:09:48.560
そのあと回転だったと思います

01:09:48.560 --> 01:09:52.943
スクロールアップして確認してみてください

01:09:52.943 --> 01:09:54.625
そうですね

01:09:54.625 --> 01:09:58.435
ここでシフトを先に行ってから 回転しています

01:09:58.435 --> 01:10:03.330
これには非常に便利な理由がいくつかあります

01:10:03.330 --> 01:10:07.405
最初に これは MPC に展開しているため

01:10:07.405 --> 01:10:10.280
計算が非常に簡単になります

01:10:10.280 --> 01:10:13.260
また 垂直に近くなったり 急上昇したりする

01:10:13.260 --> 01:10:16.750
関数にはならなくなります

01:10:16.750 --> 01:10:19.560
ポイントをスプラインに合わせようとしていたので

01:10:19.560 --> 01:10:25.005
この作業がかなり楽になりました

01:10:25.005 --> 01:10:27.720
作業しているのが x 軸のみだったためです

01:10:27.720 --> 01:10:31.020
角度のある別の線を作らず

01:10:31.020 --> 01:10:34.882
そこから作業できます

01:10:34.882 --> 01:10:38.025
台湾にお住いのシン・チェンさんからの質問です

01:10:38.025 --> 01:10:42.990
このプロジェクトで有限状態機械はハイブリッド A* とどのように連携するのですか?

01:10:42.990 --> 01:10:45.905
このプロジェクトで有限状態機械はハイブリッド A* とどのように連携するのですか?

01:10:45.905 --> 01:10:49.280
これについて以前 議論したと思います

01:10:49.280 --> 01:10:51.140
たしか 私が勝ったと記憶しています私が勝ったのでしたよね?

01:10:51.140 --> 01:10:52.110
はい そうだったと思います

01:10:52.110 --> 01:10:54.896
そう 勝ったんですこのプロジェクトに

01:10:54.896 --> 01:10:57.415
ハイブリッド A* を使うのは意味がありますか?

01:10:57.415 --> 01:11:02.995
ないと思います ハイブリッド A* は駐車場などの環境の方が適しています

01:11:02.995 --> 01:11:05.400
今回のような幹線道路では

01:11:05.400 --> 01:11:09.095
コスト関数を使用する方が道理にかなっていると思います

01:11:09.095 --> 01:11:12.685
はい

01:11:12.685 --> 01:11:15.570
幹線道路の場合は 物体が非常にまばらな環境のため

01:11:15.570 --> 01:11:19.260
非常に多くの戦略が考えられます そのなかで 最も低コストな戦略を

01:11:19.260 --> 01:11:23.100
選択します 一方 ハイブリッド A* は選択肢が

01:11:23.100 --> 01:11:28.061
限られる密度の高い環境により適していると言えます

01:11:28.061 --> 01:11:32.130
また 離散化された選択肢などです

01:11:32.130 --> 01:11:35.520
これはより連続的な環境になります

01:11:35.520 --> 01:11:39.405
幹線道路にグリッドを配してハイブリッドスターを

01:11:39.405 --> 01:11:40.876
使用したらうまく行くと思いますが

01:11:40.876 --> 01:11:44.490
コスト関数か有限状態機械を使用する方がここでは適切な選択のように思えます

01:11:44.490 --> 01:11:46.710
その方がより一般的な見方ではないかと思いますが

01:11:46.710 --> 01:11:49.425
その人により有限状態機械とハイブリッドスターを

01:11:49.425 --> 01:11:52.360
併用する場合もあるかもしれません

01:11:52.360 --> 01:11:53.880
やってみると意外と面白いかもしれませんね

01:11:53.880 --> 01:11:55.860
それを行っている研究論文もおそらく発表されていると思います

01:11:55.860 --> 01:11:58.740
ただ なぜそれをするのか理由が思いつきません

01:11:58.740 --> 01:12:03.220
誰かがその戦略を使用しているなら 非常に興味があります

01:12:03.220 --> 01:12:09.440
OKサンディエゴにお住いのクリス・エドワードさんから highway_map.txt で「s」が冗長になっていないのはなぜですか?

01:12:09.440 --> 01:12:11.700
非常に簡単に計算できますよね?

01:12:11.700 --> 01:12:14.400
万一に備えて両方に含ませています

01:12:14.400 --> 01:12:19.110
また 冒頭の方でフェッチしている地図のウェイポイント s があるため

01:12:19.110 --> 01:12:21.530
ヘルパー関数で使用されています

01:12:21.530 --> 01:12:25.765
OK計算するのが面倒なように私には思えます

01:12:25.765 --> 01:12:28.150
間違いなく可能ではありますただ ベクターの計算をする必要があります

01:12:28.150 --> 01:12:31.360
あるいは いずれかのヘルパー関数を使って s をとることもできます

01:12:31.360 --> 01:12:33.190
OKヘルパー関数があるんだね

01:12:33.190 --> 01:12:35.310
s はいろいろなところに含まれています

01:12:35.310 --> 01:12:35.364
はい そうですね大事な点ですね

01:12:35.364 --> 01:12:36.885
ローカライゼーションデータにも含まれています

01:12:36.885 --> 01:12:38.820
地図のウェイポイントにも含まれています

01:12:38.820 --> 01:12:41.460
ロンドンにお住いのアイバン・ダノーブさんから

01:12:41.460 --> 01:12:45.795
Frenet をトラジェクトリー生成と行動プランニングの両方に使用できますか?

01:12:45.795 --> 01:12:49.410
グローバルのデカルト座標に戻すタイミングと

01:12:49.410 --> 01:12:54.325
変換の誤りによるジャークを避ける方法を教えてください

01:12:54.325 --> 01:13:02.515
トラジェクトリーの生成と行動プランニングの両方に Frenet を使用できると思います

01:13:02.515 --> 01:13:05.220
トラジェクトリーを生成する場合 最終的には xy グローバル

01:13:05.220 --> 01:13:08.520
座標を元に戻す必要があります

01:13:08.520 --> 01:13:12.570
ジャークを避ける方法については

01:13:12.570 --> 01:13:17.250
先ほども話しましたが パスを滑らかにする

01:13:17.250 --> 01:13:20.775
スプラインを正確に読み取る

01:13:20.775 --> 01:13:27.210
ウェイポイントとスプライン間のジャークを最小化するなどですね

01:13:27.210 --> 01:13:29.295
ミュンヘンにお住いのフアン・ペドロさんから

01:13:29.295 --> 01:13:34.185
シミュレーターの加速表示が不正確なのですがどのように対処すればよいですか?

01:13:34.185 --> 01:13:38.190
トラジェクトリー内の連続するポイントセットから推測したり

01:13:38.190 --> 01:13:42.680
シミュレーターの更新間隔の時間を測定して速度の変化を使用すればよいのでしょうか?

01:13:42.680 --> 01:13:46.710
トラジェクトリーを計算する際に終了/開始の加速をゼロに強制して

01:13:46.710 --> 01:13:52.140
トラジェクトリーの端どうしをくっつければよいのでしょうか?

01:13:52.140 --> 01:13:56.115
コード内の加速値をチェックしてみてください

01:13:56.115 --> 01:14:01.090
シミュレーターでは一定の時間 恐らく 1 秒間隔くらいで平均を求めているだけですから

01:14:03.635 --> 01:14:07.565
実際にはそれは平均なんです

01:14:07.565 --> 01:14:12.765
ただし そのトラジェクトリー生成自体を行っている場合

01:14:12.765 --> 01:14:16.365
五次多項式解法など 一般的には

01:14:16.365 --> 01:14:21.670
開始と終了の両方でゼロ加速を使用しています

01:14:21.670 --> 01:14:28.080
はい一般的に 絶対に加速制限を超えないようにする場合は

01:14:28.080 --> 01:14:35.830
計算を行ってコードで検証すると役に立つと思います

01:14:35.830 --> 01:14:36.443
はい

01:14:36.443 --> 01:14:40.290
見てきたようにアーロンのコードでうまくいっているので

01:14:40.290 --> 01:14:44.800
スプラインに関連しているのではないかと推測します

01:14:44.800 --> 01:14:46.215
オーストリアにお住いのオーレグさんから

01:14:46.215 --> 01:14:49.590
状態遷移関数でトラジェクトリーを生成する方法を教えてください

01:14:49.590 --> 01:14:53.490
(可能性のある次の各状態のコスト計算をする場合)

01:14:53.490 --> 01:14:59.580
状態が PLCL (左へ車線変更の準備) で水平 5 でトラジェクトリーを生成する場合

01:14:59.580 --> 01:15:02.600
次のステップにはどの状態をとるべきですか?

01:15:02.600 --> 01:15:05.010
車線変更をする場合は 別々のアンカーポイントを使って

01:15:05.010 --> 01:15:08.280
いくつか異なる候補のスプラインを計算できます

01:15:08.280 --> 01:15:11.348
その各スプラインでジャークを計算してから

01:15:11.348 --> 01:15:14.400
ジャークが最も少ないスプラインを選択します

01:15:14.400 --> 01:15:20.545
トラジェクトリーを生成するレッスンで説明しました

01:15:20.545 --> 01:15:23.925
ジャークを最小化するトラジェクトリーを使用することもできます

01:15:23.925 --> 01:15:25.770
JMT に説明されています

01:15:25.770 --> 01:15:27.900
そのレッスンでも説明しています

01:15:27.900 --> 01:15:32.430
ただし 五次多項式を使用するため 今回のウォークスルーで説明したものとは異なります

01:15:32.430 --> 01:15:35.520
トラジェクトリーの状態遷移関数での生成について

01:15:35.520 --> 01:15:39.925
何かよいアドバイスはありますか?

01:15:39.925 --> 01:15:43.560
はいいくつか異なるアンカーポイントを使用して 実際にそれぞれの

01:15:43.560 --> 01:15:48.610
加速変化を計算するというのはいい案だと思います

01:15:48.610 --> 01:15:50.460
興味深い方法ですね

01:15:50.460 --> 01:15:53.040
今回行ったのは 微調整に

01:15:53.040 --> 01:15:56.190
使用できるメートル距離を持たせ

01:15:56.190 --> 01:15:58.620
車線変更があまり急激に

01:15:58.620 --> 01:16:02.630
起こらないよう変更しました

01:16:02.630 --> 01:16:05.480
うまく調整できたと思います

01:16:05.480 --> 01:16:08.550
ただし 低レベルでうまくいったら

01:16:08.550 --> 01:16:12.260
車線の維持や左へ車線変更の準備など

01:16:12.260 --> 01:16:16.455
より高い状態を積み上げて定義することができます

01:16:16.455 --> 01:16:19.200
次に その行動プランニング

01:16:19.200 --> 01:16:22.410
のクイズ コスト関数の使用

01:16:22.410 --> 01:16:27.095
水平を持たせるという順序で進んでいきます

01:16:27.095 --> 01:16:27.541
了解

01:16:27.541 --> 01:16:29.781
オーストリアにお住いのオーレグさんから

01:16:29.781 --> 01:16:32.130
状態 PLCL/R (左/右へ車線変更の準備) の背後に

01:16:32.130 --> 01:16:35.715
実装すべき論理は何ですか?

01:16:35.715 --> 01:16:40.500
目的の車線の速度の方が早い場合は

01:16:40.500 --> 01:16:43.515
速度を増やすべきですか? あるいは進路ギャップを先に増やすべきですか?

01:16:43.515 --> 01:16:46.455
速度を増やした結果 前の車に追突する場合はどうしたらいいですか?

01:16:46.455 --> 01:16:49.080
目的の車線の速度の方が遅い場合は

01:16:49.080 --> 01:16:53.340
車線変更の前に速度を落とすのか 変更してから速度を落とすのか どちらですか?

01:16:53.340 --> 01:16:54.620
非常に多くの選択肢があります

01:16:54.620 --> 01:16:57.810
一番安全な方法は 一般的には速度を落とすことだと思います

01:16:57.810 --> 01:17:00.600
この車線に移動しようとする場合 車両を選び出し

01:17:00.600 --> 01:17:04.270
その車両のすぐ後ろに車線変更をします

01:17:04.270 --> 01:17:10.950
はいPrepare Lane Change を使用する主な理由は

01:17:10.950 --> 01:17:14.040
左に車線変更したいまたは右に車線変更したいが

01:17:14.040 --> 01:17:17.800
別の車両がいるため変更できない場合です

01:17:17.800 --> 01:17:22.410
まさにここを予測するわけです

01:17:22.410 --> 01:17:24.630
予測レッスンでの内容が役立つ部分です

01:17:24.630 --> 01:17:27.310
左側で並走していて

01:17:27.310 --> 01:17:30.690
自分の車の車線変更を妨げている車両

01:17:30.690 --> 01:17:32.295
この車両が速度を上げるのか上げないのかを予測します

01:17:32.295 --> 01:17:35.010
その車両が速度を上げる場合 こちらは一定の速度を保っていれば

01:17:35.010 --> 01:17:37.845
車線変更できるギャップが開きます その車両がスピードを落とす場合

01:17:37.845 --> 01:17:44.410
可能であればこちらが速度をあげれば車線変更できます

01:17:44.410 --> 01:17:48.540
基本的には 未来を予測して ギャップができるタイミングと

01:17:48.540 --> 01:17:58.255
そのギャップに移動する最適な方法を計算します

01:17:58.255 --> 01:18:01.680
このため 選択肢がいくつかあります

01:18:01.680 --> 01:18:05.760
はいそれがプロジェクトの要点で 醍醐味となる部分ですね

01:18:05.760 --> 01:18:07.628
そうです そうですクリオさんから

01:18:07.628 --> 01:18:12.075
main.cpp のコードに戸惑っています int NextWaypoint の関数の部分です

01:18:12.075 --> 01:18:18.165
角度変数が何を表しているのかわかりません

01:18:18.165 --> 01:18:20.890
なぜ角度が pi/4 より大きくなければならないのですか?

01:18:20.890 --> 01:18:22.875
もう少し詳しく教えて頂けると助かります

01:18:22.875 --> 01:18:25.110
NextWaypoint 関数の役割を教えてください

01:18:25.110 --> 01:18:30.495
角度とは車の角度であり

01:18:30.495 --> 01:18:35.450
基本的には車の進行方向にあるウェイポイント示しています

01:18:35.450 --> 01:18:38.220
車の位置に近いが進行方向とは

01:18:38.220 --> 01:18:42.210
異なるウェイポイントは避けたいわけです

01:18:42.210 --> 01:18:50.450
また 基本的に pi/4 つまり 45 度は進行方向の範囲を指定しています

01:18:50.450 --> 01:18:55.050
ここでは三角法が関係してくるのですが

01:18:55.050 --> 01:18:59.670
そのウェイポイントがその角度に合っているかを確認しています

01:18:59.670 --> 01:19:02.220
デトロイトにお住いのクリス・チャンさんから

01:19:02.220 --> 01:19:05.065
プロジェクトに使用する主なソフトウェアコンポーネントは何ですか?

01:19:05.065 --> 01:19:08.430
JMT コスト関数 FSM などですか?

01:19:08.430 --> 01:19:11.040
速度加速やジャーク制限の違反を避ける場合

01:19:11.040 --> 01:19:14.455
特に注意すべき点は何ですか?

01:19:14.455 --> 01:19:19.025
ここで使用した主なものは

01:19:19.025 --> 01:19:25.020
Frenet 座標と パスを滑らかにするもの

01:19:25.020 --> 01:19:28.900
五次多項式かスプライン あるいはその他のものですね

01:19:28.900 --> 01:19:38.220
また有限状態機械を使用して戦略に応じた計算を行います

01:19:38.220 --> 01:19:43.200
最低限 これだけは必要だと思いますが

01:19:43.200 --> 01:19:46.260
無限に複雑にすることもでき 特に

01:19:46.260 --> 01:19:49.170
状態を追加してできるだけ早くトラフィックを操作することも可能です

01:19:49.170 --> 01:19:51.940
サンフランシスコにお住いのコンスタンティン サンホセにお住いのジャン・フランソワから

01:19:51.940 --> 01:19:53.715
発音は正しかった?

01:19:53.715 --> 01:19:55.920
大丈夫かな

01:19:55.920 --> 01:19:59.950
ソリューションの達成に JMT とスプラインを併用する方法について教えてください

01:19:59.950 --> 01:20:01.480
私はどちらか一方だと思うのですが どう思います?

01:20:01.480 --> 01:20:03.500
はい私もいずれか一方だと思います

01:20:03.500 --> 01:20:04.960
基本的にはパスを滑らかにしようとしているので

01:20:04.960 --> 01:20:07.588
JMT かスプラインのいずれかを使用すればいいと思います

01:20:07.588 --> 01:20:10.610
ドイツにお住いのフランク・シュナイダーさんから

01:20:10.610 --> 01:20:14.660
getFrenetMethod では theta に何を使用すればいいですか?

01:20:14.660 --> 01:20:20.560
距離のある座標を転換すると 車の進行方向によって外れた s 値が生成されます

01:20:20.560 --> 01:20:23.240
それは転換の非線形性が原因と思われます

01:20:23.240 --> 01:20:27.680
私たちも進路の特定のエッジで確認しています

01:20:27.680 --> 01:20:31.560
この種の s と d 値を使用すると

01:20:31.560 --> 01:20:36.235
車がそのエッジ付近にいる場合 値が近接して計算されます

01:20:36.235 --> 01:20:38.690
少しだけ外れているだけかもしれません

01:20:38.690 --> 01:20:42.760
了解僕はそのプランは実装しなかったけどね アーロン

01:20:42.760 --> 01:20:44.870
mask もいつでも変えることができますよ

01:20:44.870 --> 01:20:51.260
フレドリックさんから s_dot_dot の計算の仕方を教えてください

01:20:51.260 --> 01:20:54.585
s は Frenet 座標で私たちの位置になります

01:20:54.585 --> 01:20:57.025
s_dot は私たちの速度無制限の座標になります

01:20:57.025 --> 01:21:01.310
s_dot_dot は私たちの加速無制限の座標になります

01:21:01.310 --> 01:21:05.210
速度となる s_dot の計算方法を考える場合

01:21:05.210 --> 01:21:09.920
基本的には 1 つのポイントを計算してから次のポイントを計算します

01:21:09.920 --> 01:21:13.130
すると 車が毎秒 50 ポイントで走行する

01:21:13.130 --> 01:21:17.060
またはシミュレーターが毎秒 50 ポイントで動作することがわかります

01:21:17.060 --> 01:21:19.477
ひとつのポイントから

01:21:19.477 --> 01:21:22.880
別のポイントへの距離をとったら (失礼)

01:21:22.880 --> 01:21:27.635
その距離を 0.02 で割ります

01:21:27.635 --> 01:21:34.890
これが毎秒 50 ポイントになり 速度がわかります

01:21:34.890 --> 01:21:37.335
s_dot が得られますs_dot_dot を計算するため

01:21:37.335 --> 01:21:42.565
速度の変化を計算します

01:21:42.565 --> 01:21:44.900
つまり 任意のポイントとポイント間の速度と

01:21:44.900 --> 01:21:48.305
別のポイント間の速度を計算するわけです

01:21:48.305 --> 01:21:53.390
そしてすべてのポイントを通過するのにかかった時間で割ると

01:21:53.390 --> 01:21:59.775
s_dot_dot が得られます

01:21:59.775 --> 01:22:02.390
xy 座標でも同じです

01:22:02.390 --> 01:22:04.395
単純な座標の変換です

01:22:04.395 --> 01:22:07.190
パスプランニングプロジェクトのウォークスルーにご参加いただきありがとうございました

01:22:07.190 --> 01:22:09.795
これはかなり難しいプロジェクトですが

01:22:09.795 --> 01:22:11.270
同時に 本当に楽しいプロジェクトでもあります

01:22:11.270 --> 01:22:14.105
かなり巧妙な実装が可能です

01:22:14.105 --> 01:22:17.810
このプロジェクトやこれ以外のプロジェクトでも シミュレーターの

01:22:17.810 --> 01:22:22.240
構築に費やされたアーロンの努力は素晴らしいものがあります

01:22:22.240 --> 01:22:25.010
アーロンのおかげでプロジェクトは

01:22:25.010 --> 01:22:29.030
期待以上に楽しいものになりました

01:22:29.030 --> 01:22:31.910
皆さんも楽しんでいただけると思いますこのウォークスルーでプロジェクトにどのようにアプローチすべきか

01:22:31.910 --> 01:22:36.905
感覚を得ていただければ幸いです

01:22:36.905 --> 01:22:39.860
私たちは Slack およびフォーラムにいます

01:22:39.860 --> 01:22:44.210
質問があれば答えていきたいと思いますので

01:22:44.210 --> 01:22:46.480
ぜひ 質問してみてください

01:22:46.480 --> 01:22:49.600
はいということで さよなら バイバイ!

