WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:05.653
一旦我们的聚合算法识别了聚合以及原型轨迹

00:00:05.653 --> 00:00:09.474
在这个例子中是三个聚集以及三个原型轨迹

00:00:09.474 --> 00:00:14.144
我们便可以开始为我们在路上碰到的车辆做在线预测工作了

00:00:14.144 --> 00:00:18.239
首先 我们观察该车的部分轨迹

00:00:18.239 --> 00:00:20.279
接下来 我们将轨迹与

00:00:20.280 --> 00:00:24.810
每个聚合的原型轨迹的对应节作比较

00:00:24.809 --> 00:00:27.149
这种比较是通过使用

00:00:27.149 --> 00:00:32.269
我们先前使用的同样的相似度测量来完成的

00:00:32.270 --> 00:00:35.700
每个聚集对应的预期被更新

00:00:35.700 --> 00:00:39.885
更新是基于部分轨迹和原型轨迹的相似性来完成的

00:00:39.884 --> 00:00:43.754
最后 我们为每个聚集计算一个预测轨迹

00:00:43.755 --> 00:00:48.250
例如 将最相似的原型轨迹作为结果轨迹

00:00:48.250 --> 00:00:51.674
我们来更清楚地说明一下

00:00:51.674 --> 00:00:56.004
通过跟踪这辆车 从 T=0 时刻到 T=1 时刻

00:00:56.005 --> 00:00:58.475
现在 我们来按照以上步骤操作一下

00:00:58.475 --> 00:01:03.270
第一步 我们观察时间0和时间1之间的部分轨迹

00:01:03.270 --> 00:01:06.355
也就是车辆后面的绿色线段

00:01:06.355 --> 00:01:12.600
第二步 因为所有的原型轨迹在这一点互相叠加

00:01:12.599 --> 00:01:17.980
轨迹比较步骤将为每个聚合生成同样的几率大小

00:01:17.980 --> 00:01:24.449
第三步 尽管当前并没有哪个原型轨迹好于其他轨迹

00:01:24.450 --> 00:01:28.170
我们依然会选择一条原型轨迹来代表每个聚合

00:01:28.170 --> 00:01:33.480
然后我们将这三条轨迹以及伴随的几率广播出去

00:01:33.480 --> 00:01:38.430
接下来 当 t=2 时候 事情开始变得有意思起来

00:01:38.430 --> 00:01:45.640
首先 让我们把车拿掉 这样我们能更清晰地观察轨迹

00:01:45.640 --> 00:01:48.030
现在 当我们把部分轨迹和

00:01:48.030 --> 00:01:52.004
九条原型轨迹比较的时候

00:01:52.004 --> 00:01:55.079
我们会发现这辆车的部分轨迹

00:01:55.079 --> 00:02:00.674
与红色轨迹更加相似 而非紫色或者蓝色

00:02:00.674 --> 00:02:06.489
当我们更新轨迹伴随的几率时 我们可能会得到类似这样的结果

00:02:06.489 --> 00:02:13.495
请注意 红色轨迹的几率增加 而紫色和蓝色几率缩减

00:02:13.495 --> 00:02:20.879
蓝色缩减程度大于紫色 因为待测量轨迹和蓝色轨迹最不能匹配

00:02:20.879 --> 00:02:23.789
然后 我们为每个聚合选择最匹配的原型轨迹 

00:02:23.789 --> 00:02:28.259
并使用它们来代表车辆的未来轨迹

00:02:28.259 --> 00:02:30.347
当我们我们继续以上过程时

00:02:30.348 --> 00:02:34.000
我们可以看到 红色聚合对应的可能性快速地接近值1

